impl ::core::default::Default for ADVISE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ADVISE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ADVISE_TYPE").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for ADVISE_TYPE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for ADVISE_TYPE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for ADVISE_TYPE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for ADVISE_TYPE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for ADVISE_TYPE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for ALLOCATOR_PROPERTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for ALLOCATOR_PROPERTIES {
    fn eq(&self, other: &Self) -> bool {
        self.cBuffers == other.cBuffers && self.cbBuffer == other.cbBuffer && self.cbAlign == other.cbAlign && self.cbPrefix == other.cbPrefix
    }
}
impl ::core::cmp::Eq for ALLOCATOR_PROPERTIES {}
impl ::core::fmt::Debug for ALLOCATOR_PROPERTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ALLOCATOR_PROPERTIES").field("cBuffers", &self.cBuffers).field("cbBuffer", &self.cbBuffer).field("cbAlign", &self.cbAlign).field("cbPrefix", &self.cbPrefix).finish()
    }
}
impl ::core::default::Default for AMCOPPCommand {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMCOPPCommand {
    fn eq(&self, other: &Self) -> bool {
        self.macKDI == other.macKDI && self.guidCommandID == other.guidCommandID && self.dwSequence == other.dwSequence && self.cbSizeData == other.cbSizeData && self.CommandData == other.CommandData
    }
}
impl ::core::cmp::Eq for AMCOPPCommand {}
impl ::core::fmt::Debug for AMCOPPCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMCOPPCommand").field("macKDI", &self.macKDI).field("guidCommandID", &self.guidCommandID).field("dwSequence", &self.dwSequence).field("cbSizeData", &self.cbSizeData).field("CommandData", &self.CommandData).finish()
    }
}
impl ::core::default::Default for AMCOPPSignature {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMCOPPSignature {
    fn eq(&self, other: &Self) -> bool {
        self.Signature == other.Signature
    }
}
impl ::core::cmp::Eq for AMCOPPSignature {}
impl ::core::fmt::Debug for AMCOPPSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMCOPPSignature").field("Signature", &self.Signature).finish()
    }
}
impl ::core::default::Default for AMCOPPStatusInput {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMCOPPStatusInput {
    fn eq(&self, other: &Self) -> bool {
        self.rApp == other.rApp && self.guidStatusRequestID == other.guidStatusRequestID && self.dwSequence == other.dwSequence && self.cbSizeData == other.cbSizeData && self.StatusData == other.StatusData
    }
}
impl ::core::cmp::Eq for AMCOPPStatusInput {}
impl ::core::fmt::Debug for AMCOPPStatusInput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMCOPPStatusInput").field("rApp", &self.rApp).field("guidStatusRequestID", &self.guidStatusRequestID).field("dwSequence", &self.dwSequence).field("cbSizeData", &self.cbSizeData).field("StatusData", &self.StatusData).finish()
    }
}
impl ::core::default::Default for AMCOPPStatusOutput {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMCOPPStatusOutput {
    fn eq(&self, other: &Self) -> bool {
        self.macKDI == other.macKDI && self.cbSizeData == other.cbSizeData && self.COPPStatus == other.COPPStatus
    }
}
impl ::core::cmp::Eq for AMCOPPStatusOutput {}
impl ::core::fmt::Debug for AMCOPPStatusOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMCOPPStatusOutput").field("macKDI", &self.macKDI).field("cbSizeData", &self.cbSizeData).field("COPPStatus", &self.COPPStatus).finish()
    }
}
impl ::core::default::Default for AMExtendedSeekingCapabilities {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMExtendedSeekingCapabilities {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMExtendedSeekingCapabilities").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMMSF_MMS_INIT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMMSF_MMS_INIT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMMSF_MMS_INIT_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for AMMSF_MMS_INIT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for AMMSF_MMS_INIT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for AMMSF_MMS_INIT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for AMMSF_MMS_INIT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for AMMSF_MMS_INIT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for AMMSF_MS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMMSF_MS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMMSF_MS_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for AMMSF_MS_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for AMMSF_MS_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for AMMSF_MS_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for AMMSF_MS_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for AMMSF_MS_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for AMMSF_RENDER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMMSF_RENDER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMMSF_RENDER_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for AMMSF_RENDER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for AMMSF_RENDER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for AMMSF_RENDER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for AMMSF_RENDER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for AMMSF_RENDER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for AMOVERLAYFX {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMOVERLAYFX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMOVERLAYFX").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMPROPERTY_PIN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMPROPERTY_PIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMPROPERTY_PIN").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMPlayListEventFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMPlayListEventFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMPlayListEventFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMPlayListFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMPlayListFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMPlayListFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMPlayListItemFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMPlayListItemFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMPlayListItemFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMTVAudioEventType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMTVAudioEventType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMTVAudioEventType").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMTunerEventType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMTunerEventType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMTunerEventType").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMTunerModeType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMTunerModeType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMTunerModeType").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMTunerSignalStrength {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMTunerSignalStrength {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMTunerSignalStrength").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMTunerSubChannel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMTunerSubChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMTunerSubChannel").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMVABUFFERINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMVABUFFERINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwTypeIndex == other.dwTypeIndex && self.dwBufferIndex == other.dwBufferIndex && self.dwDataOffset == other.dwDataOffset && self.dwDataSize == other.dwDataSize
    }
}
impl ::core::cmp::Eq for AMVABUFFERINFO {}
impl ::core::fmt::Debug for AMVABUFFERINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVABUFFERINFO").field("dwTypeIndex", &self.dwTypeIndex).field("dwBufferIndex", &self.dwBufferIndex).field("dwDataOffset", &self.dwDataOffset).field("dwDataSize", &self.dwDataSize).finish()
    }
}
impl ::core::default::Default for AMVABeginFrameInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMVABeginFrameInfo {
    fn eq(&self, other: &Self) -> bool {
        self.dwDestSurfaceIndex == other.dwDestSurfaceIndex && self.pInputData == other.pInputData && self.dwSizeInputData == other.dwSizeInputData && self.pOutputData == other.pOutputData && self.dwSizeOutputData == other.dwSizeOutputData
    }
}
impl ::core::cmp::Eq for AMVABeginFrameInfo {}
impl ::core::fmt::Debug for AMVABeginFrameInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVABeginFrameInfo").field("dwDestSurfaceIndex", &self.dwDestSurfaceIndex).field("pInputData", &self.pInputData).field("dwSizeInputData", &self.dwSizeInputData).field("pOutputData", &self.pOutputData).field("dwSizeOutputData", &self.dwSizeOutputData).finish()
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::default::Default for AMVACompBufferInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AMVAEndFrameInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMVAEndFrameInfo {
    fn eq(&self, other: &Self) -> bool {
        self.dwSizeMiscData == other.dwSizeMiscData && self.pMiscData == other.pMiscData
    }
}
impl ::core::cmp::Eq for AMVAEndFrameInfo {}
impl ::core::fmt::Debug for AMVAEndFrameInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVAEndFrameInfo").field("dwSizeMiscData", &self.dwSizeMiscData).field("pMiscData", &self.pMiscData).finish()
    }
}
impl ::core::default::Default for AMVAInternalMemInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMVAInternalMemInfo {
    fn eq(&self, other: &Self) -> bool {
        self.dwScratchMemAlloc == other.dwScratchMemAlloc
    }
}
impl ::core::cmp::Eq for AMVAInternalMemInfo {}
impl ::core::fmt::Debug for AMVAInternalMemInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVAInternalMemInfo").field("dwScratchMemAlloc", &self.dwScratchMemAlloc).finish()
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::default::Default for AMVAUncompBufferInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::default::Default for AMVAUncompDataInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AMVPDATAINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AMVPDATAINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwMicrosecondsPerField == other.dwMicrosecondsPerField && self.amvpDimInfo == other.amvpDimInfo && self.dwPictAspectRatioX == other.dwPictAspectRatioX && self.dwPictAspectRatioY == other.dwPictAspectRatioY && self.bEnableDoubleClock == other.bEnableDoubleClock && self.bEnableVACT == other.bEnableVACT && self.bDataIsInterlaced == other.bDataIsInterlaced && self.lHalfLinesOdd == other.lHalfLinesOdd && self.bFieldPolarityInverted == other.bFieldPolarityInverted && self.dwNumLinesInVREF == other.dwNumLinesInVREF && self.lHalfLinesEven == other.lHalfLinesEven && self.dwReserved1 == other.dwReserved1
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AMVPDATAINFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AMVPDATAINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVPDATAINFO")
            .field("dwSize", &self.dwSize)
            .field("dwMicrosecondsPerField", &self.dwMicrosecondsPerField)
            .field("amvpDimInfo", &self.amvpDimInfo)
            .field("dwPictAspectRatioX", &self.dwPictAspectRatioX)
            .field("dwPictAspectRatioY", &self.dwPictAspectRatioY)
            .field("bEnableDoubleClock", &self.bEnableDoubleClock)
            .field("bEnableVACT", &self.bEnableVACT)
            .field("bDataIsInterlaced", &self.bDataIsInterlaced)
            .field("lHalfLinesOdd", &self.lHalfLinesOdd)
            .field("bFieldPolarityInverted", &self.bFieldPolarityInverted)
            .field("dwNumLinesInVREF", &self.dwNumLinesInVREF)
            .field("lHalfLinesEven", &self.lHalfLinesEven)
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AMVPDIMINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AMVPDIMINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwFieldWidth == other.dwFieldWidth && self.dwFieldHeight == other.dwFieldHeight && self.dwVBIWidth == other.dwVBIWidth && self.dwVBIHeight == other.dwVBIHeight && self.rcValidRegion == other.rcValidRegion
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AMVPDIMINFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AMVPDIMINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVPDIMINFO").field("dwFieldWidth", &self.dwFieldWidth).field("dwFieldHeight", &self.dwFieldHeight).field("dwVBIWidth", &self.dwVBIWidth).field("dwVBIHeight", &self.dwVBIHeight).field("rcValidRegion", &self.rcValidRegion).finish()
    }
}
impl ::core::default::Default for AMVPSIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AMVPSIZE {
    fn eq(&self, other: &Self) -> bool {
        self.dwWidth == other.dwWidth && self.dwHeight == other.dwHeight
    }
}
impl ::core::cmp::Eq for AMVPSIZE {}
impl ::core::fmt::Debug for AMVPSIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AMVPSIZE").field("dwWidth", &self.dwWidth).field("dwHeight", &self.dwHeight).finish()
    }
}
impl ::core::default::Default for AMVP_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMVP_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMVP_MODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AMVP_SELECT_FORMAT_BY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AMVP_SELECT_FORMAT_BY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AMVP_SELECT_FORMAT_BY").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AM_AC3_ALTERNATE_AUDIO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AM_AC3_ALTERNATE_AUDIO {
    fn eq(&self, other: &Self) -> bool {
        self.fStereo == other.fStereo && self.DualMode == other.DualMode
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AM_AC3_ALTERNATE_AUDIO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AM_AC3_ALTERNATE_AUDIO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_AC3_ALTERNATE_AUDIO").field("fStereo", &self.fStereo).field("DualMode", &self.DualMode).finish()
    }
}
impl ::core::default::Default for AM_AC3_BIT_STREAM_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_AC3_BIT_STREAM_MODE {
    fn eq(&self, other: &Self) -> bool {
        self.BitStreamMode == other.BitStreamMode
    }
}
impl ::core::cmp::Eq for AM_AC3_BIT_STREAM_MODE {}
impl ::core::fmt::Debug for AM_AC3_BIT_STREAM_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_AC3_BIT_STREAM_MODE").field("BitStreamMode", &self.BitStreamMode).finish()
    }
}
impl ::core::default::Default for AM_AC3_DIALOGUE_LEVEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_AC3_DIALOGUE_LEVEL {
    fn eq(&self, other: &Self) -> bool {
        self.DialogueLevel == other.DialogueLevel
    }
}
impl ::core::cmp::Eq for AM_AC3_DIALOGUE_LEVEL {}
impl ::core::fmt::Debug for AM_AC3_DIALOGUE_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_AC3_DIALOGUE_LEVEL").field("DialogueLevel", &self.DialogueLevel).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AM_AC3_DOWNMIX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AM_AC3_DOWNMIX {
    fn eq(&self, other: &Self) -> bool {
        self.fDownMix == other.fDownMix && self.fDolbySurround == other.fDolbySurround
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AM_AC3_DOWNMIX {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AM_AC3_DOWNMIX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_AC3_DOWNMIX").field("fDownMix", &self.fDownMix).field("fDolbySurround", &self.fDolbySurround).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AM_AC3_ERROR_CONCEALMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AM_AC3_ERROR_CONCEALMENT {
    fn eq(&self, other: &Self) -> bool {
        self.fRepeatPreviousBlock == other.fRepeatPreviousBlock && self.fErrorInCurrentBlock == other.fErrorInCurrentBlock
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AM_AC3_ERROR_CONCEALMENT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AM_AC3_ERROR_CONCEALMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_AC3_ERROR_CONCEALMENT").field("fRepeatPreviousBlock", &self.fRepeatPreviousBlock).field("fErrorInCurrentBlock", &self.fErrorInCurrentBlock).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AM_AC3_ROOM_TYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AM_AC3_ROOM_TYPE {
    fn eq(&self, other: &Self) -> bool {
        self.fLargeRoom == other.fLargeRoom
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AM_AC3_ROOM_TYPE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AM_AC3_ROOM_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_AC3_ROOM_TYPE").field("fLargeRoom", &self.fLargeRoom).finish()
    }
}
impl ::core::default::Default for AM_ASPECT_RATIO_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_ASPECT_RATIO_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_ASPECT_RATIO_MODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_COLCON {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_COLCON {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield1 == other._bitfield1 && self._bitfield2 == other._bitfield2 && self._bitfield3 == other._bitfield3 && self._bitfield4 == other._bitfield4
    }
}
impl ::core::cmp::Eq for AM_COLCON {}
impl ::core::fmt::Debug for AM_COLCON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_COLCON").field("_bitfield1", &self._bitfield1).field("_bitfield2", &self._bitfield2).field("_bitfield3", &self._bitfield3).field("_bitfield4", &self._bitfield4).finish()
    }
}
impl ::core::default::Default for AM_COPY_MACROVISION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_COPY_MACROVISION {
    fn eq(&self, other: &Self) -> bool {
        self.MACROVISIONLevel == other.MACROVISIONLevel
    }
}
impl ::core::cmp::Eq for AM_COPY_MACROVISION {}
impl ::core::fmt::Debug for AM_COPY_MACROVISION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_COPY_MACROVISION").field("MACROVISIONLevel", &self.MACROVISIONLevel).finish()
    }
}
impl ::core::default::Default for AM_COPY_MACROVISION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_COPY_MACROVISION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_COPY_MACROVISION_LEVEL").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_DIGITAL_CP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_DIGITAL_CP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_DIGITAL_CP").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_DVDCOPYSTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_DVDCOPYSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_DVDCOPYSTATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_DVDCOPY_BUSKEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVDCOPY_BUSKEY {
    fn eq(&self, other: &Self) -> bool {
        self.BusKey == other.BusKey && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for AM_DVDCOPY_BUSKEY {}
impl ::core::fmt::Debug for AM_DVDCOPY_BUSKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVDCOPY_BUSKEY").field("BusKey", &self.BusKey).field("Reserved", &self.Reserved).finish()
    }
}
impl ::core::default::Default for AM_DVDCOPY_CHLGKEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVDCOPY_CHLGKEY {
    fn eq(&self, other: &Self) -> bool {
        self.ChlgKey == other.ChlgKey && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for AM_DVDCOPY_CHLGKEY {}
impl ::core::fmt::Debug for AM_DVDCOPY_CHLGKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVDCOPY_CHLGKEY").field("ChlgKey", &self.ChlgKey).field("Reserved", &self.Reserved).finish()
    }
}
impl ::core::default::Default for AM_DVDCOPY_DISCKEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVDCOPY_DISCKEY {
    fn eq(&self, other: &Self) -> bool {
        self.DiscKey == other.DiscKey
    }
}
impl ::core::cmp::Eq for AM_DVDCOPY_DISCKEY {}
impl ::core::fmt::Debug for AM_DVDCOPY_DISCKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVDCOPY_DISCKEY").field("DiscKey", &self.DiscKey).finish()
    }
}
impl ::core::default::Default for AM_DVDCOPY_SET_COPY_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVDCOPY_SET_COPY_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.DVDCopyState == other.DVDCopyState
    }
}
impl ::core::cmp::Eq for AM_DVDCOPY_SET_COPY_STATE {}
impl ::core::fmt::Debug for AM_DVDCOPY_SET_COPY_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVDCOPY_SET_COPY_STATE").field("DVDCopyState", &self.DVDCopyState).finish()
    }
}
impl ::core::default::Default for AM_DVDCOPY_TITLEKEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVDCOPY_TITLEKEY {
    fn eq(&self, other: &Self) -> bool {
        self.KeyFlags == other.KeyFlags && self.Reserved1 == other.Reserved1 && self.TitleKey == other.TitleKey && self.Reserved2 == other.Reserved2
    }
}
impl ::core::cmp::Eq for AM_DVDCOPY_TITLEKEY {}
impl ::core::fmt::Debug for AM_DVDCOPY_TITLEKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVDCOPY_TITLEKEY").field("KeyFlags", &self.KeyFlags).field("Reserved1", &self.Reserved1).field("TitleKey", &self.TitleKey).field("Reserved2", &self.Reserved2).finish()
    }
}
impl ::core::default::Default for AM_DVD_ChangeRate {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVD_ChangeRate {
    fn eq(&self, other: &Self) -> bool {
        self.StartInTime == other.StartInTime && self.StartOutTime == other.StartOutTime && self.Rate == other.Rate
    }
}
impl ::core::cmp::Eq for AM_DVD_ChangeRate {}
impl ::core::fmt::Debug for AM_DVD_ChangeRate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVD_ChangeRate").field("StartInTime", &self.StartInTime).field("StartOutTime", &self.StartOutTime).field("Rate", &self.Rate).finish()
    }
}
impl ::core::default::Default for AM_DVD_GRAPH_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_DVD_GRAPH_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_DVD_GRAPH_FLAGS").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AM_DVD_RENDERSTATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AM_DVD_RENDERSTATUS {
    fn eq(&self, other: &Self) -> bool {
        self.hrVPEStatus == other.hrVPEStatus && self.bDvdVolInvalid == other.bDvdVolInvalid && self.bDvdVolUnknown == other.bDvdVolUnknown && self.bNoLine21In == other.bNoLine21In && self.bNoLine21Out == other.bNoLine21Out && self.iNumStreams == other.iNumStreams && self.iNumStreamsFailed == other.iNumStreamsFailed && self.dwFailedStreamsFlag == other.dwFailedStreamsFlag
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AM_DVD_RENDERSTATUS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AM_DVD_RENDERSTATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVD_RENDERSTATUS").field("hrVPEStatus", &self.hrVPEStatus).field("bDvdVolInvalid", &self.bDvdVolInvalid).field("bDvdVolUnknown", &self.bDvdVolUnknown).field("bNoLine21In", &self.bNoLine21In).field("bNoLine21Out", &self.bNoLine21Out).field("iNumStreams", &self.iNumStreams).field("iNumStreamsFailed", &self.iNumStreamsFailed).field("dwFailedStreamsFlag", &self.dwFailedStreamsFlag).finish()
    }
}
impl ::core::default::Default for AM_DVD_STREAM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_DVD_STREAM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_DVD_STREAM_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_DVD_YUV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DVD_YUV {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved == other.Reserved && self.Y == other.Y && self.U == other.U && self.V == other.V
    }
}
impl ::core::cmp::Eq for AM_DVD_YUV {}
impl ::core::fmt::Debug for AM_DVD_YUV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DVD_YUV").field("Reserved", &self.Reserved).field("Y", &self.Y).field("U", &self.U).field("V", &self.V).finish()
    }
}
impl ::core::default::Default for AM_DvdKaraokeData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_DvdKaraokeData {
    fn eq(&self, other: &Self) -> bool {
        self.dwDownmix == other.dwDownmix && self.dwSpeakerAssignment == other.dwSpeakerAssignment
    }
}
impl ::core::cmp::Eq for AM_DvdKaraokeData {}
impl ::core::fmt::Debug for AM_DvdKaraokeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_DvdKaraokeData").field("dwDownmix", &self.dwDownmix).field("dwSpeakerAssignment", &self.dwSpeakerAssignment).finish()
    }
}
impl ::core::default::Default for AM_ExactRateChange {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_ExactRateChange {
    fn eq(&self, other: &Self) -> bool {
        self.OutputZeroTime == other.OutputZeroTime && self.Rate == other.Rate
    }
}
impl ::core::cmp::Eq for AM_ExactRateChange {}
impl ::core::fmt::Debug for AM_ExactRateChange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_ExactRateChange").field("OutputZeroTime", &self.OutputZeroTime).field("Rate", &self.Rate).finish()
    }
}
impl ::core::default::Default for AM_FILESINK_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_FILESINK_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_FILESINK_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_FILTER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_FILTER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_FILTER_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_FRAMESTEP_STEP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_FRAMESTEP_STEP {
    fn eq(&self, other: &Self) -> bool {
        self.dwFramesToStep == other.dwFramesToStep
    }
}
impl ::core::cmp::Eq for AM_FRAMESTEP_STEP {}
impl ::core::fmt::Debug for AM_FRAMESTEP_STEP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_FRAMESTEP_STEP").field("dwFramesToStep", &self.dwFramesToStep).finish()
    }
}
impl ::core::default::Default for AM_GRAPH_CONFIG_RECONNECT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_GRAPH_CONFIG_RECONNECT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_GRAPH_CONFIG_RECONNECT_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_LINE21_CCLEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_LINE21_CCLEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_LINE21_CCLEVEL").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_LINE21_CCSERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_LINE21_CCSERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_LINE21_CCSERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_LINE21_CCSTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_LINE21_CCSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_LINE21_CCSTATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_LINE21_CCSTYLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_LINE21_CCSTYLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_LINE21_CCSTYLE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_LINE21_DRAWBGMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_LINE21_DRAWBGMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_LINE21_DRAWBGMODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_MEDIAEVENT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_MEDIAEVENT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_MEDIAEVENT_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_MPEG2Level {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_MPEG2Level {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_MPEG2Level").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_MPEG2Profile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_MPEG2Profile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_MPEG2Profile").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for AM_MPEGSTREAMTYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::PartialEq for AM_MPEGSTREAMTYPE {
    fn eq(&self, other: &Self) -> bool {
        self.dwStreamId == other.dwStreamId && self.dwReserved == other.dwReserved && self.mt == other.mt && self.bFormat == other.bFormat
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::Eq for AM_MPEGSTREAMTYPE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::fmt::Debug for AM_MPEGSTREAMTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_MPEGSTREAMTYPE").field("dwStreamId", &self.dwStreamId).field("dwReserved", &self.dwReserved).field("mt", &self.mt).field("bFormat", &self.bFormat).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for AM_MPEGSYSTEMTYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::PartialEq for AM_MPEGSYSTEMTYPE {
    fn eq(&self, other: &Self) -> bool {
        self.dwBitRate == other.dwBitRate && self.cStreams == other.cStreams && self.Streams == other.Streams
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::Eq for AM_MPEGSYSTEMTYPE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::fmt::Debug for AM_MPEGSYSTEMTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_MPEGSYSTEMTYPE").field("dwBitRate", &self.dwBitRate).field("cStreams", &self.cStreams).field("Streams", &self.Streams).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_AC3 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_AC3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_AC3").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_DVDCOPYPROT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_DVDCOPYPROT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_DVDCOPYPROT").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_DVDKARAOKE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_DVDKARAOKE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_DVDKARAOKE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_DVDSUBPIC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_DVDSUBPIC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_DVDSUBPIC").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_DVD_RATE_CHANGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_DVD_RATE_CHANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_DVD_RATE_CHANGE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_FRAMESTEP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_FRAMESTEP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_FRAMESTEP").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_SPHLI {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_PROPERTY_SPHLI {
    fn eq(&self, other: &Self) -> bool {
        self.HLISS == other.HLISS && self.Reserved == other.Reserved && self.StartPTM == other.StartPTM && self.EndPTM == other.EndPTM && self.StartX == other.StartX && self.StartY == other.StartY && self.StopX == other.StopX && self.StopY == other.StopY && self.ColCon == other.ColCon
    }
}
impl ::core::cmp::Eq for AM_PROPERTY_SPHLI {}
impl ::core::fmt::Debug for AM_PROPERTY_SPHLI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_PROPERTY_SPHLI").field("HLISS", &self.HLISS).field("Reserved", &self.Reserved).field("StartPTM", &self.StartPTM).field("EndPTM", &self.EndPTM).field("StartX", &self.StartX).field("StartY", &self.StartY).field("StopX", &self.StopX).field("StopY", &self.StopY).field("ColCon", &self.ColCon).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_SPPAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_PROPERTY_SPPAL {
    fn eq(&self, other: &Self) -> bool {
        self.sppal == other.sppal
    }
}
impl ::core::cmp::Eq for AM_PROPERTY_SPPAL {}
impl ::core::fmt::Debug for AM_PROPERTY_SPPAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_PROPERTY_SPPAL").field("sppal", &self.sppal).finish()
    }
}
impl ::core::default::Default for AM_PROPERTY_TS_RATE_CHANGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_PROPERTY_TS_RATE_CHANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_PROPERTY_TS_RATE_CHANGE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_QueryRate {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_QueryRate {
    fn eq(&self, other: &Self) -> bool {
        self.lMaxForwardFullFrame == other.lMaxForwardFullFrame && self.lMaxReverseFullFrame == other.lMaxReverseFullFrame
    }
}
impl ::core::cmp::Eq for AM_QueryRate {}
impl ::core::fmt::Debug for AM_QueryRate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_QueryRate").field("lMaxForwardFullFrame", &self.lMaxForwardFullFrame).field("lMaxReverseFullFrame", &self.lMaxReverseFullFrame).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for AM_SAMPLE2_PROPERTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::PartialEq for AM_SAMPLE2_PROPERTIES {
    fn eq(&self, other: &Self) -> bool {
        self.cbData == other.cbData && self.dwTypeSpecificFlags == other.dwTypeSpecificFlags && self.dwSampleFlags == other.dwSampleFlags && self.lActual == other.lActual && self.tStart == other.tStart && self.tStop == other.tStop && self.dwStreamId == other.dwStreamId && self.pMediaType == other.pMediaType && self.pbBuffer == other.pbBuffer && self.cbBuffer == other.cbBuffer
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::Eq for AM_SAMPLE2_PROPERTIES {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::fmt::Debug for AM_SAMPLE2_PROPERTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_SAMPLE2_PROPERTIES").field("cbData", &self.cbData).field("dwTypeSpecificFlags", &self.dwTypeSpecificFlags).field("dwSampleFlags", &self.dwSampleFlags).field("lActual", &self.lActual).field("tStart", &self.tStart).field("tStop", &self.tStop).field("dwStreamId", &self.dwStreamId).field("pMediaType", &self.pMediaType).field("pbBuffer", &self.pbBuffer).field("cbBuffer", &self.cbBuffer).finish()
    }
}
impl ::core::default::Default for AM_SAMPLE_PROPERTY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_SAMPLE_PROPERTY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_SAMPLE_PROPERTY_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_SEEKING_SEEKING_CAPABILITIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_SEEKING_SEEKING_CAPABILITIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_SEEKING_SEEKING_CAPABILITIES").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_SEEKING_SEEKING_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_SEEKING_SEEKING_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_SEEKING_SEEKING_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_STREAM_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_STREAM_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.tStart == other.tStart && self.tStop == other.tStop && self.dwStartCookie == other.dwStartCookie && self.dwStopCookie == other.dwStopCookie && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for AM_STREAM_INFO {}
impl ::core::fmt::Debug for AM_STREAM_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_STREAM_INFO").field("tStart", &self.tStart).field("tStop", &self.tStop).field("dwStartCookie", &self.dwStartCookie).field("dwStopCookie", &self.dwStopCookie).field("dwFlags", &self.dwFlags).finish()
    }
}
impl ::core::default::Default for AM_STREAM_INFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_STREAM_INFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_STREAM_INFO_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_SimpleRateChange {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_SimpleRateChange {
    fn eq(&self, other: &Self) -> bool {
        self.StartTime == other.StartTime && self.Rate == other.Rate
    }
}
impl ::core::cmp::Eq for AM_SimpleRateChange {}
impl ::core::fmt::Debug for AM_SimpleRateChange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_SimpleRateChange").field("StartTime", &self.StartTime).field("Rate", &self.Rate).finish()
    }
}
impl ::core::default::Default for AM_WST_DRAWBGMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_WST_DRAWBGMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_WST_DRAWBGMODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_WST_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_WST_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_WST_LEVEL").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_WST_PAGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AM_WST_PAGE {
    fn eq(&self, other: &Self) -> bool {
        self.dwPageNr == other.dwPageNr && self.dwSubPageNr == other.dwSubPageNr && self.pucPageData == other.pucPageData
    }
}
impl ::core::cmp::Eq for AM_WST_PAGE {}
impl ::core::fmt::Debug for AM_WST_PAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_WST_PAGE").field("dwPageNr", &self.dwPageNr).field("dwSubPageNr", &self.dwSubPageNr).field("pucPageData", &self.pucPageData).finish()
    }
}
impl ::core::default::Default for AM_WST_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_WST_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_WST_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_WST_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_WST_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_WST_STATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for AM_WST_STYLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AM_WST_STYLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AM_WST_STYLE").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for ANALOGVIDEOINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for ANALOGVIDEOINFO {
    fn eq(&self, other: &Self) -> bool {
        self.rcSource == other.rcSource && self.rcTarget == other.rcTarget && self.dwActiveWidth == other.dwActiveWidth && self.dwActiveHeight == other.dwActiveHeight && self.AvgTimePerFrame == other.AvgTimePerFrame
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for ANALOGVIDEOINFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for ANALOGVIDEOINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ANALOGVIDEOINFO").field("rcSource", &self.rcSource).field("rcTarget", &self.rcTarget).field("dwActiveWidth", &self.dwActiveWidth).field("dwActiveHeight", &self.dwActiveHeight).field("AvgTimePerFrame", &self.AvgTimePerFrame).finish()
    }
}
impl ::core::default::Default for ATSCComponentTypeFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ATSCComponentTypeFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ATSCComponentTypeFlags").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for ATSC_FILTER_OPTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AUDIO_STREAM_CONFIG_CAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AUDIO_STREAM_CONFIG_CAPS {
    fn eq(&self, other: &Self) -> bool {
        self.guid == other.guid && self.MinimumChannels == other.MinimumChannels && self.MaximumChannels == other.MaximumChannels && self.ChannelsGranularity == other.ChannelsGranularity && self.MinimumBitsPerSample == other.MinimumBitsPerSample && self.MaximumBitsPerSample == other.MaximumBitsPerSample && self.BitsPerSampleGranularity == other.BitsPerSampleGranularity && self.MinimumSampleFrequency == other.MinimumSampleFrequency && self.MaximumSampleFrequency == other.MaximumSampleFrequency && self.SampleFrequencyGranularity == other.SampleFrequencyGranularity
    }
}
impl ::core::cmp::Eq for AUDIO_STREAM_CONFIG_CAPS {}
impl ::core::fmt::Debug for AUDIO_STREAM_CONFIG_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AUDIO_STREAM_CONFIG_CAPS")
            .field("guid", &self.guid)
            .field("MinimumChannels", &self.MinimumChannels)
            .field("MaximumChannels", &self.MaximumChannels)
            .field("ChannelsGranularity", &self.ChannelsGranularity)
            .field("MinimumBitsPerSample", &self.MinimumBitsPerSample)
            .field("MaximumBitsPerSample", &self.MaximumBitsPerSample)
            .field("BitsPerSampleGranularity", &self.BitsPerSampleGranularity)
            .field("MinimumSampleFrequency", &self.MinimumSampleFrequency)
            .field("MaximumSampleFrequency", &self.MaximumSampleFrequency)
            .field("SampleFrequencyGranularity", &self.SampleFrequencyGranularity)
            .finish()
    }
}
impl ::core::default::Default for AVIEXTHEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVIFIELDINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVIINDEXENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for AVIINDEXENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.ckid == other.ckid && self.dwFlags == other.dwFlags && self.dwChunkOffset == other.dwChunkOffset && self.dwChunkLength == other.dwChunkLength
    }
}
impl ::core::cmp::Eq for AVIINDEXENTRY {}
impl ::core::fmt::Debug for AVIINDEXENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AVIINDEXENTRY").field("ckid", &self.ckid).field("dwFlags", &self.dwFlags).field("dwChunkOffset", &self.dwChunkOffset).field("dwChunkLength", &self.dwChunkLength).finish()
    }
}
impl ::core::default::Default for AVIMAINHEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVIMETAINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVIOLDINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::default::Default for AVIPALCHANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::cmp::PartialEq for AVIPALCHANGE {
    fn eq(&self, other: &Self) -> bool {
        self.bFirstEntry == other.bFirstEntry && self.bNumEntries == other.bNumEntries && self.wFlags == other.wFlags && self.peNew == other.peNew
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::cmp::Eq for AVIPALCHANGE {}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::fmt::Debug for AVIPALCHANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AVIPALCHANGE").field("bFirstEntry", &self.bFirstEntry).field("bNumEntries", &self.bNumEntries).field("wFlags", &self.wFlags).field("peNew", &self.peNew).finish()
    }
}
impl ::core::default::Default for AVISTDINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVISTDINDEX_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVISTREAMHEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVISUPERINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AVIStreamHeader {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AVIStreamHeader {
    fn eq(&self, other: &Self) -> bool {
        self.fccType == other.fccType && self.fccHandler == other.fccHandler && self.dwFlags == other.dwFlags && self.wPriority == other.wPriority && self.wLanguage == other.wLanguage && self.dwInitialFrames == other.dwInitialFrames && self.dwScale == other.dwScale && self.dwRate == other.dwRate && self.dwStart == other.dwStart && self.dwLength == other.dwLength && self.dwSuggestedBufferSize == other.dwSuggestedBufferSize && self.dwQuality == other.dwQuality && self.dwSampleSize == other.dwSampleSize && self.rcFrame == other.rcFrame
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AVIStreamHeader {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AVIStreamHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AVIStreamHeader")
            .field("fccType", &self.fccType)
            .field("fccHandler", &self.fccHandler)
            .field("dwFlags", &self.dwFlags)
            .field("wPriority", &self.wPriority)
            .field("wLanguage", &self.wLanguage)
            .field("dwInitialFrames", &self.dwInitialFrames)
            .field("dwScale", &self.dwScale)
            .field("dwRate", &self.dwRate)
            .field("dwStart", &self.dwStart)
            .field("dwLength", &self.dwLength)
            .field("dwSuggestedBufferSize", &self.dwSuggestedBufferSize)
            .field("dwQuality", &self.dwQuality)
            .field("dwSampleSize", &self.dwSampleSize)
            .field("rcFrame", &self.rcFrame)
            .finish()
    }
}
impl ::core::default::Default for AVITCDLINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVITCDLINDEX_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVITIMECODEINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVITIMEDINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AVITIMEDINDEX_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for AnalogVideoStandard {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AnalogVideoStandard {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AnalogVideoStandard").field(&self.0).finish()
    }
}
impl ::core::default::Default for ApplicationTypeType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ApplicationTypeType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ApplicationTypeType").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDANODE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDANODE_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.ulBdaNodeType == other.ulBdaNodeType && self.guidFunction == other.guidFunction && self.guidName == other.guidName
    }
}
impl ::core::cmp::Eq for BDANODE_DESCRIPTOR {}
impl ::core::fmt::Debug for BDANODE_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDANODE_DESCRIPTOR").field("ulBdaNodeType", &self.ulBdaNodeType).field("guidFunction", &self.guidFunction).field("guidName", &self.guidName).finish()
    }
}
impl ::core::default::Default for BDA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulBufferSize == other.ulBufferSize && self.argbBuffer == other.argbBuffer
    }
}
impl ::core::cmp::Eq for BDA_BUFFER {}
impl ::core::fmt::Debug for BDA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_BUFFER").field("lResult", &self.lResult).field("ulBufferSize", &self.ulBufferSize).field("argbBuffer", &self.argbBuffer).finish()
    }
}
impl ::core::default::Default for BDA_CAS_CHECK_ENTITLEMENTTOKEN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_CAS_CHECK_ENTITLEMENTTOKEN {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulDescrambleStatus == other.ulDescrambleStatus
    }
}
impl ::core::cmp::Eq for BDA_CAS_CHECK_ENTITLEMENTTOKEN {}
impl ::core::fmt::Debug for BDA_CAS_CHECK_ENTITLEMENTTOKEN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_CAS_CHECK_ENTITLEMENTTOKEN").field("lResult", &self.lResult).field("ulDescrambleStatus", &self.ulDescrambleStatus).finish()
    }
}
impl ::core::default::Default for BDA_CAS_CLOSEMMIDATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_CAS_CLOSEMMIDATA {
    fn eq(&self, other: &Self) -> bool {
        self.ulDialogNumber == other.ulDialogNumber
    }
}
impl ::core::cmp::Eq for BDA_CAS_CLOSEMMIDATA {}
impl ::core::fmt::Debug for BDA_CAS_CLOSEMMIDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_CAS_CLOSEMMIDATA").field("ulDialogNumber", &self.ulDialogNumber).finish()
    }
}
impl ::core::default::Default for BDA_CAS_CLOSE_MMIDIALOG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_CAS_CLOSE_MMIDIALOG {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.SessionResult == other.SessionResult
    }
}
impl ::core::cmp::Eq for BDA_CAS_CLOSE_MMIDIALOG {}
impl ::core::fmt::Debug for BDA_CAS_CLOSE_MMIDIALOG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_CAS_CLOSE_MMIDIALOG").field("lResult", &self.lResult).field("SessionResult", &self.SessionResult).finish()
    }
}
impl ::core::default::Default for BDA_CAS_OPENMMIDATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_CAS_OPENMMIDATA {
    fn eq(&self, other: &Self) -> bool {
        self.ulDialogNumber == other.ulDialogNumber && self.ulDialogRequest == other.ulDialogRequest && self.uuidDialogType == other.uuidDialogType && self.usDialogDataLength == other.usDialogDataLength && self.argbDialogData == other.argbDialogData
    }
}
impl ::core::cmp::Eq for BDA_CAS_OPENMMIDATA {}
impl ::core::fmt::Debug for BDA_CAS_OPENMMIDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_CAS_OPENMMIDATA").field("ulDialogNumber", &self.ulDialogNumber).field("ulDialogRequest", &self.ulDialogRequest).field("uuidDialogType", &self.uuidDialogType).field("usDialogDataLength", &self.usDialogDataLength).field("argbDialogData", &self.argbDialogData).finish()
    }
}
impl ::core::default::Default for BDA_CAS_REQUESTTUNERDATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_CAS_REQUESTTUNERDATA {
    fn eq(&self, other: &Self) -> bool {
        self.ucRequestPriority == other.ucRequestPriority && self.ucRequestReason == other.ucRequestReason && self.ucRequestConsequences == other.ucRequestConsequences && self.ulEstimatedTime == other.ulEstimatedTime
    }
}
impl ::core::cmp::Eq for BDA_CAS_REQUESTTUNERDATA {}
impl ::core::fmt::Debug for BDA_CAS_REQUESTTUNERDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_CAS_REQUESTTUNERDATA").field("ucRequestPriority", &self.ucRequestPriority).field("ucRequestReason", &self.ucRequestReason).field("ucRequestConsequences", &self.ucRequestConsequences).field("ulEstimatedTime", &self.ulEstimatedTime).finish()
    }
}
impl ::core::default::Default for BDA_CA_MODULE_UI {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_CA_MODULE_UI {
    fn eq(&self, other: &Self) -> bool {
        self.ulFormat == other.ulFormat && self.ulbcDesc == other.ulbcDesc && self.ulDesc == other.ulDesc
    }
}
impl ::core::cmp::Eq for BDA_CA_MODULE_UI {}
impl ::core::fmt::Debug for BDA_CA_MODULE_UI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_CA_MODULE_UI").field("ulFormat", &self.ulFormat).field("ulbcDesc", &self.ulbcDesc).field("ulDesc", &self.ulDesc).finish()
    }
}
impl ::core::default::Default for BDA_CHANGE_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_CHANGE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_CHANGE_STATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_CONDITIONALACCESS_MMICLOSEREASON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_CONDITIONALACCESS_MMICLOSEREASON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_CONDITIONALACCESS_MMICLOSEREASON").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_CONDITIONALACCESS_REQUESTTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_CONDITIONALACCESS_REQUESTTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_CONDITIONALACCESS_REQUESTTYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_CONDITIONALACCESS_SESSION_RESULT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_CONDITIONALACCESS_SESSION_RESULT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_CONDITIONALACCESS_SESSION_RESULT").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_Channel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_Channel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_Channel").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_Channel_Bandwidth {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_Channel_Bandwidth {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_Channel_Bandwidth").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_Comp_Flags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_Comp_Flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_Comp_Flags").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_DEBUG_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_DEBUG_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.uuidDebugDataType == other.uuidDebugDataType && self.ulDataSize == other.ulDataSize && self.argbDebugData == other.argbDebugData
    }
}
impl ::core::cmp::Eq for BDA_DEBUG_DATA {}
impl ::core::fmt::Debug for BDA_DEBUG_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_DEBUG_DATA").field("lResult", &self.lResult).field("uuidDebugDataType", &self.uuidDebugDataType).field("ulDataSize", &self.ulDataSize).field("argbDebugData", &self.argbDebugData).finish()
    }
}
impl ::core::default::Default for BDA_DISCOVERY_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_DISCOVERY_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_DISCOVERY_STATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_DISEQC_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_DISEQC_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.ulRequestId == other.ulRequestId && self.ulPacketLength == other.ulPacketLength && self.argbPacketData == other.argbPacketData
    }
}
impl ::core::cmp::Eq for BDA_DISEQC_RESPONSE {}
impl ::core::fmt::Debug for BDA_DISEQC_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_DISEQC_RESPONSE").field("ulRequestId", &self.ulRequestId).field("ulPacketLength", &self.ulPacketLength).field("argbPacketData", &self.argbPacketData).finish()
    }
}
impl ::core::default::Default for BDA_DISEQC_SEND {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_DISEQC_SEND {
    fn eq(&self, other: &Self) -> bool {
        self.ulRequestId == other.ulRequestId && self.ulPacketLength == other.ulPacketLength && self.argbPacketData == other.argbPacketData
    }
}
impl ::core::cmp::Eq for BDA_DISEQC_SEND {}
impl ::core::fmt::Debug for BDA_DISEQC_SEND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_DISEQC_SEND").field("ulRequestId", &self.ulRequestId).field("ulPacketLength", &self.ulPacketLength).field("argbPacketData", &self.argbPacketData).finish()
    }
}
impl ::core::default::Default for BDA_DRM_DRMSTATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_DRM_DRMSTATUS {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.DRMuuid == other.DRMuuid && self.ulDrmUuidListStringSize == other.ulDrmUuidListStringSize && self.argbDrmUuidListString == other.argbDrmUuidListString
    }
}
impl ::core::cmp::Eq for BDA_DRM_DRMSTATUS {}
impl ::core::fmt::Debug for BDA_DRM_DRMSTATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_DRM_DRMSTATUS").field("lResult", &self.lResult).field("DRMuuid", &self.DRMuuid).field("ulDrmUuidListStringSize", &self.ulDrmUuidListStringSize).field("argbDrmUuidListString", &self.argbDrmUuidListString).finish()
    }
}
impl ::core::default::Default for BDA_DVBT2_L1_SIGNALLING_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_DVBT2_L1_SIGNALLING_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.L1Pre_TYPE == other.L1Pre_TYPE && self.L1Pre_BWT_S1_S2 == other.L1Pre_BWT_S1_S2 && self.L1Pre_REPETITION_GUARD_PAPR == other.L1Pre_REPETITION_GUARD_PAPR && self.L1Pre_MOD_COD_FEC == other.L1Pre_MOD_COD_FEC && self.L1Pre_POSTSIZE_INFO_PILOT == other.L1Pre_POSTSIZE_INFO_PILOT && self.L1Pre_TX_ID_AVAIL == other.L1Pre_TX_ID_AVAIL && self.L1Pre_CELL_ID == other.L1Pre_CELL_ID && self.L1Pre_NETWORK_ID == other.L1Pre_NETWORK_ID && self.L1Pre_T2SYSTEM_ID == other.L1Pre_T2SYSTEM_ID && self.L1Pre_NUM_T2_FRAMES == other.L1Pre_NUM_T2_FRAMES && self.L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT == other.L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT && self.L1Pre_NUMRF_CURRENTRF_RESERVED == other.L1Pre_NUMRF_CURRENTRF_RESERVED && self.L1Pre_CRC32 == other.L1Pre_CRC32 && self.L1PostData == other.L1PostData
    }
}
impl ::core::cmp::Eq for BDA_DVBT2_L1_SIGNALLING_DATA {}
impl ::core::fmt::Debug for BDA_DVBT2_L1_SIGNALLING_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_DVBT2_L1_SIGNALLING_DATA")
            .field("L1Pre_TYPE", &self.L1Pre_TYPE)
            .field("L1Pre_BWT_S1_S2", &self.L1Pre_BWT_S1_S2)
            .field("L1Pre_REPETITION_GUARD_PAPR", &self.L1Pre_REPETITION_GUARD_PAPR)
            .field("L1Pre_MOD_COD_FEC", &self.L1Pre_MOD_COD_FEC)
            .field("L1Pre_POSTSIZE_INFO_PILOT", &self.L1Pre_POSTSIZE_INFO_PILOT)
            .field("L1Pre_TX_ID_AVAIL", &self.L1Pre_TX_ID_AVAIL)
            .field("L1Pre_CELL_ID", &self.L1Pre_CELL_ID)
            .field("L1Pre_NETWORK_ID", &self.L1Pre_NETWORK_ID)
            .field("L1Pre_T2SYSTEM_ID", &self.L1Pre_T2SYSTEM_ID)
            .field("L1Pre_NUM_T2_FRAMES", &self.L1Pre_NUM_T2_FRAMES)
            .field("L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT", &self.L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT)
            .field("L1Pre_NUMRF_CURRENTRF_RESERVED", &self.L1Pre_NUMRF_CURRENTRF_RESERVED)
            .field("L1Pre_CRC32", &self.L1Pre_CRC32)
            .field("L1PostData", &self.L1PostData)
            .finish()
    }
}
impl ::core::default::Default for BDA_DigitalSignalStandard {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_DigitalSignalStandard {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_DigitalSignalStandard").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_DrmPairingError {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_DrmPairingError {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_DrmPairingError").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_ETHERNET_ADDRESS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_ETHERNET_ADDRESS {
    fn eq(&self, other: &Self) -> bool {
        self.rgbAddress == other.rgbAddress
    }
}
impl ::core::cmp::Eq for BDA_ETHERNET_ADDRESS {}
impl ::core::fmt::Debug for BDA_ETHERNET_ADDRESS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_ETHERNET_ADDRESS").field("rgbAddress", &self.rgbAddress).finish()
    }
}
impl ::core::default::Default for BDA_ETHERNET_ADDRESS_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_ETHERNET_ADDRESS_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.ulcAddresses == other.ulcAddresses && self.rgAddressl == other.rgAddressl
    }
}
impl ::core::cmp::Eq for BDA_ETHERNET_ADDRESS_LIST {}
impl ::core::fmt::Debug for BDA_ETHERNET_ADDRESS_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_ETHERNET_ADDRESS_LIST").field("ulcAddresses", &self.ulcAddresses).field("rgAddressl", &self.rgAddressl).finish()
    }
}
impl ::core::default::Default for BDA_EVENT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_EVENT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulEventID == other.ulEventID && self.uuidEventType == other.uuidEventType && self.ulEventDataLength == other.ulEventDataLength && self.argbEventData == other.argbEventData
    }
}
impl ::core::cmp::Eq for BDA_EVENT_DATA {}
impl ::core::fmt::Debug for BDA_EVENT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_EVENT_DATA").field("lResult", &self.lResult).field("ulEventID", &self.ulEventID).field("uuidEventType", &self.uuidEventType).field("ulEventDataLength", &self.ulEventDataLength).field("argbEventData", &self.argbEventData).finish()
    }
}
impl ::core::default::Default for BDA_EVENT_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_EVENT_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_EVENT_ID").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_Frequency {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_Frequency {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_Frequency").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_Frequency_Multiplier {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_Frequency_Multiplier {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_Frequency_Multiplier").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_GDDS_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_GDDS_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulDataLength == other.ulDataLength && self.ulPercentageProgress == other.ulPercentageProgress && self.argbData == other.argbData
    }
}
impl ::core::cmp::Eq for BDA_GDDS_DATA {}
impl ::core::fmt::Debug for BDA_GDDS_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_GDDS_DATA").field("lResult", &self.lResult).field("ulDataLength", &self.ulDataLength).field("ulPercentageProgress", &self.ulPercentageProgress).field("argbData", &self.argbData).finish()
    }
}
impl ::core::default::Default for BDA_GDDS_DATATYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_GDDS_DATATYPE {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.uuidDataType == other.uuidDataType
    }
}
impl ::core::cmp::Eq for BDA_GDDS_DATATYPE {}
impl ::core::fmt::Debug for BDA_GDDS_DATATYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_GDDS_DATATYPE").field("lResult", &self.lResult).field("uuidDataType", &self.uuidDataType).finish()
    }
}
impl ::core::default::Default for BDA_IPv4_ADDRESS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_IPv4_ADDRESS {
    fn eq(&self, other: &Self) -> bool {
        self.rgbAddress == other.rgbAddress
    }
}
impl ::core::cmp::Eq for BDA_IPv4_ADDRESS {}
impl ::core::fmt::Debug for BDA_IPv4_ADDRESS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_IPv4_ADDRESS").field("rgbAddress", &self.rgbAddress).finish()
    }
}
impl ::core::default::Default for BDA_IPv4_ADDRESS_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_IPv4_ADDRESS_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.ulcAddresses == other.ulcAddresses && self.rgAddressl == other.rgAddressl
    }
}
impl ::core::cmp::Eq for BDA_IPv4_ADDRESS_LIST {}
impl ::core::fmt::Debug for BDA_IPv4_ADDRESS_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_IPv4_ADDRESS_LIST").field("ulcAddresses", &self.ulcAddresses).field("rgAddressl", &self.rgAddressl).finish()
    }
}
impl ::core::default::Default for BDA_IPv6_ADDRESS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_IPv6_ADDRESS {
    fn eq(&self, other: &Self) -> bool {
        self.rgbAddress == other.rgbAddress
    }
}
impl ::core::cmp::Eq for BDA_IPv6_ADDRESS {}
impl ::core::fmt::Debug for BDA_IPv6_ADDRESS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_IPv6_ADDRESS").field("rgbAddress", &self.rgbAddress).finish()
    }
}
impl ::core::default::Default for BDA_IPv6_ADDRESS_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_IPv6_ADDRESS_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.ulcAddresses == other.ulcAddresses && self.rgAddressl == other.rgAddressl
    }
}
impl ::core::cmp::Eq for BDA_IPv6_ADDRESS_LIST {}
impl ::core::fmt::Debug for BDA_IPv6_ADDRESS_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_IPv6_ADDRESS_LIST").field("ulcAddresses", &self.ulcAddresses).field("rgAddressl", &self.rgAddressl).finish()
    }
}
impl ::core::default::Default for BDA_ISDBCAS_EMG_REQ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_ISDBCAS_EMG_REQ {
    fn eq(&self, other: &Self) -> bool {
        self.bCLA == other.bCLA && self.bINS == other.bINS && self.bP1 == other.bP1 && self.bP2 == other.bP2 && self.bLC == other.bLC && self.bCardId == other.bCardId && self.bProtocol == other.bProtocol && self.bCABroadcasterGroupId == other.bCABroadcasterGroupId && self.bMessageControl == other.bMessageControl && self.bMessageCode == other.bMessageCode
    }
}
impl ::core::cmp::Eq for BDA_ISDBCAS_EMG_REQ {}
impl ::core::fmt::Debug for BDA_ISDBCAS_EMG_REQ {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_ISDBCAS_EMG_REQ").field("bCLA", &self.bCLA).field("bINS", &self.bINS).field("bP1", &self.bP1).field("bP2", &self.bP2).field("bLC", &self.bLC).field("bCardId", &self.bCardId).field("bProtocol", &self.bProtocol).field("bCABroadcasterGroupId", &self.bCABroadcasterGroupId).field("bMessageControl", &self.bMessageControl).field("bMessageCode", &self.bMessageCode).finish()
    }
}
impl ::core::default::Default for BDA_ISDBCAS_REQUESTHEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for BDA_ISDBCAS_RESPONSEDATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for BDA_LockType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_LockType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_LockType").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_MULTICAST_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_MULTICAST_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_MULTICAST_MODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_MUX_PIDLISTITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for BDA_PID_MAP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_PID_MAP {
    fn eq(&self, other: &Self) -> bool {
        self.MediaSampleContent == other.MediaSampleContent && self.ulcPIDs == other.ulcPIDs && self.aulPIDs == other.aulPIDs
    }
}
impl ::core::cmp::Eq for BDA_PID_MAP {}
impl ::core::fmt::Debug for BDA_PID_MAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_PID_MAP").field("MediaSampleContent", &self.MediaSampleContent).field("ulcPIDs", &self.ulcPIDs).field("aulPIDs", &self.aulPIDs).finish()
    }
}
impl ::core::default::Default for BDA_PID_UNMAP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_PID_UNMAP {
    fn eq(&self, other: &Self) -> bool {
        self.ulcPIDs == other.ulcPIDs && self.aulPIDs == other.aulPIDs
    }
}
impl ::core::cmp::Eq for BDA_PID_UNMAP {}
impl ::core::fmt::Debug for BDA_PID_UNMAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_PID_UNMAP").field("ulcPIDs", &self.ulcPIDs).field("aulPIDs", &self.aulPIDs).finish()
    }
}
impl ::core::default::Default for BDA_PROGRAM_PID_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_PROGRAM_PID_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.ulProgramNumber == other.ulProgramNumber && self.ulcPIDs == other.ulcPIDs && self.ulPID == other.ulPID
    }
}
impl ::core::cmp::Eq for BDA_PROGRAM_PID_LIST {}
impl ::core::fmt::Debug for BDA_PROGRAM_PID_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_PROGRAM_PID_LIST").field("ulProgramNumber", &self.ulProgramNumber).field("ulcPIDs", &self.ulcPIDs).field("ulPID", &self.ulPID).finish()
    }
}
impl ::core::default::Default for BDA_RATING_PINRESET {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_RATING_PINRESET {
    fn eq(&self, other: &Self) -> bool {
        self.bPinLength == other.bPinLength && self.argbNewPin == other.argbNewPin
    }
}
impl ::core::cmp::Eq for BDA_RATING_PINRESET {}
impl ::core::fmt::Debug for BDA_RATING_PINRESET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_RATING_PINRESET").field("bPinLength", &self.bPinLength).field("argbNewPin", &self.argbNewPin).finish()
    }
}
impl ::core::default::Default for BDA_Range {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_Range {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_Range").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_SCAN_CAPABILTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_SCAN_CAPABILTIES {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ul64AnalogStandardsSupported == other.ul64AnalogStandardsSupported
    }
}
impl ::core::cmp::Eq for BDA_SCAN_CAPABILTIES {}
impl ::core::fmt::Debug for BDA_SCAN_CAPABILTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_SCAN_CAPABILTIES").field("lResult", &self.lResult).field("ul64AnalogStandardsSupported", &self.ul64AnalogStandardsSupported).finish()
    }
}
impl ::core::default::Default for BDA_SCAN_START {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_SCAN_START {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.LowerFrequency == other.LowerFrequency && self.HigerFrequency == other.HigerFrequency
    }
}
impl ::core::cmp::Eq for BDA_SCAN_START {}
impl ::core::fmt::Debug for BDA_SCAN_START {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_SCAN_START").field("lResult", &self.lResult).field("LowerFrequency", &self.LowerFrequency).field("HigerFrequency", &self.HigerFrequency).finish()
    }
}
impl ::core::default::Default for BDA_SCAN_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_SCAN_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulSignalLock == other.ulSignalLock && self.ulSecondsLeft == other.ulSecondsLeft && self.ulCurrentFrequency == other.ulCurrentFrequency
    }
}
impl ::core::cmp::Eq for BDA_SCAN_STATE {}
impl ::core::fmt::Debug for BDA_SCAN_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_SCAN_STATE").field("lResult", &self.lResult).field("ulSignalLock", &self.ulSignalLock).field("ulSecondsLeft", &self.ulSecondsLeft).field("ulCurrentFrequency", &self.ulCurrentFrequency).finish()
    }
}
impl ::core::default::Default for BDA_SIGNAL_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_SIGNAL_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_SIGNAL_STATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_SIGNAL_TIMEOUTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_SIGNAL_TIMEOUTS {
    fn eq(&self, other: &Self) -> bool {
        self.ulCarrierTimeoutMs == other.ulCarrierTimeoutMs && self.ulScanningTimeoutMs == other.ulScanningTimeoutMs && self.ulTuningTimeoutMs == other.ulTuningTimeoutMs
    }
}
impl ::core::cmp::Eq for BDA_SIGNAL_TIMEOUTS {}
impl ::core::fmt::Debug for BDA_SIGNAL_TIMEOUTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_SIGNAL_TIMEOUTS").field("ulCarrierTimeoutMs", &self.ulCarrierTimeoutMs).field("ulScanningTimeoutMs", &self.ulScanningTimeoutMs).field("ulTuningTimeoutMs", &self.ulTuningTimeoutMs).finish()
    }
}
impl ::core::default::Default for BDA_STRING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_STRING {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulStringSize == other.ulStringSize && self.argbString == other.argbString
    }
}
impl ::core::cmp::Eq for BDA_STRING {}
impl ::core::fmt::Debug for BDA_STRING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_STRING").field("lResult", &self.lResult).field("ulStringSize", &self.ulStringSize).field("argbString", &self.argbString).finish()
    }
}
impl ::core::default::Default for BDA_SignalType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BDA_SignalType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BDA_SignalType").field(&self.0).finish()
    }
}
impl ::core::default::Default for BDA_TABLE_SECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TABLE_SECTION {
    fn eq(&self, other: &Self) -> bool {
        self.ulPrimarySectionId == other.ulPrimarySectionId && self.ulSecondarySectionId == other.ulSecondarySectionId && self.ulcbSectionLength == other.ulcbSectionLength && self.argbSectionData == other.argbSectionData
    }
}
impl ::core::cmp::Eq for BDA_TABLE_SECTION {}
impl ::core::fmt::Debug for BDA_TABLE_SECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TABLE_SECTION").field("ulPrimarySectionId", &self.ulPrimarySectionId).field("ulSecondarySectionId", &self.ulSecondarySectionId).field("ulcbSectionLength", &self.ulcbSectionLength).field("argbSectionData", &self.argbSectionData).finish()
    }
}
impl ::core::default::Default for BDA_TEMPLATE_CONNECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TEMPLATE_CONNECTION {
    fn eq(&self, other: &Self) -> bool {
        self.FromNodeType == other.FromNodeType && self.FromNodePinType == other.FromNodePinType && self.ToNodeType == other.ToNodeType && self.ToNodePinType == other.ToNodePinType
    }
}
impl ::core::cmp::Eq for BDA_TEMPLATE_CONNECTION {}
impl ::core::fmt::Debug for BDA_TEMPLATE_CONNECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TEMPLATE_CONNECTION").field("FromNodeType", &self.FromNodeType).field("FromNodePinType", &self.FromNodePinType).field("ToNodeType", &self.ToNodeType).field("ToNodePinType", &self.ToNodePinType).finish()
    }
}
impl ::core::default::Default for BDA_TEMPLATE_PIN_JOINT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TEMPLATE_PIN_JOINT {
    fn eq(&self, other: &Self) -> bool {
        self.uliTemplateConnection == other.uliTemplateConnection && self.ulcInstancesMax == other.ulcInstancesMax
    }
}
impl ::core::cmp::Eq for BDA_TEMPLATE_PIN_JOINT {}
impl ::core::fmt::Debug for BDA_TEMPLATE_PIN_JOINT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TEMPLATE_PIN_JOINT").field("uliTemplateConnection", &self.uliTemplateConnection).field("ulcInstancesMax", &self.ulcInstancesMax).finish()
    }
}
impl ::core::default::Default for BDA_TRANSPORT_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TRANSPORT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ulcbPhyiscalPacket == other.ulcbPhyiscalPacket && self.ulcbPhyiscalFrame == other.ulcbPhyiscalFrame && self.ulcbPhyiscalFrameAlignment == other.ulcbPhyiscalFrameAlignment && self.AvgTimePerFrame == other.AvgTimePerFrame
    }
}
impl ::core::cmp::Eq for BDA_TRANSPORT_INFO {}
impl ::core::fmt::Debug for BDA_TRANSPORT_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TRANSPORT_INFO").field("ulcbPhyiscalPacket", &self.ulcbPhyiscalPacket).field("ulcbPhyiscalFrame", &self.ulcbPhyiscalFrame).field("ulcbPhyiscalFrameAlignment", &self.ulcbPhyiscalFrameAlignment).field("AvgTimePerFrame", &self.AvgTimePerFrame).finish()
    }
}
impl ::core::default::Default for BDA_TS_SELECTORINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for BDA_TS_SELECTORINFO_ISDBS_EXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TS_SELECTORINFO_ISDBS_EXT {
    fn eq(&self, other: &Self) -> bool {
        self.bTMCC == other.bTMCC
    }
}
impl ::core::cmp::Eq for BDA_TS_SELECTORINFO_ISDBS_EXT {}
impl ::core::fmt::Debug for BDA_TS_SELECTORINFO_ISDBS_EXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TS_SELECTORINFO_ISDBS_EXT").field("bTMCC", &self.bTMCC).finish()
    }
}
impl ::core::default::Default for BDA_TUNER_DIAGNOSTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TUNER_DIAGNOSTICS {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulSignalLevel == other.ulSignalLevel && self.ulSignalLevelQuality == other.ulSignalLevelQuality && self.ulSignalNoiseRatio == other.ulSignalNoiseRatio
    }
}
impl ::core::cmp::Eq for BDA_TUNER_DIAGNOSTICS {}
impl ::core::fmt::Debug for BDA_TUNER_DIAGNOSTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TUNER_DIAGNOSTICS").field("lResult", &self.lResult).field("ulSignalLevel", &self.ulSignalLevel).field("ulSignalLevelQuality", &self.ulSignalLevelQuality).field("ulSignalNoiseRatio", &self.ulSignalNoiseRatio).finish()
    }
}
impl ::core::default::Default for BDA_TUNER_TUNERSTATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_TUNER_TUNERSTATE {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulTuneLength == other.ulTuneLength && self.argbTuneData == other.argbTuneData
    }
}
impl ::core::cmp::Eq for BDA_TUNER_TUNERSTATE {}
impl ::core::fmt::Debug for BDA_TUNER_TUNERSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_TUNER_TUNERSTATE").field("lResult", &self.lResult).field("ulTuneLength", &self.ulTuneLength).field("argbTuneData", &self.argbTuneData).finish()
    }
}
impl ::core::default::Default for BDA_USERACTIVITY_INTERVAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_USERACTIVITY_INTERVAL {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulActivityInterval == other.ulActivityInterval
    }
}
impl ::core::cmp::Eq for BDA_USERACTIVITY_INTERVAL {}
impl ::core::fmt::Debug for BDA_USERACTIVITY_INTERVAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_USERACTIVITY_INTERVAL").field("lResult", &self.lResult).field("ulActivityInterval", &self.ulActivityInterval).finish()
    }
}
impl ::core::default::Default for BDA_WMDRMTUNER_PIDPROTECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_WMDRMTUNER_PIDPROTECTION {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.uuidKeyID == other.uuidKeyID
    }
}
impl ::core::cmp::Eq for BDA_WMDRMTUNER_PIDPROTECTION {}
impl ::core::fmt::Debug for BDA_WMDRMTUNER_PIDPROTECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_WMDRMTUNER_PIDPROTECTION").field("lResult", &self.lResult).field("uuidKeyID", &self.uuidKeyID).finish()
    }
}
impl ::core::default::Default for BDA_WMDRMTUNER_PURCHASEENTITLEMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_WMDRMTUNER_PURCHASEENTITLEMENT {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulDescrambleStatus == other.ulDescrambleStatus && self.ulCaptureTokenLength == other.ulCaptureTokenLength && self.argbCaptureTokenBuffer == other.argbCaptureTokenBuffer
    }
}
impl ::core::cmp::Eq for BDA_WMDRMTUNER_PURCHASEENTITLEMENT {}
impl ::core::fmt::Debug for BDA_WMDRMTUNER_PURCHASEENTITLEMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_WMDRMTUNER_PURCHASEENTITLEMENT").field("lResult", &self.lResult).field("ulDescrambleStatus", &self.ulDescrambleStatus).field("ulCaptureTokenLength", &self.ulCaptureTokenLength).field("argbCaptureTokenBuffer", &self.argbCaptureTokenBuffer).finish()
    }
}
impl ::core::default::Default for BDA_WMDRM_KEYINFOLIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_WMDRM_KEYINFOLIST {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulKeyuuidBufferLen == other.ulKeyuuidBufferLen && self.argKeyuuidBuffer == other.argKeyuuidBuffer
    }
}
impl ::core::cmp::Eq for BDA_WMDRM_KEYINFOLIST {}
impl ::core::fmt::Debug for BDA_WMDRM_KEYINFOLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_WMDRM_KEYINFOLIST").field("lResult", &self.lResult).field("ulKeyuuidBufferLen", &self.ulKeyuuidBufferLen).field("argKeyuuidBuffer", &self.argKeyuuidBuffer).finish()
    }
}
impl ::core::default::Default for BDA_WMDRM_RENEWLICENSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_WMDRM_RENEWLICENSE {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulDescrambleStatus == other.ulDescrambleStatus && self.ulXmrLicenseOutputLength == other.ulXmrLicenseOutputLength && self.argbXmrLicenceOutputBuffer == other.argbXmrLicenceOutputBuffer
    }
}
impl ::core::cmp::Eq for BDA_WMDRM_RENEWLICENSE {}
impl ::core::fmt::Debug for BDA_WMDRM_RENEWLICENSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_WMDRM_RENEWLICENSE").field("lResult", &self.lResult).field("ulDescrambleStatus", &self.ulDescrambleStatus).field("ulXmrLicenseOutputLength", &self.ulXmrLicenseOutputLength).field("argbXmrLicenceOutputBuffer", &self.argbXmrLicenceOutputBuffer).finish()
    }
}
impl ::core::default::Default for BDA_WMDRM_STATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for BDA_WMDRM_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.lResult == other.lResult && self.ulMaxCaptureTokenSize == other.ulMaxCaptureTokenSize && self.uMaxStreamingPid == other.uMaxStreamingPid && self.ulMaxLicense == other.ulMaxLicense && self.ulMinSecurityLevel == other.ulMinSecurityLevel && self.ulRevInfoSequenceNumber == other.ulRevInfoSequenceNumber && self.ulRevInfoIssuedTime == other.ulRevInfoIssuedTime && self.ulRevListVersion == other.ulRevListVersion && self.ulRevInfoTTL == other.ulRevInfoTTL && self.ulState == other.ulState
    }
}
impl ::core::cmp::Eq for BDA_WMDRM_STATUS {}
impl ::core::fmt::Debug for BDA_WMDRM_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BDA_WMDRM_STATUS")
            .field("lResult", &self.lResult)
            .field("ulMaxCaptureTokenSize", &self.ulMaxCaptureTokenSize)
            .field("uMaxStreamingPid", &self.uMaxStreamingPid)
            .field("ulMaxLicense", &self.ulMaxLicense)
            .field("ulMinSecurityLevel", &self.ulMinSecurityLevel)
            .field("ulRevInfoSequenceNumber", &self.ulRevInfoSequenceNumber)
            .field("ulRevInfoIssuedTime", &self.ulRevInfoIssuedTime)
            .field("ulRevListVersion", &self.ulRevListVersion)
            .field("ulRevInfoTTL", &self.ulRevInfoTTL)
            .field("ulState", &self.ulState)
            .finish()
    }
}
impl ::core::default::Default for BadSampleInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for BfEnTvRat_Attributes_CAE_TV {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BfEnTvRat_Attributes_CAE_TV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BfEnTvRat_Attributes_CAE_TV").field(&self.0).finish()
    }
}
impl ::core::default::Default for BfEnTvRat_Attributes_CAF_TV {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BfEnTvRat_Attributes_CAF_TV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BfEnTvRat_Attributes_CAF_TV").field(&self.0).finish()
    }
}
impl ::core::default::Default for BfEnTvRat_Attributes_MPAA {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BfEnTvRat_Attributes_MPAA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BfEnTvRat_Attributes_MPAA").field(&self.0).finish()
    }
}
impl ::core::default::Default for BfEnTvRat_Attributes_US_TV {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BfEnTvRat_Attributes_US_TV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BfEnTvRat_Attributes_US_TV").field(&self.0).finish()
    }
}
impl ::core::default::Default for BfEnTvRat_GenericAttributes {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BfEnTvRat_GenericAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BfEnTvRat_GenericAttributes").field(&self.0).finish()
    }
}
impl ::core::default::Default for BinaryConvolutionCodeRate {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BinaryConvolutionCodeRate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BinaryConvolutionCodeRate").field(&self.0).finish()
    }
}
impl ::core::default::Default for CAPTURE_STREAMTIME {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for CAPTURE_STREAMTIME {
    fn eq(&self, other: &Self) -> bool {
        self.StreamTime == other.StreamTime
    }
}
impl ::core::cmp::Eq for CAPTURE_STREAMTIME {}
impl ::core::fmt::Debug for CAPTURE_STREAMTIME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CAPTURE_STREAMTIME").field("StreamTime", &self.StreamTime).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for COLORKEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for COLORKEY {
    fn eq(&self, other: &Self) -> bool {
        self.KeyType == other.KeyType && self.PaletteIndex == other.PaletteIndex && self.LowColorValue == other.LowColorValue && self.HighColorValue == other.HighColorValue
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for COLORKEY {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for COLORKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("COLORKEY").field("KeyType", &self.KeyType).field("PaletteIndex", &self.PaletteIndex).field("LowColorValue", &self.LowColorValue).field("HighColorValue", &self.HighColorValue).finish()
    }
}
impl ::core::default::Default for COLORKEY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COLORKEY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COLORKEY_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for COMPLETION_STATUS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COMPLETION_STATUS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COMPLETION_STATUS_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPPEventBlockReason {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPPEventBlockReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPPEventBlockReason").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_ACP_Protection_Level {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_ACP_Protection_Level {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_ACP_Protection_Level").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_BusType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_BusType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_BusType").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_CGMSA_Protection_Level {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_CGMSA_Protection_Level {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_CGMSA_Protection_Level").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_ConnectorType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_ConnectorType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_ConnectorType").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_HDCP_Protection_Level {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_HDCP_Protection_Level {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_HDCP_Protection_Level").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_ImageAspectRatio_EN300294 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_ImageAspectRatio_EN300294 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_ImageAspectRatio_EN300294").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_StatusFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_StatusFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_StatusFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_StatusHDCPFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_StatusHDCPFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_StatusHDCPFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for COPP_TVProtectionStandard {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for COPP_TVProtectionStandard {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("COPP_TVProtectionStandard").field(&self.0).finish()
    }
}
impl ::core::default::Default for CPEventBitShift {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CPEventBitShift {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CPEventBitShift").field(&self.0).finish()
    }
}
impl ::core::default::Default for CPEvents {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CPEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CPEvents").field(&self.0).finish()
    }
}
impl ::core::default::Default for CPRecordingStatus {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CPRecordingStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CPRecordingStatus").field(&self.0).finish()
    }
}
impl ::core::default::Default for CRID_LOCATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CRID_LOCATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CRID_LOCATION").field(&self.0).finish()
    }
}
impl ::core::default::Default for CROSSBAR_DEFAULT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CROSSBAR_DEFAULT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CROSSBAR_DEFAULT_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for CameraControlFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CameraControlFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CameraControlFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for CameraControlProperty {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CameraControlProperty {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CameraControlProperty").field(&self.0).finish()
    }
}
impl ::core::default::Default for ChannelChangeInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for ChannelChangeInfo {
    fn eq(&self, other: &Self) -> bool {
        self.state == other.state && self.TimeStamp == other.TimeStamp
    }
}
impl ::core::cmp::Eq for ChannelChangeInfo {}
impl ::core::fmt::Debug for ChannelChangeInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ChannelChangeInfo").field("state", &self.state).field("TimeStamp", &self.TimeStamp).finish()
    }
}
impl ::core::default::Default for ChannelChangeSpanningEvent_State {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ChannelChangeSpanningEvent_State {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ChannelChangeSpanningEvent_State").field(&self.0).finish()
    }
}
impl ::core::default::Default for ChannelInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for ChannelType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ChannelType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ChannelType").field(&self.0).finish()
    }
}
impl ::core::default::Default for ChannelTypeInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for ChannelTypeInfo {
    fn eq(&self, other: &Self) -> bool {
        self.channelType == other.channelType && self.timeStamp == other.timeStamp
    }
}
impl ::core::cmp::Eq for ChannelTypeInfo {}
impl ::core::fmt::Debug for ChannelTypeInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ChannelTypeInfo").field("channelType", &self.channelType).field("timeStamp", &self.timeStamp).finish()
    }
}
impl ::core::default::Default for ComponentCategory {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ComponentCategory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ComponentCategory").field(&self.0).finish()
    }
}
impl ::core::default::Default for ComponentStatus {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ComponentStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ComponentStatus").field(&self.0).finish()
    }
}
impl ::core::default::Default for CompressionCaps {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CompressionCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CompressionCaps").field(&self.0).finish()
    }
}
impl ::core::default::Default for DDSFF_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DDSFF_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DDSFF_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for DDSFF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for DDSFF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for DDSFF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for DDSFF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for DDSFF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for DECIMATION_USAGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DECIMATION_USAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DECIMATION_USAGE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DESC_LINKAGE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DESC_LINKAGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DESC_LINKAGE_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DISPID_TUNER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DISPID_TUNER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DISPID_TUNER").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DSHOW_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DSHOW_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.VersionNo == other.VersionNo && self.StreamId == other.StreamId && self.Default == other.Default && self.Creation == other.Creation && self.Reserved == other.Reserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DSHOW_STREAM_DESC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DSHOW_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DSHOW_STREAM_DESC").field("VersionNo", &self.VersionNo).field("StreamId", &self.StreamId).field("Default", &self.Default).field("Creation", &self.Creation).field("Reserved", &self.Reserved).finish()
    }
}
impl ::core::default::Default for DSMCC_ELEMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DSMCC_FILTER_OPTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for DSMCC_SECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVBScramblingControlSpanningEvent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVBScramblingControlSpanningEvent {
    fn eq(&self, other: &Self) -> bool {
        self.ulPID == other.ulPID && self.fScrambled == other.fScrambled
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVBScramblingControlSpanningEvent {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVBScramblingControlSpanningEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVBScramblingControlSpanningEvent").field("ulPID", &self.ulPID).field("fScrambled", &self.fScrambled).finish()
    }
}
impl ::core::default::Default for DVBSystemType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVBSystemType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVBSystemType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVB_EIT_FILTER_OPTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for DVB_STRCONV_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVB_STRCONV_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVB_STRCONV_MODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVDFilterState {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVDFilterState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVDFilterState").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVDMenuIDConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVDMenuIDConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVDMenuIDConstants").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVDSPExt {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVDSPExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVDSPExt").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVDTextStringType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVDTextStringType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVDTextStringType").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_ATR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_ATR {
    fn eq(&self, other: &Self) -> bool {
        self.ulCAT == other.ulCAT && self.pbATRI == other.pbATRI
    }
}
impl ::core::cmp::Eq for DVD_ATR {}
impl ::core::fmt::Debug for DVD_ATR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_ATR").field("ulCAT", &self.ulCAT).field("pbATRI", &self.pbATRI).finish()
    }
}
impl ::core::default::Default for DVD_AUDIO_APPMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_AUDIO_APPMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_AUDIO_APPMODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_AUDIO_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_AUDIO_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_AUDIO_FORMAT").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_AUDIO_LANG_EXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_AUDIO_LANG_EXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_AUDIO_LANG_EXT").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_AudioAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVD_AudioAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.AppMode == other.AppMode && self.AppModeData == other.AppModeData && self.AudioFormat == other.AudioFormat && self.Language == other.Language && self.LanguageExtension == other.LanguageExtension && self.fHasMultichannelInfo == other.fHasMultichannelInfo && self.dwFrequency == other.dwFrequency && self.bQuantization == other.bQuantization && self.bNumberOfChannels == other.bNumberOfChannels && self.dwReserved == other.dwReserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVD_AudioAttributes {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVD_AudioAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_AudioAttributes").field("AppMode", &self.AppMode).field("AppModeData", &self.AppModeData).field("AudioFormat", &self.AudioFormat).field("Language", &self.Language).field("LanguageExtension", &self.LanguageExtension).field("fHasMultichannelInfo", &self.fHasMultichannelInfo).field("dwFrequency", &self.dwFrequency).field("bQuantization", &self.bQuantization).field("bNumberOfChannels", &self.bNumberOfChannels).field("dwReserved", &self.dwReserved).finish()
    }
}
impl ::core::default::Default for DVD_CMD_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_CMD_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_CMD_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_DECODER_CAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_DECODER_CAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwAudioCaps == other.dwAudioCaps && self.dFwdMaxRateVideo == other.dFwdMaxRateVideo && self.dFwdMaxRateAudio == other.dFwdMaxRateAudio && self.dFwdMaxRateSP == other.dFwdMaxRateSP && self.dBwdMaxRateVideo == other.dBwdMaxRateVideo && self.dBwdMaxRateAudio == other.dBwdMaxRateAudio && self.dBwdMaxRateSP == other.dBwdMaxRateSP && self.dwRes1 == other.dwRes1 && self.dwRes2 == other.dwRes2 && self.dwRes3 == other.dwRes3 && self.dwRes4 == other.dwRes4
    }
}
impl ::core::cmp::Eq for DVD_DECODER_CAPS {}
impl ::core::fmt::Debug for DVD_DECODER_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_DECODER_CAPS")
            .field("dwSize", &self.dwSize)
            .field("dwAudioCaps", &self.dwAudioCaps)
            .field("dFwdMaxRateVideo", &self.dFwdMaxRateVideo)
            .field("dFwdMaxRateAudio", &self.dFwdMaxRateAudio)
            .field("dFwdMaxRateSP", &self.dFwdMaxRateSP)
            .field("dBwdMaxRateVideo", &self.dBwdMaxRateVideo)
            .field("dBwdMaxRateAudio", &self.dBwdMaxRateAudio)
            .field("dBwdMaxRateSP", &self.dBwdMaxRateSP)
            .field("dwRes1", &self.dwRes1)
            .field("dwRes2", &self.dwRes2)
            .field("dwRes3", &self.dwRes3)
            .field("dwRes4", &self.dwRes4)
            .finish()
    }
}
impl ::core::default::Default for DVD_DISC_SIDE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_DISC_SIDE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_DISC_SIDE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_DOMAIN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_DOMAIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_DOMAIN").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_ERROR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_ERROR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_ERROR").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_FRAMERATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_FRAMERATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_FRAMERATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_HMSF_TIMECODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_HMSF_TIMECODE {
    fn eq(&self, other: &Self) -> bool {
        self.bHours == other.bHours && self.bMinutes == other.bMinutes && self.bSeconds == other.bSeconds && self.bFrames == other.bFrames
    }
}
impl ::core::cmp::Eq for DVD_HMSF_TIMECODE {}
impl ::core::fmt::Debug for DVD_HMSF_TIMECODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_HMSF_TIMECODE").field("bHours", &self.bHours).field("bMinutes", &self.bMinutes).field("bSeconds", &self.bSeconds).field("bFrames", &self.bFrames).finish()
    }
}
impl ::core::default::Default for DVD_KARAOKE_ASSIGNMENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_KARAOKE_ASSIGNMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_KARAOKE_ASSIGNMENT").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_KARAOKE_CONTENTS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_KARAOKE_CONTENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_KARAOKE_CONTENTS").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_KARAOKE_DOWNMIX {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_KARAOKE_DOWNMIX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_KARAOKE_DOWNMIX").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_KaraokeAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVD_KaraokeAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.bVersion == other.bVersion && self.fMasterOfCeremoniesInGuideVocal1 == other.fMasterOfCeremoniesInGuideVocal1 && self.fDuet == other.fDuet && self.ChannelAssignment == other.ChannelAssignment && self.wChannelContents == other.wChannelContents
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVD_KaraokeAttributes {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVD_KaraokeAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_KaraokeAttributes").field("bVersion", &self.bVersion).field("fMasterOfCeremoniesInGuideVocal1", &self.fMasterOfCeremoniesInGuideVocal1).field("fDuet", &self.fDuet).field("ChannelAssignment", &self.ChannelAssignment).field("wChannelContents", &self.wChannelContents).finish()
    }
}
impl ::core::default::Default for DVD_MENU_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_MENU_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_MENU_ID").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_MUA_Coeff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_MUA_Coeff {
    fn eq(&self, other: &Self) -> bool {
        self.log2_alpha == other.log2_alpha && self.log2_beta == other.log2_beta
    }
}
impl ::core::cmp::Eq for DVD_MUA_Coeff {}
impl ::core::fmt::Debug for DVD_MUA_Coeff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_MUA_Coeff").field("log2_alpha", &self.log2_alpha).field("log2_beta", &self.log2_beta).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_MUA_MixingInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVD_MUA_MixingInfo {
    fn eq(&self, other: &Self) -> bool {
        self.fMixTo0 == other.fMixTo0 && self.fMixTo1 == other.fMixTo1 && self.fMix0InPhase == other.fMix0InPhase && self.fMix1InPhase == other.fMix1InPhase && self.dwSpeakerPosition == other.dwSpeakerPosition
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVD_MUA_MixingInfo {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVD_MUA_MixingInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_MUA_MixingInfo").field("fMixTo0", &self.fMixTo0).field("fMixTo1", &self.fMixTo1).field("fMix0InPhase", &self.fMix0InPhase).field("fMix1InPhase", &self.fMix1InPhase).field("dwSpeakerPosition", &self.dwSpeakerPosition).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_MenuAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVD_MenuAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.fCompatibleRegion == other.fCompatibleRegion && self.VideoAttributes == other.VideoAttributes && self.fAudioPresent == other.fAudioPresent && self.AudioAttributes == other.AudioAttributes && self.fSubpicturePresent == other.fSubpicturePresent && self.SubpictureAttributes == other.SubpictureAttributes
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVD_MenuAttributes {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVD_MenuAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_MenuAttributes").field("fCompatibleRegion", &self.fCompatibleRegion).field("VideoAttributes", &self.VideoAttributes).field("fAudioPresent", &self.fAudioPresent).field("AudioAttributes", &self.AudioAttributes).field("fSubpicturePresent", &self.fSubpicturePresent).field("SubpictureAttributes", &self.SubpictureAttributes).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_MultichannelAudioAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVD_MultichannelAudioAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.Info == other.Info && self.Coeff == other.Coeff
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVD_MultichannelAudioAttributes {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVD_MultichannelAudioAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_MultichannelAudioAttributes").field("Info", &self.Info).field("Coeff", &self.Coeff).finish()
    }
}
impl ::core::default::Default for DVD_NavCmdType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_NavCmdType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_NavCmdType").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_OPTION_FLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_OPTION_FLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_OPTION_FLAG").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_PARENTAL_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_PARENTAL_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_PARENTAL_LEVEL").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_PB_STOPPED {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_PB_STOPPED {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_PB_STOPPED").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_PLAYBACK_LOCATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_PLAYBACK_LOCATION {
    fn eq(&self, other: &Self) -> bool {
        self.TitleNum == other.TitleNum && self.ChapterNum == other.ChapterNum && self.TimeCode == other.TimeCode
    }
}
impl ::core::cmp::Eq for DVD_PLAYBACK_LOCATION {}
impl ::core::fmt::Debug for DVD_PLAYBACK_LOCATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_PLAYBACK_LOCATION").field("TitleNum", &self.TitleNum).field("ChapterNum", &self.ChapterNum).field("TimeCode", &self.TimeCode).finish()
    }
}
impl ::core::default::Default for DVD_PLAYBACK_LOCATION2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_PLAYBACK_LOCATION2 {
    fn eq(&self, other: &Self) -> bool {
        self.TitleNum == other.TitleNum && self.ChapterNum == other.ChapterNum && self.TimeCode == other.TimeCode && self.TimeCodeFlags == other.TimeCodeFlags
    }
}
impl ::core::cmp::Eq for DVD_PLAYBACK_LOCATION2 {}
impl ::core::fmt::Debug for DVD_PLAYBACK_LOCATION2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_PLAYBACK_LOCATION2").field("TitleNum", &self.TitleNum).field("ChapterNum", &self.ChapterNum).field("TimeCode", &self.TimeCode).field("TimeCodeFlags", &self.TimeCodeFlags).finish()
    }
}
impl ::core::default::Default for DVD_PLAY_DIRECTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_PLAY_DIRECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_PLAY_DIRECTION").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_PREFERRED_DISPLAY_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_PREFERRED_DISPLAY_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_PREFERRED_DISPLAY_MODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_REGION {
    fn eq(&self, other: &Self) -> bool {
        self.CopySystem == other.CopySystem && self.RegionData == other.RegionData && self.SystemRegion == other.SystemRegion && self.ResetCount == other.ResetCount
    }
}
impl ::core::cmp::Eq for DVD_REGION {}
impl ::core::fmt::Debug for DVD_REGION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_REGION").field("CopySystem", &self.CopySystem).field("RegionData", &self.RegionData).field("SystemRegion", &self.SystemRegion).field("ResetCount", &self.ResetCount).finish()
    }
}
impl ::core::default::Default for DVD_RELATIVE_BUTTON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_RELATIVE_BUTTON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_RELATIVE_BUTTON").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_SUBPICTURE_CODING {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_SUBPICTURE_CODING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_SUBPICTURE_CODING").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_SUBPICTURE_LANG_EXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_SUBPICTURE_LANG_EXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_SUBPICTURE_LANG_EXT").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_SUBPICTURE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_SUBPICTURE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_SUBPICTURE_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_SubpictureAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_SubpictureAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.CodingMode == other.CodingMode && self.Language == other.Language && self.LanguageExtension == other.LanguageExtension
    }
}
impl ::core::cmp::Eq for DVD_SubpictureAttributes {}
impl ::core::fmt::Debug for DVD_SubpictureAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_SubpictureAttributes").field("Type", &self.Type).field("CodingMode", &self.CodingMode).field("Language", &self.Language).field("LanguageExtension", &self.LanguageExtension).finish()
    }
}
impl ::core::default::Default for DVD_TIMECODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVD_TIMECODE {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for DVD_TIMECODE {}
impl ::core::fmt::Debug for DVD_TIMECODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_TIMECODE").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::core::default::Default for DVD_TIMECODE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_TIMECODE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_TIMECODE_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_TITLE_APPMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_TITLE_APPMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_TITLE_APPMODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_TextCharSet {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_TextCharSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_TextCharSet").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVD_TextStringType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_TextStringType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_TextStringType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_TitleAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for DVD_VIDEO_COMPRESSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_VIDEO_COMPRESSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_VIDEO_COMPRESSION").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DVD_VideoAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DVD_VideoAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.fPanscanPermitted == other.fPanscanPermitted && self.fLetterboxPermitted == other.fLetterboxPermitted && self.ulAspectX == other.ulAspectX && self.ulAspectY == other.ulAspectY && self.ulFrameRate == other.ulFrameRate && self.ulFrameHeight == other.ulFrameHeight && self.Compression == other.Compression && self.fLine21Field1InGOP == other.fLine21Field1InGOP && self.fLine21Field2InGOP == other.fLine21Field2InGOP && self.ulSourceResolutionX == other.ulSourceResolutionX && self.ulSourceResolutionY == other.ulSourceResolutionY && self.fIsSourceLetterboxed == other.fIsSourceLetterboxed && self.fIsFilmMode == other.fIsFilmMode
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DVD_VideoAttributes {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DVD_VideoAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVD_VideoAttributes")
            .field("fPanscanPermitted", &self.fPanscanPermitted)
            .field("fLetterboxPermitted", &self.fLetterboxPermitted)
            .field("ulAspectX", &self.ulAspectX)
            .field("ulAspectY", &self.ulAspectY)
            .field("ulFrameRate", &self.ulFrameRate)
            .field("ulFrameHeight", &self.ulFrameHeight)
            .field("Compression", &self.Compression)
            .field("fLine21Field1InGOP", &self.fLine21Field1InGOP)
            .field("fLine21Field2InGOP", &self.fLine21Field2InGOP)
            .field("ulSourceResolutionX", &self.ulSourceResolutionX)
            .field("ulSourceResolutionY", &self.ulSourceResolutionY)
            .field("fIsSourceLetterboxed", &self.fIsSourceLetterboxed)
            .field("fIsFilmMode", &self.fIsFilmMode)
            .finish()
    }
}
impl ::core::default::Default for DVD_WARNING {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DVD_WARNING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DVD_WARNING").field(&self.0).finish()
    }
}
impl ::core::default::Default for DVINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DVINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwDVAAuxSrc == other.dwDVAAuxSrc && self.dwDVAAuxCtl == other.dwDVAAuxCtl && self.dwDVAAuxSrc1 == other.dwDVAAuxSrc1 && self.dwDVAAuxCtl1 == other.dwDVAAuxCtl1 && self.dwDVVAuxSrc == other.dwDVVAuxSrc && self.dwDVVAuxCtl == other.dwDVVAuxCtl && self.dwDVReserved == other.dwDVReserved
    }
}
impl ::core::cmp::Eq for DVINFO {}
impl ::core::fmt::Debug for DVINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVINFO").field("dwDVAAuxSrc", &self.dwDVAAuxSrc).field("dwDVAAuxCtl", &self.dwDVAAuxCtl).field("dwDVAAuxSrc1", &self.dwDVAAuxSrc1).field("dwDVAAuxCtl1", &self.dwDVAAuxCtl1).field("dwDVVAuxSrc", &self.dwDVVAuxSrc).field("dwDVVAuxCtl", &self.dwDVVAuxCtl).field("dwDVReserved", &self.dwDVReserved).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for DVR_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::PartialEq for DVR_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.StreamId == other.StreamId && self.Default == other.Default && self.Creation == other.Creation && self.Reserved == other.Reserved && self.guidSubMediaType == other.guidSubMediaType && self.guidFormatType == other.guidFormatType && self.MediaType == other.MediaType
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::cmp::Eq for DVR_STREAM_DESC {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::fmt::Debug for DVR_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DVR_STREAM_DESC").field("Version", &self.Version).field("StreamId", &self.StreamId).field("Default", &self.Default).field("Creation", &self.Creation).field("Reserved", &self.Reserved).field("guidSubMediaType", &self.guidSubMediaType).field("guidFormatType", &self.guidFormatType).field("MediaType", &self.MediaType).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for DXVA2SW_CALLBACKS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2TraceVideoProcessBltData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2Trace_DecodeDevBeginFrameData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2Trace_DecodeDevCreatedData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2Trace_DecodeDevGetBufferData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2Trace_DecodeDeviceData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2Trace_VideoProcessDevCreatedData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Diagnostics_Etw"))]
impl ::core::default::Default for DXVA2Trace_VideoProcessDeviceData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for DXVA2_DestinationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DXVA2_DestinationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_DestinationFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for DXVA2_SampleFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DXVA2_SampleFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_SampleFlags").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for DXVA2_VIDEOPROCESSBLT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
impl ::core::default::Default for DXVA2_VIDEOSAMPLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for DXVA_COPPSetProtectionLevelCmdData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DXVA_COPPSetProtectionLevelCmdData {
    fn eq(&self, other: &Self) -> bool {
        self.ProtType == other.ProtType && self.ProtLevel == other.ProtLevel && self.ExtendedInfoChangeMask == other.ExtendedInfoChangeMask && self.ExtendedInfoData == other.ExtendedInfoData
    }
}
impl ::core::cmp::Eq for DXVA_COPPSetProtectionLevelCmdData {}
impl ::core::fmt::Debug for DXVA_COPPSetProtectionLevelCmdData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPSetProtectionLevelCmdData").field("ProtType", &self.ProtType).field("ProtLevel", &self.ProtLevel).field("ExtendedInfoChangeMask", &self.ExtendedInfoChangeMask).field("ExtendedInfoData", &self.ExtendedInfoData).finish()
    }
}
impl ::core::default::Default for DXVA_COPPSetSignalingCmdData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DXVA_COPPSetSignalingCmdData {
    fn eq(&self, other: &Self) -> bool {
        self.ActiveTVProtectionStandard == other.ActiveTVProtectionStandard && self.AspectRatioChangeMask1 == other.AspectRatioChangeMask1 && self.AspectRatioData1 == other.AspectRatioData1 && self.AspectRatioChangeMask2 == other.AspectRatioChangeMask2 && self.AspectRatioData2 == other.AspectRatioData2 && self.AspectRatioChangeMask3 == other.AspectRatioChangeMask3 && self.AspectRatioData3 == other.AspectRatioData3 && self.ExtendedInfoChangeMask == other.ExtendedInfoChangeMask && self.ExtendedInfoData == other.ExtendedInfoData && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for DXVA_COPPSetSignalingCmdData {}
impl ::core::fmt::Debug for DXVA_COPPSetSignalingCmdData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPSetSignalingCmdData")
            .field("ActiveTVProtectionStandard", &self.ActiveTVProtectionStandard)
            .field("AspectRatioChangeMask1", &self.AspectRatioChangeMask1)
            .field("AspectRatioData1", &self.AspectRatioData1)
            .field("AspectRatioChangeMask2", &self.AspectRatioChangeMask2)
            .field("AspectRatioData2", &self.AspectRatioData2)
            .field("AspectRatioChangeMask3", &self.AspectRatioChangeMask3)
            .field("AspectRatioData3", &self.AspectRatioData3)
            .field("ExtendedInfoChangeMask", &self.ExtendedInfoChangeMask)
            .field("ExtendedInfoData", &self.ExtendedInfoData)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::core::default::Default for DXVA_COPPStatusData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DXVA_COPPStatusData {
    fn eq(&self, other: &Self) -> bool {
        self.rApp == other.rApp && self.dwFlags == other.dwFlags && self.dwData == other.dwData && self.ExtendedInfoValidMask == other.ExtendedInfoValidMask && self.ExtendedInfoData == other.ExtendedInfoData
    }
}
impl ::core::cmp::Eq for DXVA_COPPStatusData {}
impl ::core::fmt::Debug for DXVA_COPPStatusData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPStatusData").field("rApp", &self.rApp).field("dwFlags", &self.dwFlags).field("dwData", &self.dwData).field("ExtendedInfoValidMask", &self.ExtendedInfoValidMask).field("ExtendedInfoData", &self.ExtendedInfoData).finish()
    }
}
impl ::core::default::Default for DXVA_COPPStatusDisplayData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DXVA_COPPStatusDisplayData {
    fn eq(&self, other: &Self) -> bool {
        self.rApp == other.rApp && self.dwFlags == other.dwFlags && self.DisplayWidth == other.DisplayWidth && self.DisplayHeight == other.DisplayHeight && self.Format == other.Format && self.d3dFormat == other.d3dFormat && self.FreqNumerator == other.FreqNumerator && self.FreqDenominator == other.FreqDenominator
    }
}
impl ::core::cmp::Eq for DXVA_COPPStatusDisplayData {}
impl ::core::fmt::Debug for DXVA_COPPStatusDisplayData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPStatusDisplayData").field("rApp", &self.rApp).field("dwFlags", &self.dwFlags).field("DisplayWidth", &self.DisplayWidth).field("DisplayHeight", &self.DisplayHeight).field("Format", &self.Format).field("d3dFormat", &self.d3dFormat).field("FreqNumerator", &self.FreqNumerator).field("FreqDenominator", &self.FreqDenominator).finish()
    }
}
impl ::core::default::Default for DXVA_COPPStatusHDCPKeyData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DXVA_COPPStatusHDCPKeyData {
    fn eq(&self, other: &Self) -> bool {
        self.rApp == other.rApp && self.dwFlags == other.dwFlags && self.dwHDCPFlags == other.dwHDCPFlags && self.BKey == other.BKey && self.Reserved1 == other.Reserved1 && self.Reserved2 == other.Reserved2
    }
}
impl ::core::cmp::Eq for DXVA_COPPStatusHDCPKeyData {}
impl ::core::fmt::Debug for DXVA_COPPStatusHDCPKeyData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPStatusHDCPKeyData").field("rApp", &self.rApp).field("dwFlags", &self.dwFlags).field("dwHDCPFlags", &self.dwHDCPFlags).field("BKey", &self.BKey).field("Reserved1", &self.Reserved1).field("Reserved2", &self.Reserved2).finish()
    }
}
impl ::core::default::Default for DXVA_COPPStatusSignalingCmdData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DXVA_COPPStatusSignalingCmdData {
    fn eq(&self, other: &Self) -> bool {
        self.rApp == other.rApp && self.dwFlags == other.dwFlags && self.AvailableTVProtectionStandards == other.AvailableTVProtectionStandards && self.ActiveTVProtectionStandard == other.ActiveTVProtectionStandard && self.TVType == other.TVType && self.AspectRatioValidMask1 == other.AspectRatioValidMask1 && self.AspectRatioData1 == other.AspectRatioData1 && self.AspectRatioValidMask2 == other.AspectRatioValidMask2 && self.AspectRatioData2 == other.AspectRatioData2 && self.AspectRatioValidMask3 == other.AspectRatioValidMask3 && self.AspectRatioData3 == other.AspectRatioData3 && self.ExtendedInfoValidMask == other.ExtendedInfoValidMask && self.ExtendedInfoData == other.ExtendedInfoData
    }
}
impl ::core::cmp::Eq for DXVA_COPPStatusSignalingCmdData {}
impl ::core::fmt::Debug for DXVA_COPPStatusSignalingCmdData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPStatusSignalingCmdData")
            .field("rApp", &self.rApp)
            .field("dwFlags", &self.dwFlags)
            .field("AvailableTVProtectionStandards", &self.AvailableTVProtectionStandards)
            .field("ActiveTVProtectionStandard", &self.ActiveTVProtectionStandard)
            .field("TVType", &self.TVType)
            .field("AspectRatioValidMask1", &self.AspectRatioValidMask1)
            .field("AspectRatioData1", &self.AspectRatioData1)
            .field("AspectRatioValidMask2", &self.AspectRatioValidMask2)
            .field("AspectRatioData2", &self.AspectRatioData2)
            .field("AspectRatioValidMask3", &self.AspectRatioValidMask3)
            .field("AspectRatioData3", &self.AspectRatioData3)
            .field("ExtendedInfoValidMask", &self.ExtendedInfoValidMask)
            .field("ExtendedInfoData", &self.ExtendedInfoData)
            .finish()
    }
}
impl ::core::default::Default for DisplaySizeList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DisplaySizeList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DisplaySizeList").field(&self.0).finish()
    }
}
impl ::core::default::Default for DownResEventParam {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DownResEventParam {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DownResEventParam").field(&self.0).finish()
    }
}
impl ::core::default::Default for DualMonoInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for DualMonoInfo {
    fn eq(&self, other: &Self) -> bool {
        self.LangID1 == other.LangID1 && self.LangID2 == other.LangID2 && self.lISOLangCode1 == other.lISOLangCode1 && self.lISOLangCode2 == other.lISOLangCode2
    }
}
impl ::core::cmp::Eq for DualMonoInfo {}
impl ::core::fmt::Debug for DualMonoInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DualMonoInfo").field("LangID1", &self.LangID1).field("LangID2", &self.LangID2).field("lISOLangCode1", &self.lISOLangCode1).field("lISOLangCode2", &self.lISOLangCode2).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DvbParentalRatingDescriptor {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DvbParentalRatingDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.ulNumParams == other.ulNumParams && self.pParams == other.pParams
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DvbParentalRatingDescriptor {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DvbParentalRatingDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DvbParentalRatingDescriptor").field("ulNumParams", &self.ulNumParams).field("pParams", &self.pParams).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DvbParentalRatingParam {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DvbParentalRatingParam {
    fn eq(&self, other: &Self) -> bool {
        self.szCountryCode == other.szCountryCode && self.bRating == other.bRating
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DvbParentalRatingParam {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DvbParentalRatingParam {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DvbParentalRatingParam").field("szCountryCode", &self.szCountryCode).field("bRating", &self.bRating).finish()
    }
}
impl ::core::default::Default for EALocationCodeType {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for EALocationCodeType {
    fn eq(&self, other: &Self) -> bool {
        self.LocationCodeScheme == other.LocationCodeScheme && self.state_code == other.state_code && self.county_subdivision == other.county_subdivision && self.county_code == other.county_code
    }
}
impl ::core::cmp::Eq for EALocationCodeType {}
impl ::core::fmt::Debug for EALocationCodeType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EALocationCodeType").field("LocationCodeScheme", &self.LocationCodeScheme).field("state_code", &self.state_code).field("county_subdivision", &self.county_subdivision).field("county_code", &self.county_code).finish()
    }
}
impl ::core::default::Default for EnTag_Mode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTag_Mode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTag_Mode").field(&self.0).finish()
    }
}
impl ::core::default::Default for EnTvRat_CAE_TV {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTvRat_CAE_TV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTvRat_CAE_TV").field(&self.0).finish()
    }
}
impl ::core::default::Default for EnTvRat_CAF_TV {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTvRat_CAF_TV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTvRat_CAF_TV").field(&self.0).finish()
    }
}
impl ::core::default::Default for EnTvRat_GenericLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTvRat_GenericLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTvRat_GenericLevel").field(&self.0).finish()
    }
}
impl ::core::default::Default for EnTvRat_MPAA {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTvRat_MPAA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTvRat_MPAA").field(&self.0).finish()
    }
}
impl ::core::default::Default for EnTvRat_System {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTvRat_System {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTvRat_System").field(&self.0).finish()
    }
}
impl ::core::default::Default for EnTvRat_US_TV {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EnTvRat_US_TV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EnTvRat_US_TV").field(&self.0).finish()
    }
}
impl ::core::default::Default for EncDecEvents {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EncDecEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EncDecEvents").field(&self.0).finish()
    }
}
impl ::core::default::Default for EntitlementType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EntitlementType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EntitlementType").field(&self.0).finish()
    }
}
impl ::core::default::Default for FECMethod {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FECMethod {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FECMethod").field(&self.0).finish()
    }
}
impl ::core::default::Default for FILTER_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for FILTER_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.achName == other.achName && self.pGraph == other.pGraph
    }
}
impl ::core::cmp::Eq for FILTER_INFO {}
impl ::core::fmt::Debug for FILTER_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILTER_INFO").field("achName", &self.achName).field("pGraph", &self.pGraph).finish()
    }
}
impl ::core::default::Default for FILTER_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FILTER_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILTER_STATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for FormatNotSupportedEvents {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FormatNotSupportedEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FormatNotSupportedEvents").field(&self.0).finish()
    }
}
impl ::core::default::Default for GuardInterval {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for GuardInterval {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("GuardInterval").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl ::core::default::Default for HEAACWAVEFORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl ::core::default::Default for HEAACWAVEINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for HierarchyAlpha {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HierarchyAlpha {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HierarchyAlpha").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMAnalogVideoDecoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMAnalogVideoDecoder {}
impl ::core::fmt::Debug for IAMAnalogVideoDecoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMAnalogVideoDecoder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMAnalogVideoEncoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMAnalogVideoEncoder {}
impl ::core::fmt::Debug for IAMAnalogVideoEncoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMAnalogVideoEncoder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMAsyncReaderTimestampScaling {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMAsyncReaderTimestampScaling {}
impl ::core::fmt::Debug for IAMAsyncReaderTimestampScaling {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMAsyncReaderTimestampScaling").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMAudioInputMixer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMAudioInputMixer {}
impl ::core::fmt::Debug for IAMAudioInputMixer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMAudioInputMixer").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMAudioRendererStats {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMAudioRendererStats {}
impl ::core::fmt::Debug for IAMAudioRendererStats {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMAudioRendererStats").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMBufferNegotiation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMBufferNegotiation {}
impl ::core::fmt::Debug for IAMBufferNegotiation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMBufferNegotiation").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMCameraControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMCameraControl {}
impl ::core::fmt::Debug for IAMCameraControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMCameraControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMCertifiedOutputProtection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMCertifiedOutputProtection {}
impl ::core::fmt::Debug for IAMCertifiedOutputProtection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMCertifiedOutputProtection").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMChannelInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMChannelInfo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMChannelInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMChannelInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMClockAdjust {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMClockAdjust {}
impl ::core::fmt::Debug for IAMClockAdjust {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMClockAdjust").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMClockSlave {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMClockSlave {}
impl ::core::fmt::Debug for IAMClockSlave {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMClockSlave").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMCollection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMCollection {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMCollection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMCollection").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMCopyCaptureFileProgress {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMCopyCaptureFileProgress {}
impl ::core::fmt::Debug for IAMCopyCaptureFileProgress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMCopyCaptureFileProgress").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMCrossbar {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMCrossbar {}
impl ::core::fmt::Debug for IAMCrossbar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMCrossbar").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMDecoderCaps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMDecoderCaps {}
impl ::core::fmt::Debug for IAMDecoderCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMDecoderCaps").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMDevMemoryAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMDevMemoryAllocator {}
impl ::core::fmt::Debug for IAMDevMemoryAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMDevMemoryAllocator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMDevMemoryControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMDevMemoryControl {}
impl ::core::fmt::Debug for IAMDevMemoryControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMDevMemoryControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMDeviceRemoval {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMDeviceRemoval {}
impl ::core::fmt::Debug for IAMDeviceRemoval {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMDeviceRemoval").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMDirectSound {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMDirectSound {}
impl ::core::fmt::Debug for IAMDirectSound {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMDirectSound").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMDroppedFrames {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMDroppedFrames {}
impl ::core::fmt::Debug for IAMDroppedFrames {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMDroppedFrames").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMExtDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMExtDevice {}
impl ::core::fmt::Debug for IAMExtDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMExtDevice").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMExtTransport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMExtTransport {}
impl ::core::fmt::Debug for IAMExtTransport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMExtTransport").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMExtendedErrorInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMExtendedErrorInfo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMExtendedErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMExtendedErrorInfo").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMExtendedSeeking {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMExtendedSeeking {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMExtendedSeeking {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMExtendedSeeking").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMFilterGraphCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMFilterGraphCallback {}
impl ::core::fmt::Debug for IAMFilterGraphCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMFilterGraphCallback").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMFilterMiscFlags {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMFilterMiscFlags {}
impl ::core::fmt::Debug for IAMFilterMiscFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMFilterMiscFlags").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMGraphBuilderCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMGraphBuilderCallback {}
impl ::core::fmt::Debug for IAMGraphBuilderCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMGraphBuilderCallback").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMGraphStreams {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMGraphStreams {}
impl ::core::fmt::Debug for IAMGraphStreams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMGraphStreams").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMLatency {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMLatency {}
impl ::core::fmt::Debug for IAMLatency {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMLatency").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMLine21Decoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMLine21Decoder {}
impl ::core::fmt::Debug for IAMLine21Decoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMLine21Decoder").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMMediaContent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMMediaContent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMMediaContent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMMediaContent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMMediaContent2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMMediaContent2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMMediaContent2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMMediaContent2").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMMediaStream {}
impl ::core::fmt::Debug for IAMMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMMediaStream").field(&self.0).finish()
    }
}
impl IAMMediaStream {
    pub unsafe fn GetMultiMediaStream(&self) -> ::windows::core::Result<IMultiMediaStream> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMultiMediaStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetInformation(&self, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetInformation)(::windows::core::Vtable::as_raw(self), ppurposeid, ptype).ok()
    }
    pub unsafe fn SetSameFormat<P0>(&self, pstreamthathasdesiredformat: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMediaStream>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSameFormat)(::windows::core::Vtable::as_raw(self), pstreamthathasdesiredformat.into().abi(), dwflags).ok()
    }
    pub unsafe fn AllocateSample(&self, dwflags: u32) -> ::windows::core::Result<IStreamSample> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AllocateSample)(::windows::core::Vtable::as_raw(self), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CreateSharedSample<P0>(&self, pexistingsample: P0, dwflags: u32) -> ::windows::core::Result<IStreamSample>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IStreamSample>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateSharedSample)(::windows::core::Vtable::as_raw(self), pexistingsample.into().abi(), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SendEndOfStream(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SendEndOfStream)(::windows::core::Vtable::as_raw(self), dwflags).ok()
    }
}
impl ::core::cmp::PartialEq for IAMMediaTypeSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMMediaTypeSample {}
impl ::core::fmt::Debug for IAMMediaTypeSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMMediaTypeSample").field(&self.0).finish()
    }
}
impl IAMMediaTypeSample {
    pub unsafe fn GetMediaStream(&self, ppmediastream: *const ::core::option::Option<IMediaStream>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetMediaStream)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(ppmediastream)).ok()
    }
    pub unsafe fn GetSampleTimes(&self, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetSampleTimes)(::windows::core::Vtable::as_raw(self), pstarttime, pendtime, pcurrenttime).ok()
    }
    pub unsafe fn SetSampleTimes(&self, pstarttime: *const i64, pendtime: *const i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSampleTimes)(::windows::core::Vtable::as_raw(self), pstarttime, pendtime).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Update<P0>(&self, dwflags: u32, hevent: P0, pfnapc: super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.Update)(::windows::core::Vtable::as_raw(self), dwflags, hevent.into(), pfnapc, dwapcdata).ok()
    }
    pub unsafe fn CompletionStatus(&self, dwflags: u32, dwmilliseconds: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CompletionStatus)(::windows::core::Vtable::as_raw(self), dwflags, dwmilliseconds).ok()
    }
}
impl ::core::cmp::PartialEq for IAMMediaTypeStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMMediaTypeStream {}
impl ::core::fmt::Debug for IAMMediaTypeStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMMediaTypeStream").field(&self.0).finish()
    }
}
impl IAMMediaTypeStream {
    pub unsafe fn GetMultiMediaStream(&self) -> ::windows::core::Result<IMultiMediaStream> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMultiMediaStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetInformation(&self, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetInformation)(::windows::core::Vtable::as_raw(self), ppurposeid, ptype).ok()
    }
    pub unsafe fn SetSameFormat<P0>(&self, pstreamthathasdesiredformat: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMediaStream>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSameFormat)(::windows::core::Vtable::as_raw(self), pstreamthathasdesiredformat.into().abi(), dwflags).ok()
    }
    pub unsafe fn AllocateSample(&self, dwflags: u32) -> ::windows::core::Result<IStreamSample> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AllocateSample)(::windows::core::Vtable::as_raw(self), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CreateSharedSample<P0>(&self, pexistingsample: P0, dwflags: u32) -> ::windows::core::Result<IStreamSample>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IStreamSample>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateSharedSample)(::windows::core::Vtable::as_raw(self), pexistingsample.into().abi(), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SendEndOfStream(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SendEndOfStream)(::windows::core::Vtable::as_raw(self), dwflags).ok()
    }
}
impl ::core::cmp::PartialEq for IAMMultiMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMMultiMediaStream {}
impl ::core::fmt::Debug for IAMMultiMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMMultiMediaStream").field(&self.0).finish()
    }
}
impl IAMMultiMediaStream {
    pub unsafe fn GetInformation(&self, pdwflags: *mut MMSSF_GET_INFORMATION_FLAGS, pstreamtype: *mut STREAM_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetInformation)(::windows::core::Vtable::as_raw(self), pdwflags, pstreamtype).ok()
    }
    pub unsafe fn GetMediaStream(&self, idpurpose: *const ::windows::core::GUID) -> ::windows::core::Result<IMediaStream> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMediaStream)(::windows::core::Vtable::as_raw(self), idpurpose, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn EnumMediaStreams(&self, index: i32) -> ::windows::core::Result<IMediaStream> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumMediaStreams)(::windows::core::Vtable::as_raw(self), index, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetState(&self) -> ::windows::core::Result<STREAM_STATE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetState)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetState(&self, newstate: STREAM_STATE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetState)(::windows::core::Vtable::as_raw(self), newstate).ok()
    }
    pub unsafe fn GetTime(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTime)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetDuration(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetDuration)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Seek(&self, seektime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Seek)(::windows::core::Vtable::as_raw(self), seektime).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetEndOfStreamEventHandle(&self) -> ::windows::core::Result<super::super::Foundation::HANDLE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEndOfStreamEventHandle)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMNetShowConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMNetShowConfig {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMNetShowConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMNetShowConfig").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMNetShowExProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMNetShowExProps {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMNetShowExProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMNetShowExProps").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMNetShowPreroll {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMNetShowPreroll {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMNetShowPreroll {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMNetShowPreroll").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMNetworkStatus {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMNetworkStatus {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMNetworkStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMNetworkStatus").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMOpenProgress {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMOpenProgress {}
impl ::core::fmt::Debug for IAMOpenProgress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMOpenProgress").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMOverlayFX {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMOverlayFX {}
impl ::core::fmt::Debug for IAMOverlayFX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMOverlayFX").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMParse {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMParse {}
impl ::core::fmt::Debug for IAMParse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMParse").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMPhysicalPinInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMPhysicalPinInfo {}
impl ::core::fmt::Debug for IAMPhysicalPinInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMPhysicalPinInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMPlayList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMPlayList {}
impl ::core::fmt::Debug for IAMPlayList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMPlayList").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMPlayListItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMPlayListItem {}
impl ::core::fmt::Debug for IAMPlayListItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMPlayListItem").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMPluginControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMPluginControl {}
impl ::core::fmt::Debug for IAMPluginControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMPluginControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMPushSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMPushSource {}
impl ::core::fmt::Debug for IAMPushSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMPushSource").field(&self.0).finish()
    }
}
impl IAMPushSource {
    pub unsafe fn GetLatency(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetLatency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IAMRebuild {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMRebuild {}
impl ::core::fmt::Debug for IAMRebuild {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMRebuild").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMResourceControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMResourceControl {}
impl ::core::fmt::Debug for IAMResourceControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMResourceControl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAMStats {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAMStats {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAMStats {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMStats").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMStreamConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMStreamConfig {}
impl ::core::fmt::Debug for IAMStreamConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMStreamConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMStreamControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMStreamControl {}
impl ::core::fmt::Debug for IAMStreamControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMStreamControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMStreamSelect {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMStreamSelect {}
impl ::core::fmt::Debug for IAMStreamSelect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMStreamSelect").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTVAudio {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTVAudio {}
impl ::core::fmt::Debug for IAMTVAudio {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTVAudio").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTVAudioNotification {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTVAudioNotification {}
impl ::core::fmt::Debug for IAMTVAudioNotification {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTVAudioNotification").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTVTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTVTuner {}
impl ::core::fmt::Debug for IAMTVTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTVTuner").field(&self.0).finish()
    }
}
impl IAMTVTuner {
    pub unsafe fn put_Channel(&self, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.put_Channel)(::windows::core::Vtable::as_raw(self), lchannel, lvideosubchannel, laudiosubchannel).ok()
    }
    pub unsafe fn get_Channel(&self, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_Channel)(::windows::core::Vtable::as_raw(self), plchannel, plvideosubchannel, plaudiosubchannel).ok()
    }
    pub unsafe fn ChannelMinMax(&self, lchannelmin: *mut i32, lchannelmax: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ChannelMinMax)(::windows::core::Vtable::as_raw(self), lchannelmin, lchannelmax).ok()
    }
    pub unsafe fn SetCountryCode(&self, lcountrycode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCountryCode)(::windows::core::Vtable::as_raw(self), lcountrycode).ok()
    }
    pub unsafe fn CountryCode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CountryCode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetTuningSpace(&self, ltuningspace: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetTuningSpace)(::windows::core::Vtable::as_raw(self), ltuningspace).ok()
    }
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Logon<P0>(&self, hcurrentuser: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.Logon)(::windows::core::Vtable::as_raw(self), hcurrentuser.into()).ok()
    }
    pub unsafe fn Logout(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Logout)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SignalPresent(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SignalPresent)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMode(&self, lmode: AMTunerModeType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMode)(::windows::core::Vtable::as_raw(self), lmode).ok()
    }
    pub unsafe fn Mode(&self) -> ::windows::core::Result<AMTunerModeType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Mode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetAvailableModes(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetAvailableModes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn RegisterNotificationCallBack<P0>(&self, pnotify: P0, levents: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IAMTunerNotification>>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterNotificationCallBack)(::windows::core::Vtable::as_raw(self), pnotify.into().abi(), levents).ok()
    }
    pub unsafe fn UnRegisterNotificationCallBack<P0>(&self, pnotify: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IAMTunerNotification>>,
    {
        (::windows::core::Vtable::vtable(self).base__.UnRegisterNotificationCallBack)(::windows::core::Vtable::as_raw(self), pnotify.into().abi()).ok()
    }
}
impl ::core::cmp::PartialEq for IAMTimecodeDisplay {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTimecodeDisplay {}
impl ::core::fmt::Debug for IAMTimecodeDisplay {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTimecodeDisplay").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTimecodeGenerator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTimecodeGenerator {}
impl ::core::fmt::Debug for IAMTimecodeGenerator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTimecodeGenerator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTimecodeReader {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTimecodeReader {}
impl ::core::fmt::Debug for IAMTimecodeReader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTimecodeReader").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTuner {}
impl ::core::fmt::Debug for IAMTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTuner").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMTunerNotification {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMTunerNotification {}
impl ::core::fmt::Debug for IAMTunerNotification {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMTunerNotification").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVfwCaptureDialogs {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVfwCaptureDialogs {}
impl ::core::fmt::Debug for IAMVfwCaptureDialogs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVfwCaptureDialogs").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVfwCompressDialogs {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVfwCompressDialogs {}
impl ::core::fmt::Debug for IAMVfwCompressDialogs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVfwCompressDialogs").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVideoAccelerator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVideoAccelerator {}
impl ::core::fmt::Debug for IAMVideoAccelerator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVideoAccelerator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVideoAcceleratorNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVideoAcceleratorNotify {}
impl ::core::fmt::Debug for IAMVideoAcceleratorNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVideoAcceleratorNotify").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVideoCompression {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVideoCompression {}
impl ::core::fmt::Debug for IAMVideoCompression {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVideoCompression").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVideoControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVideoControl {}
impl ::core::fmt::Debug for IAMVideoControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVideoControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVideoDecimationProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVideoDecimationProperties {}
impl ::core::fmt::Debug for IAMVideoDecimationProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVideoDecimationProperties").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMVideoProcAmp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMVideoProcAmp {}
impl ::core::fmt::Debug for IAMVideoProcAmp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMVideoProcAmp").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMWMBufferPass {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMWMBufferPass {}
impl ::core::fmt::Debug for IAMWMBufferPass {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMWMBufferPass").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMWMBufferPassCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMWMBufferPassCallback {}
impl ::core::fmt::Debug for IAMWMBufferPassCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMWMBufferPassCallback").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMWstDecoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMWstDecoder {}
impl ::core::fmt::Debug for IAMWstDecoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMWstDecoder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAMovieSetup {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAMovieSetup {}
impl ::core::fmt::Debug for IAMovieSetup {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAMovieSetup").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IATSCChannelTuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IATSCChannelTuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IATSCChannelTuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSCChannelTuneRequest").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCChannelTuneRequest {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Components(&self) -> ::windows::core::Result<IComponents> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Components)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Locator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Locator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetLocator<P0>(&self, locator: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetLocator)(::windows::core::Vtable::as_raw(self), locator.into().abi()).ok()
    }
    pub unsafe fn Channel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Channel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetChannel(&self, channel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetChannel)(::windows::core::Vtable::as_raw(self), channel).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IATSCComponentType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IATSCComponentType {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IATSCComponentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSCComponentType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCComponentType {
    pub unsafe fn Category(&self) -> ::windows::core::Result<ComponentCategory> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCategory(&self, category: ComponentCategory) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetCategory)(::windows::core::Vtable::as_raw(self), category).ok()
    }
    pub unsafe fn MediaMajorType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaMajorType(&self, mediamajortype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetMediaMajorType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediamajortype)).ok()
    }
    pub unsafe fn _MediaMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaMajorType(&self, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Set_MediaMajorType)(::windows::core::Vtable::as_raw(self), mediamajortypeguid).ok()
    }
    pub unsafe fn MediaSubType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaSubType(&self, mediasubtype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetMediaSubType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediasubtype)).ok()
    }
    pub unsafe fn _MediaSubType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaSubType(&self, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Set_MediaSubType)(::windows::core::Vtable::as_raw(self), mediasubtypeguid).ok()
    }
    pub unsafe fn MediaFormatType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaFormatType(&self, mediaformattype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetMediaFormatType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediaformattype)).ok()
    }
    pub unsafe fn _MediaFormatType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaFormatType(&self, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Set_MediaFormatType)(::windows::core::Vtable::as_raw(self), mediaformattypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn MediaType(&self) -> ::windows::core::Result<super::MediaFoundation::AM_MEDIA_TYPE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.MediaType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn SetMediaType(&self, mediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetMediaType)(::windows::core::Vtable::as_raw(self), mediatype).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IComponentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn LangID(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.LangID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetLangID(&self, langid: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetLangID)(::windows::core::Vtable::as_raw(self), langid).ok()
    }
    pub unsafe fn StreamType(&self) -> ::windows::core::Result<MPEG2StreamType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.StreamType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetStreamType(&self, mp2streamtype: MPEG2StreamType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetStreamType)(::windows::core::Vtable::as_raw(self), mp2streamtype).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IATSCLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IATSCLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IATSCLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSCLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IATSCLocator2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IATSCLocator2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IATSCLocator2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSCLocator2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCLocator2 {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn PhysicalChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PhysicalChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPhysicalChannel(&self, physicalchannel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetPhysicalChannel)(::windows::core::Vtable::as_raw(self), physicalchannel).ok()
    }
    pub unsafe fn TSID(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetTSID(&self, tsid: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetTSID)(::windows::core::Vtable::as_raw(self), tsid).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IATSCTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IATSCTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IATSCTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSCTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IATSCTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn MinChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMinChannel(&self, newminchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMinChannel)(::windows::core::Vtable::as_raw(self), newminchannelval).ok()
    }
    pub unsafe fn MaxChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMaxChannel(&self, newmaxchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMaxChannel)(::windows::core::Vtable::as_raw(self), newmaxchannelval).ok()
    }
    pub unsafe fn InputType(&self) -> ::windows::core::Result<TunerInputType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.InputType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInputType(&self, newinputtypeval: TunerInputType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInputType)(::windows::core::Vtable::as_raw(self), newinputtypeval).ok()
    }
    pub unsafe fn CountryCode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CountryCode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCountryCode(&self, newcountrycodeval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCountryCode)(::windows::core::Vtable::as_raw(self), newcountrycodeval).ok()
    }
}
impl ::core::cmp::PartialEq for IATSC_EIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IATSC_EIT {}
impl ::core::fmt::Debug for IATSC_EIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSC_EIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IATSC_ETT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IATSC_ETT {}
impl ::core::fmt::Debug for IATSC_ETT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSC_ETT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IATSC_MGT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IATSC_MGT {}
impl ::core::fmt::Debug for IATSC_MGT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSC_MGT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IATSC_STT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IATSC_STT {}
impl ::core::fmt::Debug for IATSC_STT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSC_STT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IATSC_VCT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IATSC_VCT {}
impl ::core::fmt::Debug for IATSC_VCT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IATSC_VCT").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAnalogAudioComponentType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAnalogAudioComponentType {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAnalogAudioComponentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAnalogAudioComponentType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogAudioComponentType {
    pub unsafe fn Category(&self) -> ::windows::core::Result<ComponentCategory> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCategory(&self, category: ComponentCategory) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCategory)(::windows::core::Vtable::as_raw(self), category).ok()
    }
    pub unsafe fn MediaMajorType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaMajorType(&self, mediamajortype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaMajorType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediamajortype)).ok()
    }
    pub unsafe fn _MediaMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaMajorType(&self, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MediaMajorType)(::windows::core::Vtable::as_raw(self), mediamajortypeguid).ok()
    }
    pub unsafe fn MediaSubType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaSubType(&self, mediasubtype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaSubType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediasubtype)).ok()
    }
    pub unsafe fn _MediaSubType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaSubType(&self, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MediaSubType)(::windows::core::Vtable::as_raw(self), mediasubtypeguid).ok()
    }
    pub unsafe fn MediaFormatType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaFormatType(&self, mediaformattype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaFormatType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediaformattype)).ok()
    }
    pub unsafe fn _MediaFormatType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaFormatType(&self, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MediaFormatType)(::windows::core::Vtable::as_raw(self), mediaformattypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn MediaType(&self) -> ::windows::core::Result<super::MediaFoundation::AM_MEDIA_TYPE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn SetMediaType(&self, mediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaType)(::windows::core::Vtable::as_raw(self), mediatype).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IComponentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAnalogLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAnalogLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAnalogLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAnalogLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAnalogRadioTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAnalogRadioTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAnalogRadioTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAnalogRadioTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogRadioTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAnalogRadioTuningSpace2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAnalogRadioTuningSpace2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAnalogRadioTuningSpace2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAnalogRadioTuningSpace2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogRadioTuningSpace2 {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn MinFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMinFrequency(&self, newminfrequencyval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMinFrequency)(::windows::core::Vtable::as_raw(self), newminfrequencyval).ok()
    }
    pub unsafe fn MaxFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMaxFrequency(&self, newmaxfrequencyval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMaxFrequency)(::windows::core::Vtable::as_raw(self), newmaxfrequencyval).ok()
    }
    pub unsafe fn Step(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Step)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetStep(&self, newstepval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetStep)(::windows::core::Vtable::as_raw(self), newstepval).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAnalogTVTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAnalogTVTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAnalogTVTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAnalogTVTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAnalogTVTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IAsyncReader {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAsyncReader {}
impl ::core::fmt::Debug for IAsyncReader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAsyncReader").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAtscContentAdvisoryDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAtscContentAdvisoryDescriptor {}
impl ::core::fmt::Debug for IAtscContentAdvisoryDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAtscContentAdvisoryDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAtscPsipParser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAtscPsipParser {}
impl ::core::fmt::Debug for IAtscPsipParser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAtscPsipParser").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAttributeGet {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAttributeGet {}
impl ::core::fmt::Debug for IAttributeGet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAttributeGet").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAttributeSet {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAttributeSet {}
impl ::core::fmt::Debug for IAttributeSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAttributeSet").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IAudioData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAudioData {}
impl ::core::fmt::Debug for IAudioData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAudioData").field(&self.0).finish()
    }
}
impl IAudioData {
    pub unsafe fn SetBuffer(&self, cbsize: u32, pbdata: *const u8, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetBuffer)(::windows::core::Vtable::as_raw(self), cbsize, pbdata, dwflags).ok()
    }
    pub unsafe fn GetInfo(&self, pdwlength: *mut u32, ppbdata: *mut *mut u8, pcbactualdata: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetInfo)(::windows::core::Vtable::as_raw(self), pdwlength, ppbdata, pcbactualdata).ok()
    }
    pub unsafe fn SetActual(&self, cbdatavalid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetActual)(::windows::core::Vtable::as_raw(self), cbdatavalid).ok()
    }
}
impl ::core::cmp::PartialEq for IAudioMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAudioMediaStream {}
impl ::core::fmt::Debug for IAudioMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAudioMediaStream").field(&self.0).finish()
    }
}
impl IAudioMediaStream {
    pub unsafe fn GetMultiMediaStream(&self) -> ::windows::core::Result<IMultiMediaStream> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMultiMediaStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetInformation(&self, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetInformation)(::windows::core::Vtable::as_raw(self), ppurposeid, ptype).ok()
    }
    pub unsafe fn SetSameFormat<P0>(&self, pstreamthathasdesiredformat: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMediaStream>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSameFormat)(::windows::core::Vtable::as_raw(self), pstreamthathasdesiredformat.into().abi(), dwflags).ok()
    }
    pub unsafe fn AllocateSample(&self, dwflags: u32) -> ::windows::core::Result<IStreamSample> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AllocateSample)(::windows::core::Vtable::as_raw(self), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CreateSharedSample<P0>(&self, pexistingsample: P0, dwflags: u32) -> ::windows::core::Result<IStreamSample>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IStreamSample>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateSharedSample)(::windows::core::Vtable::as_raw(self), pexistingsample.into().abi(), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SendEndOfStream(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SendEndOfStream)(::windows::core::Vtable::as_raw(self), dwflags).ok()
    }
}
impl ::core::cmp::PartialEq for IAudioStreamSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAudioStreamSample {}
impl ::core::fmt::Debug for IAudioStreamSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAudioStreamSample").field(&self.0).finish()
    }
}
impl IAudioStreamSample {
    pub unsafe fn GetMediaStream(&self, ppmediastream: *const ::core::option::Option<IMediaStream>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetMediaStream)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(ppmediastream)).ok()
    }
    pub unsafe fn GetSampleTimes(&self, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetSampleTimes)(::windows::core::Vtable::as_raw(self), pstarttime, pendtime, pcurrenttime).ok()
    }
    pub unsafe fn SetSampleTimes(&self, pstarttime: *const i64, pendtime: *const i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSampleTimes)(::windows::core::Vtable::as_raw(self), pstarttime, pendtime).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Update<P0>(&self, dwflags: u32, hevent: P0, pfnapc: super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.Update)(::windows::core::Vtable::as_raw(self), dwflags, hevent.into(), pfnapc, dwapcdata).ok()
    }
    pub unsafe fn CompletionStatus(&self, dwflags: u32, dwmilliseconds: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CompletionStatus)(::windows::core::Vtable::as_raw(self), dwflags, dwmilliseconds).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAuxInTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAuxInTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAuxInTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAuxInTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAuxInTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IAuxInTuningSpace2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IAuxInTuningSpace2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IAuxInTuningSpace2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAuxInTuningSpace2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IAuxInTuningSpace2 {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IBDAComparable {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDAComparable {}
impl ::core::fmt::Debug for IBDAComparable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDAComparable").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDACreateTuneRequestEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDACreateTuneRequestEx {}
impl ::core::fmt::Debug for IBDACreateTuneRequestEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDACreateTuneRequestEx").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_AUX {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_AUX {}
impl ::core::fmt::Debug for IBDA_AUX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_AUX").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_AutoDemodulate {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_AutoDemodulate {}
impl ::core::fmt::Debug for IBDA_AutoDemodulate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_AutoDemodulate").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_AutoDemodulateEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_AutoDemodulateEx {}
impl ::core::fmt::Debug for IBDA_AutoDemodulateEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_AutoDemodulateEx").field(&self.0).finish()
    }
}
impl IBDA_AutoDemodulateEx {
    pub unsafe fn put_AutoDemodulate(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.put_AutoDemodulate)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IBDA_ConditionalAccess {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_ConditionalAccess {}
impl ::core::fmt::Debug for IBDA_ConditionalAccess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_ConditionalAccess").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_ConditionalAccessEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_ConditionalAccessEx {}
impl ::core::fmt::Debug for IBDA_ConditionalAccessEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_ConditionalAccessEx").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_DRIDRMService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DRIDRMService {}
impl ::core::fmt::Debug for IBDA_DRIDRMService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DRIDRMService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_DRIWMDRMSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DRIWMDRMSession {}
impl ::core::fmt::Debug for IBDA_DRIWMDRMSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DRIWMDRMSession").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_DRM {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DRM {}
impl ::core::fmt::Debug for IBDA_DRM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DRM").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_DRMService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DRMService {}
impl ::core::fmt::Debug for IBDA_DRMService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DRMService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_DeviceControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DeviceControl {}
impl ::core::fmt::Debug for IBDA_DeviceControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DeviceControl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::core::cmp::PartialEq for IBDA_DiagnosticProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::core::cmp::Eq for IBDA_DiagnosticProperties {}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::core::fmt::Debug for IBDA_DiagnosticProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DiagnosticProperties").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl IBDA_DiagnosticProperties {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
    pub unsafe fn Read<P0, P1>(&self, pszpropname: P0, pvar: *mut super::super::System::Com::VARIANT, perrorlog: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<super::super::System::Com::IErrorLog>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Read)(::windows::core::Vtable::as_raw(self), pszpropname.into().abi(), pvar, perrorlog.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
    pub unsafe fn Write<P0>(&self, pszpropname: P0, pvar: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Write)(::windows::core::Vtable::as_raw(self), pszpropname.into().abi(), pvar).ok()
    }
}
impl ::core::cmp::PartialEq for IBDA_DigitalDemodulator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DigitalDemodulator {}
impl ::core::fmt::Debug for IBDA_DigitalDemodulator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DigitalDemodulator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_DigitalDemodulator2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DigitalDemodulator2 {}
impl ::core::fmt::Debug for IBDA_DigitalDemodulator2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DigitalDemodulator2").field(&self.0).finish()
    }
}
impl IBDA_DigitalDemodulator2 {
    pub unsafe fn SetModulationType(&self, pmodulationtype: *const ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetModulationType)(::windows::core::Vtable::as_raw(self), pmodulationtype).ok()
    }
    pub unsafe fn ModulationType(&self, pmodulationtype: *mut ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ModulationType)(::windows::core::Vtable::as_raw(self), pmodulationtype).ok()
    }
    pub unsafe fn SetInnerFECMethod(&self, pfecmethod: *const FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInnerFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn InnerFECMethod(&self, pfecmethod: *mut FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.InnerFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn SetInnerFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn InnerFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn SetOuterFECMethod(&self, pfecmethod: *const FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOuterFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn OuterFECMethod(&self, pfecmethod: *mut FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OuterFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn SetOuterFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn OuterFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn SetSymbolRate(&self, psymbolrate: *const u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), psymbolrate).ok()
    }
    pub unsafe fn SymbolRate(&self, psymbolrate: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SymbolRate)(::windows::core::Vtable::as_raw(self), psymbolrate).ok()
    }
    pub unsafe fn SetSpectralInversion(&self, pspectralinversion: *const SpectralInversion) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSpectralInversion)(::windows::core::Vtable::as_raw(self), pspectralinversion).ok()
    }
    pub unsafe fn SpectralInversion(&self, pspectralinversion: *mut SpectralInversion) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SpectralInversion)(::windows::core::Vtable::as_raw(self), pspectralinversion).ok()
    }
}
impl ::core::cmp::PartialEq for IBDA_DigitalDemodulator3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DigitalDemodulator3 {}
impl ::core::fmt::Debug for IBDA_DigitalDemodulator3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DigitalDemodulator3").field(&self.0).finish()
    }
}
impl IBDA_DigitalDemodulator3 {
    pub unsafe fn SetModulationType(&self, pmodulationtype: *const ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetModulationType)(::windows::core::Vtable::as_raw(self), pmodulationtype).ok()
    }
    pub unsafe fn ModulationType(&self, pmodulationtype: *mut ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.ModulationType)(::windows::core::Vtable::as_raw(self), pmodulationtype).ok()
    }
    pub unsafe fn SetInnerFECMethod(&self, pfecmethod: *const FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn InnerFECMethod(&self, pfecmethod: *mut FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn SetInnerFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn InnerFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn SetOuterFECMethod(&self, pfecmethod: *const FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn OuterFECMethod(&self, pfecmethod: *mut FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFECMethod)(::windows::core::Vtable::as_raw(self), pfecmethod).ok()
    }
    pub unsafe fn SetOuterFECRate(&self, pfecrate: *const BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn OuterFECRate(&self, pfecrate: *mut BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), pfecrate).ok()
    }
    pub unsafe fn SetSymbolRate(&self, psymbolrate: *const u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), psymbolrate).ok()
    }
    pub unsafe fn SymbolRate(&self, psymbolrate: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), psymbolrate).ok()
    }
    pub unsafe fn SetSpectralInversion(&self, pspectralinversion: *const SpectralInversion) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSpectralInversion)(::windows::core::Vtable::as_raw(self), pspectralinversion).ok()
    }
    pub unsafe fn SpectralInversion(&self, pspectralinversion: *mut SpectralInversion) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SpectralInversion)(::windows::core::Vtable::as_raw(self), pspectralinversion).ok()
    }
    pub unsafe fn SetGuardInterval(&self, pguardinterval: *const GuardInterval) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetGuardInterval)(::windows::core::Vtable::as_raw(self), pguardinterval).ok()
    }
    pub unsafe fn GuardInterval(&self, pguardinterval: *mut GuardInterval) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GuardInterval)(::windows::core::Vtable::as_raw(self), pguardinterval).ok()
    }
    pub unsafe fn SetTransmissionMode(&self, ptransmissionmode: *const TransmissionMode) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetTransmissionMode)(::windows::core::Vtable::as_raw(self), ptransmissionmode).ok()
    }
    pub unsafe fn TransmissionMode(&self, ptransmissionmode: *mut TransmissionMode) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.TransmissionMode)(::windows::core::Vtable::as_raw(self), ptransmissionmode).ok()
    }
    pub unsafe fn SetRollOff(&self, prolloff: *const RollOff) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetRollOff)(::windows::core::Vtable::as_raw(self), prolloff).ok()
    }
    pub unsafe fn RollOff(&self, prolloff: *mut RollOff) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RollOff)(::windows::core::Vtable::as_raw(self), prolloff).ok()
    }
    pub unsafe fn SetPilot(&self, ppilot: *const Pilot) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetPilot)(::windows::core::Vtable::as_raw(self), ppilot).ok()
    }
    pub unsafe fn Pilot(&self, ppilot: *mut Pilot) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Pilot)(::windows::core::Vtable::as_raw(self), ppilot).ok()
    }
}
impl ::core::cmp::PartialEq for IBDA_DiseqCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_DiseqCommand {}
impl ::core::fmt::Debug for IBDA_DiseqCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_DiseqCommand").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_EasMessage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_EasMessage {}
impl ::core::fmt::Debug for IBDA_EasMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_EasMessage").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_Encoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_Encoder {}
impl ::core::fmt::Debug for IBDA_Encoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_Encoder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_EthernetFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_EthernetFilter {}
impl ::core::fmt::Debug for IBDA_EthernetFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_EthernetFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_EventingService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_EventingService {}
impl ::core::fmt::Debug for IBDA_EventingService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_EventingService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_FDC {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_FDC {}
impl ::core::fmt::Debug for IBDA_FDC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_FDC").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_FrequencyFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_FrequencyFilter {}
impl ::core::fmt::Debug for IBDA_FrequencyFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_FrequencyFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_GuideDataDeliveryService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_GuideDataDeliveryService {}
impl ::core::fmt::Debug for IBDA_GuideDataDeliveryService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_GuideDataDeliveryService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_IPSinkControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_IPSinkControl {}
impl ::core::fmt::Debug for IBDA_IPSinkControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_IPSinkControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_IPSinkInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_IPSinkInfo {}
impl ::core::fmt::Debug for IBDA_IPSinkInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_IPSinkInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_IPV4Filter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_IPV4Filter {}
impl ::core::fmt::Debug for IBDA_IPV4Filter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_IPV4Filter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_IPV6Filter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_IPV6Filter {}
impl ::core::fmt::Debug for IBDA_IPV6Filter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_IPV6Filter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_ISDBConditionalAccess {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_ISDBConditionalAccess {}
impl ::core::fmt::Debug for IBDA_ISDBConditionalAccess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_ISDBConditionalAccess").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_LNBInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_LNBInfo {}
impl ::core::fmt::Debug for IBDA_LNBInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_LNBInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_MUX {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_MUX {}
impl ::core::fmt::Debug for IBDA_MUX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_MUX").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_NameValueService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_NameValueService {}
impl ::core::fmt::Debug for IBDA_NameValueService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_NameValueService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_NetworkProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_NetworkProvider {}
impl ::core::fmt::Debug for IBDA_NetworkProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_NetworkProvider").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_NullTransform {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_NullTransform {}
impl ::core::fmt::Debug for IBDA_NullTransform {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_NullTransform").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_PinControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_PinControl {}
impl ::core::fmt::Debug for IBDA_PinControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_PinControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_SignalProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_SignalProperties {}
impl ::core::fmt::Debug for IBDA_SignalProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_SignalProperties").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_SignalStatistics {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_SignalStatistics {}
impl ::core::fmt::Debug for IBDA_SignalStatistics {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_SignalStatistics").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_TIF_REGISTRATION {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_TIF_REGISTRATION {}
impl ::core::fmt::Debug for IBDA_TIF_REGISTRATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_TIF_REGISTRATION").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_Topology {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_Topology {}
impl ::core::fmt::Debug for IBDA_Topology {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_Topology").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_TransportStreamInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_TransportStreamInfo {}
impl ::core::fmt::Debug for IBDA_TransportStreamInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_TransportStreamInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_TransportStreamSelector {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_TransportStreamSelector {}
impl ::core::fmt::Debug for IBDA_TransportStreamSelector {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_TransportStreamSelector").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_UserActivityService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_UserActivityService {}
impl ::core::fmt::Debug for IBDA_UserActivityService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_UserActivityService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_VoidTransform {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_VoidTransform {}
impl ::core::fmt::Debug for IBDA_VoidTransform {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_VoidTransform").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_WMDRMSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_WMDRMSession {}
impl ::core::fmt::Debug for IBDA_WMDRMSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_WMDRMSession").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBDA_WMDRMTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBDA_WMDRMTuner {}
impl ::core::fmt::Debug for IBDA_WMDRMTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBDA_WMDRMTuner").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBPCSatelliteTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBPCSatelliteTuner {}
impl ::core::fmt::Debug for IBPCSatelliteTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBPCSatelliteTuner").field(&self.0).finish()
    }
}
impl IBPCSatelliteTuner {
    pub unsafe fn put_Channel(&self, lchannel: i32, lvideosubchannel: i32, laudiosubchannel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.put_Channel)(::windows::core::Vtable::as_raw(self), lchannel, lvideosubchannel, laudiosubchannel).ok()
    }
    pub unsafe fn get_Channel(&self, plchannel: *mut i32, plvideosubchannel: *mut i32, plaudiosubchannel: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.get_Channel)(::windows::core::Vtable::as_raw(self), plchannel, plvideosubchannel, plaudiosubchannel).ok()
    }
    pub unsafe fn ChannelMinMax(&self, lchannelmin: *mut i32, lchannelmax: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ChannelMinMax)(::windows::core::Vtable::as_raw(self), lchannelmin, lchannelmax).ok()
    }
    pub unsafe fn SetCountryCode(&self, lcountrycode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCountryCode)(::windows::core::Vtable::as_raw(self), lcountrycode).ok()
    }
    pub unsafe fn CountryCode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CountryCode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetTuningSpace(&self, ltuningspace: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetTuningSpace)(::windows::core::Vtable::as_raw(self), ltuningspace).ok()
    }
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Logon<P0>(&self, hcurrentuser: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.Logon)(::windows::core::Vtable::as_raw(self), hcurrentuser.into()).ok()
    }
    pub unsafe fn Logout(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Logout)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SignalPresent(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SignalPresent)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMode(&self, lmode: AMTunerModeType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMode)(::windows::core::Vtable::as_raw(self), lmode).ok()
    }
    pub unsafe fn Mode(&self) -> ::windows::core::Result<AMTunerModeType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Mode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetAvailableModes(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetAvailableModes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn RegisterNotificationCallBack<P0>(&self, pnotify: P0, levents: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IAMTunerNotification>>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterNotificationCallBack)(::windows::core::Vtable::as_raw(self), pnotify.into().abi(), levents).ok()
    }
    pub unsafe fn UnRegisterNotificationCallBack<P0>(&self, pnotify: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IAMTunerNotification>>,
    {
        (::windows::core::Vtable::vtable(self).base__.UnRegisterNotificationCallBack)(::windows::core::Vtable::as_raw(self), pnotify.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IBaseFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IBaseFilter {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IBaseFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBaseFilter").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IBaseFilter {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Run(&self, tstart: i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Run)(::windows::core::Vtable::as_raw(self), tstart).ok()
    }
    pub unsafe fn GetState(&self, dwmillisecstimeout: u32) -> ::windows::core::Result<FILTER_STATE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetState)(::windows::core::Vtable::as_raw(self), dwmillisecstimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSyncSource<P0>(&self, pclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::IReferenceClock>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSyncSource)(::windows::core::Vtable::as_raw(self), pclock.into().abi()).ok()
    }
    pub unsafe fn GetSyncSource(&self) -> ::windows::core::Result<super::IReferenceClock> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetSyncSource)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IBaseVideoMixer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBaseVideoMixer {}
impl ::core::fmt::Debug for IBaseVideoMixer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBaseVideoMixer").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IBasicAudio {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IBasicAudio {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IBasicAudio {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBasicAudio").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IBasicVideo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IBasicVideo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IBasicVideo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBasicVideo").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IBasicVideo2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IBasicVideo2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IBasicVideo2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBasicVideo2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IBasicVideo2 {
    pub unsafe fn AvgTimePerFrame(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AvgTimePerFrame)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn BitRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.BitRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn BitErrorRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.BitErrorRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn VideoWidth(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.VideoWidth)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn VideoHeight(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.VideoHeight)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceLeft(&self, sourceleft: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceLeft)(::windows::core::Vtable::as_raw(self), sourceleft).ok()
    }
    pub unsafe fn SourceLeft(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceLeft)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceWidth(&self, sourcewidth: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceWidth)(::windows::core::Vtable::as_raw(self), sourcewidth).ok()
    }
    pub unsafe fn SourceWidth(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceWidth)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceTop(&self, sourcetop: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceTop)(::windows::core::Vtable::as_raw(self), sourcetop).ok()
    }
    pub unsafe fn SourceTop(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceTop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceHeight(&self, sourceheight: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceHeight)(::windows::core::Vtable::as_raw(self), sourceheight).ok()
    }
    pub unsafe fn SourceHeight(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceHeight)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDestinationLeft(&self, destinationleft: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDestinationLeft)(::windows::core::Vtable::as_raw(self), destinationleft).ok()
    }
    pub unsafe fn DestinationLeft(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DestinationLeft)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDestinationWidth(&self, destinationwidth: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDestinationWidth)(::windows::core::Vtable::as_raw(self), destinationwidth).ok()
    }
    pub unsafe fn DestinationWidth(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DestinationWidth)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDestinationTop(&self, destinationtop: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDestinationTop)(::windows::core::Vtable::as_raw(self), destinationtop).ok()
    }
    pub unsafe fn DestinationTop(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DestinationTop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDestinationHeight(&self, destinationheight: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDestinationHeight)(::windows::core::Vtable::as_raw(self), destinationheight).ok()
    }
    pub unsafe fn DestinationHeight(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DestinationHeight)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourcePosition(&self, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourcePosition)(::windows::core::Vtable::as_raw(self), left, top, width, height).ok()
    }
    pub unsafe fn GetSourcePosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetSourcePosition)(::windows::core::Vtable::as_raw(self), pleft, ptop, pwidth, pheight).ok()
    }
    pub unsafe fn SetDefaultSourcePosition(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultSourcePosition)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SetDestinationPosition(&self, left: i32, top: i32, width: i32, height: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDestinationPosition)(::windows::core::Vtable::as_raw(self), left, top, width, height).ok()
    }
    pub unsafe fn GetDestinationPosition(&self, pleft: *mut i32, ptop: *mut i32, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetDestinationPosition)(::windows::core::Vtable::as_raw(self), pleft, ptop, pwidth, pheight).ok()
    }
    pub unsafe fn SetDefaultDestinationPosition(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultDestinationPosition)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn GetVideoSize(&self, pwidth: *mut i32, pheight: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetVideoSize)(::windows::core::Vtable::as_raw(self), pwidth, pheight).ok()
    }
    pub unsafe fn GetVideoPaletteEntries(&self, startindex: i32, entries: i32, pretrieved: *mut i32, ppalette: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetVideoPaletteEntries)(::windows::core::Vtable::as_raw(self), startindex, entries, pretrieved, ppalette).ok()
    }
    pub unsafe fn GetCurrentImage(&self, pbuffersize: *mut i32, pdibimage: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetCurrentImage)(::windows::core::Vtable::as_raw(self), pbuffersize, pdibimage).ok()
    }
    pub unsafe fn IsUsingDefaultSource(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsUsingDefaultSource)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn IsUsingDefaultDestination(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsUsingDefaultDestination)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IBroadcastEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBroadcastEvent {}
impl ::core::fmt::Debug for IBroadcastEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBroadcastEvent").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IBroadcastEventEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBroadcastEventEx {}
impl ::core::fmt::Debug for IBroadcastEventEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBroadcastEventEx").field(&self.0).finish()
    }
}
impl IBroadcastEventEx {
    pub unsafe fn Fire(&self, eventid: ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Fire)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(eventid)).ok()
    }
}
impl ::core::cmp::PartialEq for IBufferingTime {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBufferingTime {}
impl ::core::fmt::Debug for IBufferingTime {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBufferingTime").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICAT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICAT {}
impl ::core::fmt::Debug for ICAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICAT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICCSubStreamFiltering {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICCSubStreamFiltering {}
impl ::core::fmt::Debug for ICCSubStreamFiltering {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICCSubStreamFiltering").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICameraControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICameraControl {}
impl ::core::fmt::Debug for ICameraControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICameraControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICaptionServiceDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICaptionServiceDescriptor {}
impl ::core::fmt::Debug for ICaptionServiceDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICaptionServiceDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICaptureGraphBuilder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICaptureGraphBuilder {}
impl ::core::fmt::Debug for ICaptureGraphBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICaptureGraphBuilder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICaptureGraphBuilder2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICaptureGraphBuilder2 {}
impl ::core::fmt::Debug for ICaptureGraphBuilder2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICaptureGraphBuilder2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IChannelIDTuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IChannelIDTuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IChannelIDTuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IChannelIDTuneRequest").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IChannelIDTuneRequest {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Components(&self) -> ::windows::core::Result<IComponents> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Components)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Locator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Locator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetLocator<P0>(&self, locator: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetLocator)(::windows::core::Vtable::as_raw(self), locator.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IChannelTuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IChannelTuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IChannelTuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IChannelTuneRequest").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IChannelTuneRequest {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Components(&self) -> ::windows::core::Result<IComponents> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Components)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Locator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Locator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetLocator<P0>(&self, locator: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetLocator)(::windows::core::Vtable::as_raw(self), locator.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IComponent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IComponent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IComponent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IComponent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IComponentType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IComponentType {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IComponentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IComponentType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IComponentTypes {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IComponentTypes {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IComponentTypes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IComponentTypes").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IComponents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IComponents {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IComponents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IComponents").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IComponentsOld {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IComponentsOld {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IComponentsOld {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IComponentsOld").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IConfigAsfWriter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IConfigAsfWriter {}
impl ::core::fmt::Debug for IConfigAsfWriter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IConfigAsfWriter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IConfigAsfWriter2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IConfigAsfWriter2 {}
impl ::core::fmt::Debug for IConfigAsfWriter2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IConfigAsfWriter2").field(&self.0).finish()
    }
}
impl IConfigAsfWriter2 {
    pub unsafe fn ConfigureFilterUsingProfileId(&self, dwprofileid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ConfigureFilterUsingProfileId)(::windows::core::Vtable::as_raw(self), dwprofileid).ok()
    }
    pub unsafe fn GetCurrentProfileId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCurrentProfileId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ConfigureFilterUsingProfileGuid(&self, guidprofile: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ConfigureFilterUsingProfileGuid)(::windows::core::Vtable::as_raw(self), guidprofile).ok()
    }
    pub unsafe fn GetCurrentProfileGuid(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCurrentProfileGuid)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Media_WindowsMediaFormat\"`*"]
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn ConfigureFilterUsingProfile<P0>(&self, pprofile: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::WindowsMediaFormat::IWMProfile>>,
    {
        (::windows::core::Vtable::vtable(self).base__.ConfigureFilterUsingProfile)(::windows::core::Vtable::as_raw(self), pprofile.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Media_WindowsMediaFormat\"`*"]
    #[cfg(feature = "Win32_Media_WindowsMediaFormat")]
    pub unsafe fn GetCurrentProfile(&self) -> ::windows::core::Result<super::WindowsMediaFormat::IWMProfile> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCurrentProfile)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetIndexMode<P0>(&self, bindexfile: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetIndexMode)(::windows::core::Vtable::as_raw(self), bindexfile.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetIndexMode(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetIndexMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IConfigAviMux {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IConfigAviMux {}
impl ::core::fmt::Debug for IConfigAviMux {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IConfigAviMux").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IConfigInterleaving {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IConfigInterleaving {}
impl ::core::fmt::Debug for IConfigInterleaving {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IConfigInterleaving").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICreateDevEnum {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICreateDevEnum {}
impl ::core::fmt::Debug for ICreateDevEnum {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICreateDevEnum").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ICreatePropBagOnRegKey {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICreatePropBagOnRegKey {}
impl ::core::fmt::Debug for ICreatePropBagOnRegKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICreatePropBagOnRegKey").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDDrawExclModeVideo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDDrawExclModeVideo {}
impl ::core::fmt::Debug for IDDrawExclModeVideo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDDrawExclModeVideo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDDrawExclModeVideoCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDDrawExclModeVideoCallback {}
impl ::core::fmt::Debug for IDDrawExclModeVideoCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDDrawExclModeVideoCallback").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDMOWrapperFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDMOWrapperFilter {}
impl ::core::fmt::Debug for IDMOWrapperFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDMOWrapperFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDShowPlugin {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDShowPlugin {}
impl ::core::fmt::Debug for IDShowPlugin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDShowPlugin").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDTFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDTFilter {}
impl ::core::fmt::Debug for IDTFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDTFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDTFilter2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDTFilter2 {}
impl ::core::fmt::Debug for IDTFilter2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDTFilter2").field(&self.0).finish()
    }
}
impl IDTFilter2 {
    pub unsafe fn EvalRatObjOK(&self) -> ::windows::core::Result<::windows::core::HRESULT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EvalRatObjOK)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCurrRating(&self, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetCurrRating)(::windows::core::Vtable::as_raw(self), pensystem, penrating, plbfenattr).ok()
    }
    pub unsafe fn get_BlockedRatingAttributes(&self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_BlockedRatingAttributes)(::windows::core::Vtable::as_raw(self), ensystem, enlevel, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn put_BlockedRatingAttributes(&self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.put_BlockedRatingAttributes)(::windows::core::Vtable::as_raw(self), ensystem, enlevel, lbfattrs).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn BlockUnRated(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.BlockUnRated)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetBlockUnRated<P0>(&self, fblockunratedshows: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetBlockUnRated)(::windows::core::Vtable::as_raw(self), fblockunratedshows.into()).ok()
    }
    pub unsafe fn BlockUnRatedDelay(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.BlockUnRatedDelay)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetBlockUnRatedDelay(&self, msecsdelaybeforeblock: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetBlockUnRatedDelay)(::windows::core::Vtable::as_raw(self), msecsdelaybeforeblock).ok()
    }
}
impl ::core::cmp::PartialEq for IDTFilter3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDTFilter3 {}
impl ::core::fmt::Debug for IDTFilter3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDTFilter3").field(&self.0).finish()
    }
}
impl IDTFilter3 {
    pub unsafe fn EvalRatObjOK(&self) -> ::windows::core::Result<::windows::core::HRESULT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EvalRatObjOK)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCurrRating(&self, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, plbfenattr: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.GetCurrRating)(::windows::core::Vtable::as_raw(self), pensystem, penrating, plbfenattr).ok()
    }
    pub unsafe fn get_BlockedRatingAttributes(&self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_BlockedRatingAttributes)(::windows::core::Vtable::as_raw(self), ensystem, enlevel, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn put_BlockedRatingAttributes(&self, ensystem: EnTvRat_System, enlevel: EnTvRat_GenericLevel, lbfattrs: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.put_BlockedRatingAttributes)(::windows::core::Vtable::as_raw(self), ensystem, enlevel, lbfattrs).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn BlockUnRated(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.BlockUnRated)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetBlockUnRated<P0>(&self, fblockunratedshows: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetBlockUnRated)(::windows::core::Vtable::as_raw(self), fblockunratedshows.into()).ok()
    }
    pub unsafe fn BlockUnRatedDelay(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.BlockUnRatedDelay)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetBlockUnRatedDelay(&self, msecsdelaybeforeblock: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetBlockUnRatedDelay)(::windows::core::Vtable::as_raw(self), msecsdelaybeforeblock).ok()
    }
    pub unsafe fn ChallengeUrl(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ChallengeUrl)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCurrLicenseExpDate(&self, prottype: *const ProtType) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCurrLicenseExpDate)(::windows::core::Vtable::as_raw(self), prottype, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLastErrorCode(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetLastErrorCode)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IDTFilterConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDTFilterConfig {}
impl ::core::fmt::Debug for IDTFilterConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDTFilterConfig").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDTFilterEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDTFilterEvents {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDTFilterEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDTFilterEvents").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDTFilterLicenseRenewal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDTFilterLicenseRenewal {}
impl ::core::fmt::Debug for IDTFilterLicenseRenewal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDTFilterLicenseRenewal").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBCLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBCLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBCLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBCLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBCLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBSLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBSLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBSLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBSLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBSLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBSLocator2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBSLocator2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBSLocator2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBSLocator2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBSLocator2 {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SignalPolarisation(&self) -> ::windows::core::Result<Polarisation> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SignalPolarisation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSignalPolarisation(&self, polarisationval: Polarisation) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSignalPolarisation)(::windows::core::Vtable::as_raw(self), polarisationval).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn WestPosition(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.WestPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetWestPosition<P0>(&self, westlongitude: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetWestPosition)(::windows::core::Vtable::as_raw(self), westlongitude.into()).ok()
    }
    pub unsafe fn OrbitalPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OrbitalPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOrbitalPosition(&self, longitude: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOrbitalPosition)(::windows::core::Vtable::as_raw(self), longitude).ok()
    }
    pub unsafe fn Azimuth(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Azimuth)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetAzimuth(&self, azimuth: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetAzimuth)(::windows::core::Vtable::as_raw(self), azimuth).ok()
    }
    pub unsafe fn Elevation(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Elevation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetElevation(&self, elevation: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetElevation)(::windows::core::Vtable::as_raw(self), elevation).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBSTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBSTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBSTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBSTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBSTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SystemType(&self) -> ::windows::core::Result<DVBSystemType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SystemType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSystemType(&self, systype: DVBSystemType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSystemType)(::windows::core::Vtable::as_raw(self), systype).ok()
    }
    pub unsafe fn NetworkID(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.NetworkID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkID(&self, networkid: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetNetworkID)(::windows::core::Vtable::as_raw(self), networkid).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBTLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBTLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBTLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBTLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBTLocator2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBTLocator2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBTLocator2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBTLocator2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTLocator2 {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Bandwidth(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Bandwidth)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetBandwidth(&self, bandwidthval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetBandwidth)(::windows::core::Vtable::as_raw(self), bandwidthval).ok()
    }
    pub unsafe fn LPInnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.LPInnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetLPInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetLPInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn LPInnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.LPInnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetLPInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetLPInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn HAlpha(&self) -> ::windows::core::Result<HierarchyAlpha> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.HAlpha)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetHAlpha(&self, alpha: HierarchyAlpha) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetHAlpha)(::windows::core::Vtable::as_raw(self), alpha).ok()
    }
    pub unsafe fn Guard(&self) -> ::windows::core::Result<GuardInterval> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Guard)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetGuard(&self, gi: GuardInterval) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetGuard)(::windows::core::Vtable::as_raw(self), gi).ok()
    }
    pub unsafe fn Mode(&self) -> ::windows::core::Result<TransmissionMode> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Mode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMode(&self, mode: TransmissionMode) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMode)(::windows::core::Vtable::as_raw(self), mode).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OtherFrequencyInUse(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OtherFrequencyInUse)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetOtherFrequencyInUse<P0>(&self, otherfrequencyinuseval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetOtherFrequencyInUse)(::windows::core::Vtable::as_raw(self), otherfrequencyinuseval.into()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBTuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBTuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBTuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBTuneRequest").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTuneRequest {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Components(&self) -> ::windows::core::Result<IComponents> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Components)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Locator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Locator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetLocator<P0>(&self, locator: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetLocator)(::windows::core::Vtable::as_raw(self), locator.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDVBTuningSpace2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDVBTuningSpace2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDVBTuningSpace2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVBTuningSpace2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDVBTuningSpace2 {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SystemType(&self) -> ::windows::core::Result<DVBSystemType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SystemType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSystemType(&self, systype: DVBSystemType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSystemType)(::windows::core::Vtable::as_raw(self), systype).ok()
    }
}
impl ::core::cmp::PartialEq for IDVB_BAT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_BAT {}
impl ::core::fmt::Debug for IDVB_BAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_BAT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_DIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_DIT {}
impl ::core::fmt::Debug for IDVB_DIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_DIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_EIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_EIT {}
impl ::core::fmt::Debug for IDVB_EIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_EIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_EIT2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_EIT2 {}
impl ::core::fmt::Debug for IDVB_EIT2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_EIT2").field(&self.0).finish()
    }
}
impl IDVB_EIT2 {
    pub unsafe fn Initialize<P0, P1>(&self, psectionlist: P0, pmpegdata: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ISectionList>>,
        P1: ::std::convert::Into<::windows::core::InParam<IMpeg2Data>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Initialize)(::windows::core::Vtable::as_raw(self), psectionlist.into().abi(), pmpegdata.into().abi()).ok()
    }
    pub unsafe fn GetVersionNumber(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetVersionNumber)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetServiceId(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetServiceId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTransportStreamId(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTransportStreamId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetOriginalNetworkId(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetOriginalNetworkId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetSegmentLastSectionNumber(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetSegmentLastSectionNumber)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLastTableId(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetLastTableId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCountOfRecords(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCountOfRecords)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordEventId(&self, dwrecordindex: u32) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordEventId)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordStartTime(&self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_DATE_AND_TIME> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordStartTime)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordDuration(&self, dwrecordindex: u32) -> ::windows::core::Result<MPEG_TIME> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordDuration)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordRunningStatus(&self, dwrecordindex: u32) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordRunningStatus)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRecordFreeCAMode(&self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordFreeCAMode)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordCountOfDescriptors(&self, dwrecordindex: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordCountOfDescriptors)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordDescriptorByIndex(&self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordDescriptorByIndex)(::windows::core::Vtable::as_raw(self), dwrecordindex, dwindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordDescriptorByTag(&self, dwrecordindex: u32, btag: u8, pdwcookie: ::core::option::Option<*mut u32>, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetRecordDescriptorByTag)(::windows::core::Vtable::as_raw(self), dwrecordindex, btag, ::core::mem::transmute(pdwcookie.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppdescriptor)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn RegisterForNextTable<P0>(&self, hnexttableavailable: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterForNextTable)(::windows::core::Vtable::as_raw(self), hnexttableavailable.into()).ok()
    }
    pub unsafe fn GetNextTable(&self) -> ::windows::core::Result<IDVB_EIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetNextTable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn RegisterForWhenCurrent<P0>(&self, hnexttableiscurrent: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterForWhenCurrent)(::windows::core::Vtable::as_raw(self), hnexttableiscurrent.into()).ok()
    }
    pub unsafe fn ConvertNextToCurrent(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ConvertNextToCurrent)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn GetVersionHash(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetVersionHash)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDVB_NIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_NIT {}
impl ::core::fmt::Debug for IDVB_NIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_NIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_RST {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_RST {}
impl ::core::fmt::Debug for IDVB_RST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_RST").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_SDT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_SDT {}
impl ::core::fmt::Debug for IDVB_SDT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_SDT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_SIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_SIT {}
impl ::core::fmt::Debug for IDVB_SIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_SIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_ST {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_ST {}
impl ::core::fmt::Debug for IDVB_ST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_ST").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_TDT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_TDT {}
impl ::core::fmt::Debug for IDVB_TDT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_TDT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVB_TOT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVB_TOT {}
impl ::core::fmt::Debug for IDVB_TOT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVB_TOT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVEnc {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVEnc {}
impl ::core::fmt::Debug for IDVEnc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVEnc").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVRGB219 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVRGB219 {}
impl ::core::fmt::Debug for IDVRGB219 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVRGB219").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDVSplitter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDVSplitter {}
impl ::core::fmt::Debug for IDVSplitter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDVSplitter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDecimateVideoImage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDecimateVideoImage {}
impl ::core::fmt::Debug for IDecimateVideoImage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDecimateVideoImage").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDeferredCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDeferredCommand {}
impl ::core::fmt::Debug for IDeferredCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDeferredCommand").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDigitalCableLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDigitalCableLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDigitalCableLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDigitalCableLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalCableLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn PhysicalChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PhysicalChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPhysicalChannel(&self, physicalchannel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPhysicalChannel)(::windows::core::Vtable::as_raw(self), physicalchannel).ok()
    }
    pub unsafe fn TSID(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.TSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetTSID(&self, tsid: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetTSID)(::windows::core::Vtable::as_raw(self), tsid).ok()
    }
    pub unsafe fn ProgramNumber(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ProgramNumber)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetProgramNumber(&self, programnumber: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetProgramNumber)(::windows::core::Vtable::as_raw(self), programnumber).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDigitalCableTuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDigitalCableTuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDigitalCableTuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDigitalCableTuneRequest").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalCableTuneRequest {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Components(&self) -> ::windows::core::Result<IComponents> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Components)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Locator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Locator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetLocator<P0>(&self, locator: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetLocator)(::windows::core::Vtable::as_raw(self), locator.into().abi()).ok()
    }
    pub unsafe fn Channel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Channel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetChannel(&self, channel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetChannel)(::windows::core::Vtable::as_raw(self), channel).ok()
    }
    pub unsafe fn MinorChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinorChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMinorChannel(&self, minorchannel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMinorChannel)(::windows::core::Vtable::as_raw(self), minorchannel).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDigitalCableTuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDigitalCableTuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDigitalCableTuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDigitalCableTuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalCableTuningSpace {
    pub unsafe fn UniqueName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.UniqueName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetUniqueName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetUniqueName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn FriendlyName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.FriendlyName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFriendlyName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetFriendlyName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn CLSID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CLSID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn NetworkType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetNetworkType(&self, networktypeguid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetNetworkType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(networktypeguid)).ok()
    }
    pub unsafe fn _NetworkType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._NetworkType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_NetworkType(&self, networktypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Set_NetworkType)(::windows::core::Vtable::as_raw(self), networktypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateTuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CreateTuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumCategoryGUIDs(&self) -> ::windows::core::Result<super::super::System::Com::IEnumGUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EnumCategoryGUIDs)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EnumDeviceMonikers(&self) -> ::windows::core::Result<super::super::System::Com::IEnumMoniker> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EnumDeviceMonikers)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultPreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.DefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultPreferredComponentTypes<P0>(&self, newcomponenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetDefaultPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), newcomponenttypes.into().abi()).ok()
    }
    pub unsafe fn FrequencyMapping(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.FrequencyMapping)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFrequencyMapping(&self, mapping: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetFrequencyMapping)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mapping)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DefaultLocator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.DefaultLocator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDefaultLocator<P0>(&self, locatorval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetDefaultLocator)(::windows::core::Vtable::as_raw(self), locatorval.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn MinChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.MinChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMinChannel(&self, newminchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetMinChannel)(::windows::core::Vtable::as_raw(self), newminchannelval).ok()
    }
    pub unsafe fn MaxChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.MaxChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMaxChannel(&self, newmaxchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetMaxChannel)(::windows::core::Vtable::as_raw(self), newmaxchannelval).ok()
    }
    pub unsafe fn InputType(&self) -> ::windows::core::Result<TunerInputType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.InputType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInputType(&self, newinputtypeval: TunerInputType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetInputType)(::windows::core::Vtable::as_raw(self), newinputtypeval).ok()
    }
    pub unsafe fn CountryCode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CountryCode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCountryCode(&self, newcountrycodeval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCountryCode)(::windows::core::Vtable::as_raw(self), newcountrycodeval).ok()
    }
    pub unsafe fn MinMinorChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinMinorChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMinMinorChannel(&self, newminminorchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMinMinorChannel)(::windows::core::Vtable::as_raw(self), newminminorchannelval).ok()
    }
    pub unsafe fn MaxMinorChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxMinorChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMaxMinorChannel(&self, newmaxminorchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMaxMinorChannel)(::windows::core::Vtable::as_raw(self), newmaxminorchannelval).ok()
    }
    pub unsafe fn MinPhysicalChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinPhysicalChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMinPhysicalChannel(&self, newminphysicalchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMinPhysicalChannel)(::windows::core::Vtable::as_raw(self), newminphysicalchannelval).ok()
    }
    pub unsafe fn MaxPhysicalChannel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxPhysicalChannel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMaxPhysicalChannel(&self, newmaxphysicalchannelval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMaxPhysicalChannel)(::windows::core::Vtable::as_raw(self), newmaxphysicalchannelval).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IDigitalLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IDigitalLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IDigitalLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDigitalLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IDigitalLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDirectDrawMediaSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawMediaSample {}
impl ::core::fmt::Debug for IDirectDrawMediaSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawMediaSample").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDirectDrawMediaSampleAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawMediaSampleAllocator {}
impl ::core::fmt::Debug for IDirectDrawMediaSampleAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawMediaSampleAllocator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDirectDrawMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawMediaStream {}
impl ::core::fmt::Debug for IDirectDrawMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawMediaStream").field(&self.0).finish()
    }
}
impl IDirectDrawMediaStream {
    pub unsafe fn GetMultiMediaStream(&self) -> ::windows::core::Result<IMultiMediaStream> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMultiMediaStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetInformation(&self, ppurposeid: *mut ::windows::core::GUID, ptype: *mut STREAM_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetInformation)(::windows::core::Vtable::as_raw(self), ppurposeid, ptype).ok()
    }
    pub unsafe fn SetSameFormat<P0>(&self, pstreamthathasdesiredformat: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMediaStream>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSameFormat)(::windows::core::Vtable::as_raw(self), pstreamthathasdesiredformat.into().abi(), dwflags).ok()
    }
    pub unsafe fn AllocateSample(&self, dwflags: u32) -> ::windows::core::Result<IStreamSample> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AllocateSample)(::windows::core::Vtable::as_raw(self), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CreateSharedSample<P0>(&self, pexistingsample: P0, dwflags: u32) -> ::windows::core::Result<IStreamSample>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IStreamSample>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateSharedSample)(::windows::core::Vtable::as_raw(self), pexistingsample.into().abi(), dwflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SendEndOfStream(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SendEndOfStream)(::windows::core::Vtable::as_raw(self), dwflags).ok()
    }
}
impl ::core::cmp::PartialEq for IDirectDrawStreamSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawStreamSample {}
impl ::core::fmt::Debug for IDirectDrawStreamSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawStreamSample").field(&self.0).finish()
    }
}
impl IDirectDrawStreamSample {
    pub unsafe fn GetMediaStream(&self, ppmediastream: *const ::core::option::Option<IMediaStream>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetMediaStream)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(ppmediastream)).ok()
    }
    pub unsafe fn GetSampleTimes(&self, pstarttime: *mut i64, pendtime: *mut i64, pcurrenttime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetSampleTimes)(::windows::core::Vtable::as_raw(self), pstarttime, pendtime, pcurrenttime).ok()
    }
    pub unsafe fn SetSampleTimes(&self, pstarttime: *const i64, pendtime: *const i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSampleTimes)(::windows::core::Vtable::as_raw(self), pstarttime, pendtime).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Update<P0>(&self, dwflags: u32, hevent: P0, pfnapc: super::super::Foundation::PAPCFUNC, dwapcdata: usize) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.Update)(::windows::core::Vtable::as_raw(self), dwflags, hevent.into(), pfnapc, dwapcdata).ok()
    }
    pub unsafe fn CompletionStatus(&self, dwflags: u32, dwmilliseconds: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CompletionStatus)(::windows::core::Vtable::as_raw(self), dwflags, dwmilliseconds).ok()
    }
}
impl ::core::cmp::PartialEq for IDirectDrawVideo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawVideo {}
impl ::core::fmt::Debug for IDirectDrawVideo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawVideo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDistributorNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDistributorNotify {}
impl ::core::fmt::Debug for IDistributorNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDistributorNotify").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDrawVideoImage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDrawVideoImage {}
impl ::core::fmt::Debug for IDrawVideoImage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDrawVideoImage").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbCableDeliverySystemDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbCableDeliverySystemDescriptor {}
impl ::core::fmt::Debug for IDvbCableDeliverySystemDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbCableDeliverySystemDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbComponentDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbComponentDescriptor {}
impl ::core::fmt::Debug for IDvbComponentDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbComponentDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbContentDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbContentDescriptor {}
impl ::core::fmt::Debug for IDvbContentDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbContentDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbContentIdentifierDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbContentIdentifierDescriptor {}
impl ::core::fmt::Debug for IDvbContentIdentifierDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbContentIdentifierDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbDataBroadcastDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbDataBroadcastDescriptor {}
impl ::core::fmt::Debug for IDvbDataBroadcastDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbDataBroadcastDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbDataBroadcastIDDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbDataBroadcastIDDescriptor {}
impl ::core::fmt::Debug for IDvbDataBroadcastIDDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbDataBroadcastIDDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbDefaultAuthorityDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbDefaultAuthorityDescriptor {}
impl ::core::fmt::Debug for IDvbDefaultAuthorityDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbDefaultAuthorityDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbExtendedEventDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbExtendedEventDescriptor {}
impl ::core::fmt::Debug for IDvbExtendedEventDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbExtendedEventDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbFrequencyListDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbFrequencyListDescriptor {}
impl ::core::fmt::Debug for IDvbFrequencyListDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbFrequencyListDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbHDSimulcastLogicalChannelDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbHDSimulcastLogicalChannelDescriptor {}
impl ::core::fmt::Debug for IDvbHDSimulcastLogicalChannelDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbHDSimulcastLogicalChannelDescriptor").field(&self.0).finish()
    }
}
impl IDvbHDSimulcastLogicalChannelDescriptor {
    pub unsafe fn GetTag(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetTag)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLength(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetLength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCountOfRecords(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetCountOfRecords)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordServiceId(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetRecordServiceId)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordLogicalChannelNumber(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetRecordLogicalChannelNumber)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordLogicalChannelAndVisibility(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordLogicalChannelAndVisibility)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDvbLinkageDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbLinkageDescriptor {}
impl ::core::fmt::Debug for IDvbLinkageDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbLinkageDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbLogicalChannel2Descriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbLogicalChannel2Descriptor {}
impl ::core::fmt::Debug for IDvbLogicalChannel2Descriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbLogicalChannel2Descriptor").field(&self.0).finish()
    }
}
impl IDvbLogicalChannel2Descriptor {
    pub unsafe fn GetTag(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetTag)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLength(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetLength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCountOfRecords(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetCountOfRecords)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordServiceId(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetRecordServiceId)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordLogicalChannelNumber(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetRecordLogicalChannelNumber)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordLogicalChannelAndVisibility(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordLogicalChannelAndVisibility)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDvbLogicalChannelDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbLogicalChannelDescriptor {}
impl ::core::fmt::Debug for IDvbLogicalChannelDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbLogicalChannelDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbLogicalChannelDescriptor2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbLogicalChannelDescriptor2 {}
impl ::core::fmt::Debug for IDvbLogicalChannelDescriptor2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbLogicalChannelDescriptor2").field(&self.0).finish()
    }
}
impl IDvbLogicalChannelDescriptor2 {
    pub unsafe fn GetTag(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTag)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLength(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetLength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCountOfRecords(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCountOfRecords)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordServiceId(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordServiceId)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordLogicalChannelNumber(&self, brecordindex: u8) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordLogicalChannelNumber)(::windows::core::Vtable::as_raw(self), brecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDvbMultilingualServiceNameDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbMultilingualServiceNameDescriptor {}
impl ::core::fmt::Debug for IDvbMultilingualServiceNameDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbMultilingualServiceNameDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbNetworkNameDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbNetworkNameDescriptor {}
impl ::core::fmt::Debug for IDvbNetworkNameDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbNetworkNameDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbParentalRatingDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbParentalRatingDescriptor {}
impl ::core::fmt::Debug for IDvbParentalRatingDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbParentalRatingDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbPrivateDataSpecifierDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbPrivateDataSpecifierDescriptor {}
impl ::core::fmt::Debug for IDvbPrivateDataSpecifierDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbPrivateDataSpecifierDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbSatelliteDeliverySystemDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbSatelliteDeliverySystemDescriptor {}
impl ::core::fmt::Debug for IDvbSatelliteDeliverySystemDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbSatelliteDeliverySystemDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbServiceAttributeDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbServiceAttributeDescriptor {}
impl ::core::fmt::Debug for IDvbServiceAttributeDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbServiceAttributeDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbServiceDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbServiceDescriptor {}
impl ::core::fmt::Debug for IDvbServiceDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbServiceDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbServiceDescriptor2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbServiceDescriptor2 {}
impl ::core::fmt::Debug for IDvbServiceDescriptor2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbServiceDescriptor2").field(&self.0).finish()
    }
}
impl IDvbServiceDescriptor2 {
    pub unsafe fn GetTag(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTag)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLength(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetLength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetServiceType(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetServiceType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetServiceProviderName(&self) -> ::windows::core::Result<*mut u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetServiceProviderName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetServiceProviderNameW(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetServiceProviderNameW)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetServiceName(&self) -> ::windows::core::Result<*mut u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetServiceName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetProcessedServiceName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetProcessedServiceName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetServiceNameEmphasized(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetServiceNameEmphasized)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDvbServiceListDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbServiceListDescriptor {}
impl ::core::fmt::Debug for IDvbServiceListDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbServiceListDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbShortEventDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbShortEventDescriptor {}
impl ::core::fmt::Debug for IDvbShortEventDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbShortEventDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbSiParser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbSiParser {}
impl ::core::fmt::Debug for IDvbSiParser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbSiParser").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbSiParser2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbSiParser2 {}
impl ::core::fmt::Debug for IDvbSiParser2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbSiParser2").field(&self.0).finish()
    }
}
impl IDvbSiParser2 {
    pub unsafe fn Initialize<P0>(&self, punkmpeg2data: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Initialize)(::windows::core::Vtable::as_raw(self), punkmpeg2data.into().abi()).ok()
    }
    pub unsafe fn GetPAT(&self) -> ::windows::core::Result<IPAT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetPAT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCAT(&self, dwtimeout: u32) -> ::windows::core::Result<ICAT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCAT)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetPMT(&self, pid: u16, pwprogramnumber: ::core::option::Option<*const u16>) -> ::windows::core::Result<IPMT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetPMT)(::windows::core::Vtable::as_raw(self), pid, ::core::mem::transmute(pwprogramnumber.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTSDT(&self) -> ::windows::core::Result<ITSDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTSDT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetNIT(&self, tableid: u8, pwnetworkid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_NIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetNIT)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwnetworkid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetSDT(&self, tableid: u8, pwtransportstreamid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_SDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetSDT)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwtransportstreamid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEIT(&self, tableid: u8, pwserviceid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_EIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEIT)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwserviceid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetBAT(&self, pwbouquetid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_BAT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetBAT)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pwbouquetid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRST(&self, dwtimeout: u32) -> ::windows::core::Result<IDVB_RST> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRST)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetST(&self, pid: u16, dwtimeout: u32) -> ::windows::core::Result<IDVB_ST> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetST)(::windows::core::Vtable::as_raw(self), pid, dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTDT(&self) -> ::windows::core::Result<IDVB_TDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTDT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTOT(&self) -> ::windows::core::Result<IDVB_TOT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTOT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetDIT(&self, dwtimeout: u32) -> ::windows::core::Result<IDVB_DIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetDIT)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetSIT(&self, dwtimeout: u32) -> ::windows::core::Result<IDVB_SIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetSIT)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IDvbSubtitlingDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbSubtitlingDescriptor {}
impl ::core::fmt::Debug for IDvbSubtitlingDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbSubtitlingDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbTeletextDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbTeletextDescriptor {}
impl ::core::fmt::Debug for IDvbTeletextDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbTeletextDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbTerrestrial2DeliverySystemDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbTerrestrial2DeliverySystemDescriptor {}
impl ::core::fmt::Debug for IDvbTerrestrial2DeliverySystemDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbTerrestrial2DeliverySystemDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvbTerrestrialDeliverySystemDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvbTerrestrialDeliverySystemDescriptor {}
impl ::core::fmt::Debug for IDvbTerrestrialDeliverySystemDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvbTerrestrialDeliverySystemDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdCmd {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdCmd {}
impl ::core::fmt::Debug for IDvdCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdCmd").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdControl {}
impl ::core::fmt::Debug for IDvdControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdControl2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdControl2 {}
impl ::core::fmt::Debug for IDvdControl2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdControl2").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdGraphBuilder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdGraphBuilder {}
impl ::core::fmt::Debug for IDvdGraphBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdGraphBuilder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdInfo {}
impl ::core::fmt::Debug for IDvdInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdInfo2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdInfo2 {}
impl ::core::fmt::Debug for IDvdInfo2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdInfo2").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IDvdState {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDvdState {}
impl ::core::fmt::Debug for IDvdState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDvdState").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IESCloseMmiEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESCloseMmiEvent {}
impl ::core::fmt::Debug for IESCloseMmiEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESCloseMmiEvent").field(&self.0).finish()
    }
}
impl IESCloseMmiEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IESEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESEvent {}
impl ::core::fmt::Debug for IESEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESEvent").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IESEventFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESEventFactory {}
impl ::core::fmt::Debug for IESEventFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESEventFactory").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IESEventService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESEventService {}
impl ::core::fmt::Debug for IESEventService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESEventService").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IESEventServiceConfiguration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESEventServiceConfiguration {}
impl ::core::fmt::Debug for IESEventServiceConfiguration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESEventServiceConfiguration").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IESEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESEvents {}
impl ::core::fmt::Debug for IESEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESEvents").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IESFileExpiryDateEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESFileExpiryDateEvent {}
impl ::core::fmt::Debug for IESFileExpiryDateEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESFileExpiryDateEvent").field(&self.0).finish()
    }
}
impl IESFileExpiryDateEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IESIsdbCasResponseEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESIsdbCasResponseEvent {}
impl ::core::fmt::Debug for IESIsdbCasResponseEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESIsdbCasResponseEvent").field(&self.0).finish()
    }
}
impl IESIsdbCasResponseEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IESLicenseRenewalResultEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESLicenseRenewalResultEvent {}
impl ::core::fmt::Debug for IESLicenseRenewalResultEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESLicenseRenewalResultEvent").field(&self.0).finish()
    }
}
impl IESLicenseRenewalResultEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IESOpenMmiEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESOpenMmiEvent {}
impl ::core::fmt::Debug for IESOpenMmiEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESOpenMmiEvent").field(&self.0).finish()
    }
}
impl IESOpenMmiEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IESRequestTunerEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESRequestTunerEvent {}
impl ::core::fmt::Debug for IESRequestTunerEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESRequestTunerEvent").field(&self.0).finish()
    }
}
impl IESRequestTunerEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IESValueUpdatedEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IESValueUpdatedEvent {}
impl ::core::fmt::Debug for IESValueUpdatedEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESValueUpdatedEvent").field(&self.0).finish()
    }
}
impl IESValueUpdatedEvent {
    pub unsafe fn GetEventId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEventType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCompletionStatus(&self, dwresult: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCompletionStatus)(::windows::core::Vtable::as_raw(self), dwresult).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetData(&self) -> ::windows::core::Result<*mut super::super::System::Com::SAFEARRAY> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStringData(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStringData)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IETFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IETFilter {}
impl ::core::fmt::Debug for IETFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IETFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IETFilterConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IETFilterConfig {}
impl ::core::fmt::Debug for IETFilterConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IETFilterConfig").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IETFilterEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IETFilterEvents {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IETFilterEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IETFilterEvents").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEncoderAPI {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEncoderAPI {}
impl ::core::fmt::Debug for IEncoderAPI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEncoderAPI").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumComponentTypes {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumComponentTypes {}
impl ::core::fmt::Debug for IEnumComponentTypes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumComponentTypes").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumComponents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumComponents {}
impl ::core::fmt::Debug for IEnumComponents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumComponents").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumFilters {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumFilters {}
impl ::core::fmt::Debug for IEnumFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumFilters").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumGuideDataProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumGuideDataProperties {}
impl ::core::fmt::Debug for IEnumGuideDataProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumGuideDataProperties").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumMSVidGraphSegment {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumMSVidGraphSegment {}
impl ::core::fmt::Debug for IEnumMSVidGraphSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumMSVidGraphSegment").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumMediaTypes {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumMediaTypes {}
impl ::core::fmt::Debug for IEnumMediaTypes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumMediaTypes").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumPIDMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumPIDMap {}
impl ::core::fmt::Debug for IEnumPIDMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumPIDMap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumPins {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumPins {}
impl ::core::fmt::Debug for IEnumPins {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumPins").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumRegFilters {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumRegFilters {}
impl ::core::fmt::Debug for IEnumRegFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumRegFilters").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumStreamBufferRecordingAttrib {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumStreamBufferRecordingAttrib {}
impl ::core::fmt::Debug for IEnumStreamBufferRecordingAttrib {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumStreamBufferRecordingAttrib").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumStreamIdMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumStreamIdMap {}
impl ::core::fmt::Debug for IEnumStreamIdMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumStreamIdMap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumTuneRequests {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumTuneRequests {}
impl ::core::fmt::Debug for IEnumTuneRequests {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumTuneRequests").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IEnumTuningSpaces {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumTuningSpaces {}
impl ::core::fmt::Debug for IEnumTuningSpaces {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumTuningSpaces").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IEvalRat {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IEvalRat {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IEvalRat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEvalRat").field(&self.0).finish()
    }
}
impl ::core::default::Default for IFILTERMAPPER_MERIT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for IFILTERMAPPER_MERIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFILTERMAPPER_MERIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFileSinkFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileSinkFilter {}
impl ::core::fmt::Debug for IFileSinkFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSinkFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFileSinkFilter2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileSinkFilter2 {}
impl ::core::fmt::Debug for IFileSinkFilter2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSinkFilter2").field(&self.0).finish()
    }
}
impl IFileSinkFilter2 {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn SetFileName<P0>(&self, pszfilename: P0, pmt: ::core::option::Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetFileName)(::windows::core::Vtable::as_raw(self), pszfilename.into().abi(), ::core::mem::transmute(pmt.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn GetCurFile(&self, ppszfilename: *mut ::windows::core::PWSTR, pmt: *mut super::MediaFoundation::AM_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetCurFile)(::windows::core::Vtable::as_raw(self), ppszfilename, pmt).ok()
    }
}
impl ::core::cmp::PartialEq for IFileSourceFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileSourceFilter {}
impl ::core::fmt::Debug for IFileSourceFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSourceFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFilterChain {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterChain {}
impl ::core::fmt::Debug for IFilterChain {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterChain").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFilterGraph {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterGraph {}
impl ::core::fmt::Debug for IFilterGraph {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterGraph").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFilterGraph2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterGraph2 {}
impl ::core::fmt::Debug for IFilterGraph2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterGraph2").field(&self.0).finish()
    }
}
impl IFilterGraph2 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddFilter<P0, P1>(&self, pfilter: P0, pname: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IBaseFilter>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.AddFilter)(::windows::core::Vtable::as_raw(self), pfilter.into().abi(), pname.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveFilter<P0>(&self, pfilter: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IBaseFilter>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.RemoveFilter)(::windows::core::Vtable::as_raw(self), pfilter.into().abi()).ok()
    }
    pub unsafe fn EnumFilters(&self) -> ::windows::core::Result<IEnumFilters> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumFilters)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn FindFilterByName<P0>(&self, pname: P0) -> ::windows::core::Result<IBaseFilter>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FindFilterByName)(::windows::core::Vtable::as_raw(self), pname.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn ConnectDirect<P0, P1>(&self, ppinout: P0, ppinin: P1, pmt: ::core::option::Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
        P1: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.ConnectDirect)(::windows::core::Vtable::as_raw(self), ppinout.into().abi(), ppinin.into().abi(), ::core::mem::transmute(pmt.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn Reconnect<P0>(&self, ppin: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.Reconnect)(::windows::core::Vtable::as_raw(self), ppin.into().abi()).ok()
    }
    pub unsafe fn Disconnect<P0>(&self, ppin: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.Disconnect)(::windows::core::Vtable::as_raw(self), ppin.into().abi()).ok()
    }
    pub unsafe fn SetDefaultSyncSource(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDefaultSyncSource)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Connect<P0, P1>(&self, ppinout: P0, ppinin: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
        P1: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Connect)(::windows::core::Vtable::as_raw(self), ppinout.into().abi(), ppinin.into().abi()).ok()
    }
    pub unsafe fn Render<P0>(&self, ppinout: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Render)(::windows::core::Vtable::as_raw(self), ppinout.into().abi()).ok()
    }
    pub unsafe fn RenderFile<P0, P1>(&self, lpcwstrfile: P0, lpcwstrplaylist: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.RenderFile)(::windows::core::Vtable::as_raw(self), lpcwstrfile.into().abi(), lpcwstrplaylist.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddSourceFilter<P0, P1>(&self, lpcwstrfilename: P0, lpcwstrfiltername: P1) -> ::windows::core::Result<IBaseFilter>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AddSourceFilter)(::windows::core::Vtable::as_raw(self), lpcwstrfilename.into().abi(), lpcwstrfiltername.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetLogFile(&self, hfile: usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetLogFile)(::windows::core::Vtable::as_raw(self), hfile).ok()
    }
    pub unsafe fn Abort(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Abort)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ShouldOperationContinue(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ShouldOperationContinue)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IFilterGraph3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterGraph3 {}
impl ::core::fmt::Debug for IFilterGraph3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterGraph3").field(&self.0).finish()
    }
}
impl IFilterGraph3 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddFilter<P0, P1>(&self, pfilter: P0, pname: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IBaseFilter>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.AddFilter)(::windows::core::Vtable::as_raw(self), pfilter.into().abi(), pname.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveFilter<P0>(&self, pfilter: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IBaseFilter>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.RemoveFilter)(::windows::core::Vtable::as_raw(self), pfilter.into().abi()).ok()
    }
    pub unsafe fn EnumFilters(&self) -> ::windows::core::Result<IEnumFilters> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EnumFilters)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn FindFilterByName<P0>(&self, pname: P0) -> ::windows::core::Result<IBaseFilter>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.FindFilterByName)(::windows::core::Vtable::as_raw(self), pname.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn ConnectDirect<P0, P1>(&self, ppinout: P0, ppinin: P1, pmt: ::core::option::Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
        P1: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ConnectDirect)(::windows::core::Vtable::as_raw(self), ppinout.into().abi(), ppinin.into().abi(), ::core::mem::transmute(pmt.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn Reconnect<P0>(&self, ppin: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Reconnect)(::windows::core::Vtable::as_raw(self), ppin.into().abi()).ok()
    }
    pub unsafe fn Disconnect<P0>(&self, ppin: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Disconnect)(::windows::core::Vtable::as_raw(self), ppin.into().abi()).ok()
    }
    pub unsafe fn SetDefaultSyncSource(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetDefaultSyncSource)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Connect<P0, P1>(&self, ppinout: P0, ppinin: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
        P1: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.Connect)(::windows::core::Vtable::as_raw(self), ppinout.into().abi(), ppinin.into().abi()).ok()
    }
    pub unsafe fn Render<P0>(&self, ppinout: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.Render)(::windows::core::Vtable::as_raw(self), ppinout.into().abi()).ok()
    }
    pub unsafe fn RenderFile<P0, P1>(&self, lpcwstrfile: P0, lpcwstrplaylist: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.RenderFile)(::windows::core::Vtable::as_raw(self), lpcwstrfile.into().abi(), lpcwstrplaylist.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddSourceFilter<P0, P1>(&self, lpcwstrfilename: P0, lpcwstrfiltername: P1) -> ::windows::core::Result<IBaseFilter>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.AddSourceFilter)(::windows::core::Vtable::as_raw(self), lpcwstrfilename.into().abi(), lpcwstrfiltername.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetLogFile(&self, hfile: usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetLogFile)(::windows::core::Vtable::as_raw(self), hfile).ok()
    }
    pub unsafe fn Abort(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Abort)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ShouldOperationContinue(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.ShouldOperationContinue)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddSourceFilterForMoniker<P0, P1, P2>(&self, pmoniker: P0, pctx: P1, lpcwstrfiltername: P2) -> ::windows::core::Result<IBaseFilter>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Com::IMoniker>>,
        P1: ::std::convert::Into<::windows::core::InParam<super::super::System::Com::IBindCtx>>,
        P2: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AddSourceFilterForMoniker)(::windows::core::Vtable::as_raw(self), pmoniker.into().abi(), pctx.into().abi(), lpcwstrfiltername.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn ReconnectEx<P0>(&self, ppin: P0, pmt: ::core::option::Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.ReconnectEx)(::windows::core::Vtable::as_raw(self), ppin.into().abi(), ::core::mem::transmute(pmt.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn RenderEx<P0>(&self, ppinout: P0, dwflags: u32, pvcontext: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.RenderEx)(::windows::core::Vtable::as_raw(self), ppinout.into().abi(), dwflags, ::core::mem::transmute(pvcontext.unwrap_or(::std::ptr::null_mut()))).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IFilterInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IFilterInfo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IFilterInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFilterMapper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterMapper {}
impl ::core::fmt::Debug for IFilterMapper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterMapper").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFilterMapper2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterMapper2 {}
impl ::core::fmt::Debug for IFilterMapper2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterMapper2").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFilterMapper3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFilterMapper3 {}
impl ::core::fmt::Debug for IFilterMapper3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFilterMapper3").field(&self.0).finish()
    }
}
impl IFilterMapper3 {
    pub unsafe fn CreateCategory<P0>(&self, clsidcategory: *const ::windows::core::GUID, dwcategorymerit: u32, description: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.CreateCategory)(::windows::core::Vtable::as_raw(self), clsidcategory, dwcategorymerit, description.into().abi()).ok()
    }
    pub unsafe fn UnregisterFilter<P0>(&self, pclsidcategory: *const ::windows::core::GUID, szinstance: P0, filter: *const ::windows::core::GUID) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.UnregisterFilter)(::windows::core::Vtable::as_raw(self), pclsidcategory, szinstance.into().abi(), filter).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn RegisterFilter<P0, P1>(&self, clsidfilter: *const ::windows::core::GUID, name: P0, ppmoniker: ::core::option::Option<*mut ::core::option::Option<super::super::System::Com::IMoniker>>, pclsidcategory: *const ::windows::core::GUID, szinstance: P1, prf2: *const REGFILTER2) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterFilter)(::windows::core::Vtable::as_raw(self), clsidfilter, name.into().abi(), ::core::mem::transmute(ppmoniker.unwrap_or(::std::ptr::null_mut())), pclsidcategory, szinstance.into().abi(), prf2).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn EnumMatchingFilters<P0, P1, P2, P3>(&self, ppenum: *mut ::core::option::Option<super::super::System::Com::IEnumMoniker>, dwflags: u32, bexactmatch: P0, dwmerit: u32, binputneeded: P1, cinputtypes: u32, pinputtypes: ::core::option::Option<*const ::windows::core::GUID>, pmedin: ::core::option::Option<*const REGPINMEDIUM>, ppincategoryin: ::core::option::Option<*const ::windows::core::GUID>, brender: P2, boutputneeded: P3, coutputtypes: u32, poutputtypes: ::core::option::Option<*const ::windows::core::GUID>, pmedout: ::core::option::Option<*const REGPINMEDIUM>, ppincategoryout: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
        P1: ::std::convert::Into<super::super::Foundation::BOOL>,
        P2: ::std::convert::Into<super::super::Foundation::BOOL>,
        P3: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.EnumMatchingFilters)(
            ::windows::core::Vtable::as_raw(self),
            ::core::mem::transmute(ppenum),
            dwflags,
            bexactmatch.into(),
            dwmerit,
            binputneeded.into(),
            cinputtypes,
            ::core::mem::transmute(pinputtypes.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(pmedin.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppincategoryin.unwrap_or(::std::ptr::null())),
            brender.into(),
            boutputneeded.into(),
            coutputtypes,
            ::core::mem::transmute(poutputtypes.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(pmedout.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppincategoryout.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
}
impl ::core::cmp::PartialEq for IFrequencyMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFrequencyMap {}
impl ::core::fmt::Debug for IFrequencyMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFrequencyMap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFullScreenVideo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFullScreenVideo {}
impl ::core::fmt::Debug for IFullScreenVideo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFullScreenVideo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IFullScreenVideoEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFullScreenVideoEx {}
impl ::core::fmt::Debug for IFullScreenVideoEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFullScreenVideoEx").field(&self.0).finish()
    }
}
impl IFullScreenVideoEx {
    pub unsafe fn CountModes(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CountModes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetModeInfo(&self, mode: i32, pwidth: *mut i32, pheight: *mut i32, pdepth: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetModeInfo)(::windows::core::Vtable::as_raw(self), mode, pwidth, pheight, pdepth).ok()
    }
    pub unsafe fn GetCurrentMode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCurrentMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn IsModeAvailable(&self, mode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsModeAvailable)(::windows::core::Vtable::as_raw(self), mode).ok()
    }
    pub unsafe fn IsModeEnabled(&self, mode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsModeEnabled)(::windows::core::Vtable::as_raw(self), mode).ok()
    }
    pub unsafe fn SetEnabled(&self, mode: i32, benabled: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetEnabled)(::windows::core::Vtable::as_raw(self), mode, benabled).ok()
    }
    pub unsafe fn GetClipFactor(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetClipFactor)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetClipFactor(&self, clipfactor: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetClipFactor)(::windows::core::Vtable::as_raw(self), clipfactor).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMessageDrain<P0>(&self, hwnd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HWND>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMessageDrain)(::windows::core::Vtable::as_raw(self), hwnd.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMessageDrain(&self) -> ::windows::core::Result<super::super::Foundation::HWND> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMessageDrain)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMonitor(&self, monitor: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMonitor)(::windows::core::Vtable::as_raw(self), monitor).ok()
    }
    pub unsafe fn GetMonitor(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMonitor)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn HideOnDeactivate(&self, hide: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.HideOnDeactivate)(::windows::core::Vtable::as_raw(self), hide).ok()
    }
    pub unsafe fn IsHideOnDeactivate(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsHideOnDeactivate)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SetCaption(&self, strcaption: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCaption)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(strcaption)).ok()
    }
    pub unsafe fn GetCaption(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCaption)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDefault(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDefault)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IGenericDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGenericDescriptor {}
impl ::core::fmt::Debug for IGenericDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGenericDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGenericDescriptor2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGenericDescriptor2 {}
impl ::core::fmt::Debug for IGenericDescriptor2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGenericDescriptor2").field(&self.0).finish()
    }
}
impl IGenericDescriptor2 {
    pub unsafe fn Initialize(&self, pbdesc: *const u8, bcount: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Initialize)(::windows::core::Vtable::as_raw(self), pbdesc, bcount).ok()
    }
    pub unsafe fn GetTag(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTag)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetLength(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetLength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetBody(&self) -> ::windows::core::Result<*mut u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetBody)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IGetCapabilitiesKey {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGetCapabilitiesKey {}
impl ::core::fmt::Debug for IGetCapabilitiesKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGetCapabilitiesKey").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGpnvsCommonBase {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGpnvsCommonBase {}
impl ::core::fmt::Debug for IGpnvsCommonBase {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGpnvsCommonBase").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGraphBuilder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGraphBuilder {}
impl ::core::fmt::Debug for IGraphBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGraphBuilder").field(&self.0).finish()
    }
}
impl IGraphBuilder {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AddFilter<P0, P1>(&self, pfilter: P0, pname: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IBaseFilter>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.AddFilter)(::windows::core::Vtable::as_raw(self), pfilter.into().abi(), pname.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn RemoveFilter<P0>(&self, pfilter: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IBaseFilter>>,
    {
        (::windows::core::Vtable::vtable(self).base__.RemoveFilter)(::windows::core::Vtable::as_raw(self), pfilter.into().abi()).ok()
    }
    pub unsafe fn EnumFilters(&self) -> ::windows::core::Result<IEnumFilters> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumFilters)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn FindFilterByName<P0>(&self, pname: P0) -> ::windows::core::Result<IBaseFilter>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FindFilterByName)(::windows::core::Vtable::as_raw(self), pname.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn ConnectDirect<P0, P1>(&self, ppinout: P0, ppinin: P1, pmt: ::core::option::Option<*const super::MediaFoundation::AM_MEDIA_TYPE>) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
        P1: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.ConnectDirect)(::windows::core::Vtable::as_raw(self), ppinout.into().abi(), ppinin.into().abi(), ::core::mem::transmute(pmt.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn Reconnect<P0>(&self, ppin: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Reconnect)(::windows::core::Vtable::as_raw(self), ppin.into().abi()).ok()
    }
    pub unsafe fn Disconnect<P0>(&self, ppin: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IPin>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Disconnect)(::windows::core::Vtable::as_raw(self), ppin.into().abi()).ok()
    }
    pub unsafe fn SetDefaultSyncSource(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultSyncSource)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IGraphConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGraphConfig {}
impl ::core::fmt::Debug for IGraphConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGraphConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGraphConfigCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGraphConfigCallback {}
impl ::core::fmt::Debug for IGraphConfigCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGraphConfigCallback").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGraphVersion {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGraphVersion {}
impl ::core::fmt::Debug for IGraphVersion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGraphVersion").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGuideData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGuideData {}
impl ::core::fmt::Debug for IGuideData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGuideData").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGuideDataEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGuideDataEvent {}
impl ::core::fmt::Debug for IGuideDataEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGuideDataEvent").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGuideDataLoader {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGuideDataLoader {}
impl ::core::fmt::Debug for IGuideDataLoader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGuideDataLoader").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IGuideDataProperty {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGuideDataProperty {}
impl ::core::fmt::Debug for IGuideDataProperty {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGuideDataProperty").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIPDVDec {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIPDVDec {}
impl ::core::fmt::Debug for IIPDVDec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIPDVDec").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IISDBSLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IISDBSLocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IISDBSLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDBSLocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IISDBSLocator {
    pub unsafe fn CarrierFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CarrierFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCarrierFrequency(&self, frequency: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetCarrierFrequency)(::windows::core::Vtable::as_raw(self), frequency).ok()
    }
    pub unsafe fn InnerFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn InnerFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.InnerFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInnerFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetInnerFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFEC(&self) -> ::windows::core::Result<FECMethod> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFEC)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFEC(&self, fec: FECMethod) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFEC)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn OuterFECRate(&self) -> ::windows::core::Result<BinaryConvolutionCodeRate> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.OuterFECRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOuterFECRate(&self, fec: BinaryConvolutionCodeRate) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetOuterFECRate)(::windows::core::Vtable::as_raw(self), fec).ok()
    }
    pub unsafe fn Modulation(&self) -> ::windows::core::Result<ModulationType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Modulation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetModulation(&self, modulation: ModulationType) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetModulation)(::windows::core::Vtable::as_raw(self), modulation).ok()
    }
    pub unsafe fn SymbolRate(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SymbolRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSymbolRate(&self, rate: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetSymbolRate)(::windows::core::Vtable::as_raw(self), rate).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SignalPolarisation(&self) -> ::windows::core::Result<Polarisation> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SignalPolarisation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSignalPolarisation(&self, polarisationval: Polarisation) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSignalPolarisation)(::windows::core::Vtable::as_raw(self), polarisationval).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn WestPosition(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.WestPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetWestPosition<P0>(&self, westlongitude: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetWestPosition)(::windows::core::Vtable::as_raw(self), westlongitude.into()).ok()
    }
    pub unsafe fn OrbitalPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OrbitalPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOrbitalPosition(&self, longitude: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOrbitalPosition)(::windows::core::Vtable::as_raw(self), longitude).ok()
    }
    pub unsafe fn Azimuth(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Azimuth)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetAzimuth(&self, azimuth: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetAzimuth)(::windows::core::Vtable::as_raw(self), azimuth).ok()
    }
    pub unsafe fn Elevation(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Elevation)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetElevation(&self, elevation: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetElevation)(::windows::core::Vtable::as_raw(self), elevation).ok()
    }
}
impl ::core::cmp::PartialEq for IISDB_BIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_BIT {}
impl ::core::fmt::Debug for IISDB_BIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_BIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IISDB_CDT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_CDT {}
impl ::core::fmt::Debug for IISDB_CDT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_CDT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IISDB_EMM {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_EMM {}
impl ::core::fmt::Debug for IISDB_EMM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_EMM").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IISDB_LDT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_LDT {}
impl ::core::fmt::Debug for IISDB_LDT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_LDT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IISDB_NBIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_NBIT {}
impl ::core::fmt::Debug for IISDB_NBIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_NBIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IISDB_SDT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_SDT {}
impl ::core::fmt::Debug for IISDB_SDT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_SDT").field(&self.0).finish()
    }
}
impl IISDB_SDT {
    pub unsafe fn Initialize<P0, P1>(&self, psectionlist: P0, pmpegdata: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ISectionList>>,
        P1: ::std::convert::Into<::windows::core::InParam<IMpeg2Data>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Initialize)(::windows::core::Vtable::as_raw(self), psectionlist.into().abi(), pmpegdata.into().abi()).ok()
    }
    pub unsafe fn GetVersionNumber(&self) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetVersionNumber)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTransportStreamId(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTransportStreamId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetOriginalNetworkId(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetOriginalNetworkId)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCountOfRecords(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCountOfRecords)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordServiceId(&self, dwrecordindex: u32) -> ::windows::core::Result<u16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordServiceId)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRecordEITScheduleFlag(&self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordEITScheduleFlag)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRecordEITPresentFollowingFlag(&self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordEITPresentFollowingFlag)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordRunningStatus(&self, dwrecordindex: u32) -> ::windows::core::Result<u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordRunningStatus)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRecordFreeCAMode(&self, dwrecordindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordFreeCAMode)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordCountOfDescriptors(&self, dwrecordindex: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordCountOfDescriptors)(::windows::core::Vtable::as_raw(self), dwrecordindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordDescriptorByIndex(&self, dwrecordindex: u32, dwindex: u32) -> ::windows::core::Result<IGenericDescriptor> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRecordDescriptorByIndex)(::windows::core::Vtable::as_raw(self), dwrecordindex, dwindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRecordDescriptorByTag(&self, dwrecordindex: u32, btag: u8, pdwcookie: ::core::option::Option<*mut u32>, ppdescriptor: *mut ::core::option::Option<IGenericDescriptor>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetRecordDescriptorByTag)(::windows::core::Vtable::as_raw(self), dwrecordindex, btag, ::core::mem::transmute(pdwcookie.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppdescriptor)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn RegisterForNextTable<P0>(&self, hnexttableavailable: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterForNextTable)(::windows::core::Vtable::as_raw(self), hnexttableavailable.into()).ok()
    }
    pub unsafe fn GetNextTable(&self) -> ::windows::core::Result<IDVB_SDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetNextTable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn RegisterForWhenCurrent<P0>(&self, hnexttableiscurrent: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Vtable::vtable(self).base__.RegisterForWhenCurrent)(::windows::core::Vtable::as_raw(self), hnexttableiscurrent.into()).ok()
    }
    pub unsafe fn ConvertNextToCurrent(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ConvertNextToCurrent)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn GetVersionHash(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetVersionHash)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IISDB_SDTT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IISDB_SDTT {}
impl ::core::fmt::Debug for IISDB_SDTT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IISDB_SDTT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbAudioComponentDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbAudioComponentDescriptor {}
impl ::core::fmt::Debug for IIsdbAudioComponentDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbAudioComponentDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbCAContractInformationDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbCAContractInformationDescriptor {}
impl ::core::fmt::Debug for IIsdbCAContractInformationDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbCAContractInformationDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbCADescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbCADescriptor {}
impl ::core::fmt::Debug for IIsdbCADescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbCADescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbCAServiceDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbCAServiceDescriptor {}
impl ::core::fmt::Debug for IIsdbCAServiceDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbCAServiceDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbComponentGroupDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbComponentGroupDescriptor {}
impl ::core::fmt::Debug for IIsdbComponentGroupDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbComponentGroupDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbDataContentDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbDataContentDescriptor {}
impl ::core::fmt::Debug for IIsdbDataContentDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbDataContentDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbDigitalCopyControlDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbDigitalCopyControlDescriptor {}
impl ::core::fmt::Debug for IIsdbDigitalCopyControlDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbDigitalCopyControlDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbDownloadContentDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbDownloadContentDescriptor {}
impl ::core::fmt::Debug for IIsdbDownloadContentDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbDownloadContentDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbEmergencyInformationDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbEmergencyInformationDescriptor {}
impl ::core::fmt::Debug for IIsdbEmergencyInformationDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbEmergencyInformationDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbEventGroupDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbEventGroupDescriptor {}
impl ::core::fmt::Debug for IIsdbEventGroupDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbEventGroupDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbHierarchicalTransmissionDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbHierarchicalTransmissionDescriptor {}
impl ::core::fmt::Debug for IIsdbHierarchicalTransmissionDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbHierarchicalTransmissionDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbLogoTransmissionDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbLogoTransmissionDescriptor {}
impl ::core::fmt::Debug for IIsdbLogoTransmissionDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbLogoTransmissionDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbSIParameterDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbSIParameterDescriptor {}
impl ::core::fmt::Debug for IIsdbSIParameterDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbSIParameterDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbSeriesDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbSeriesDescriptor {}
impl ::core::fmt::Debug for IIsdbSeriesDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbSeriesDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbSiParser2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbSiParser2 {}
impl ::core::fmt::Debug for IIsdbSiParser2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbSiParser2").field(&self.0).finish()
    }
}
impl IIsdbSiParser2 {
    pub unsafe fn Initialize<P0>(&self, punkmpeg2data: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.Initialize)(::windows::core::Vtable::as_raw(self), punkmpeg2data.into().abi()).ok()
    }
    pub unsafe fn GetPAT(&self) -> ::windows::core::Result<IPAT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetPAT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCAT(&self, dwtimeout: u32) -> ::windows::core::Result<ICAT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetCAT)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetPMT(&self, pid: u16, pwprogramnumber: ::core::option::Option<*const u16>) -> ::windows::core::Result<IPMT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetPMT)(::windows::core::Vtable::as_raw(self), pid, ::core::mem::transmute(pwprogramnumber.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTSDT(&self) -> ::windows::core::Result<ITSDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetTSDT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetNIT(&self, tableid: u8, pwnetworkid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_NIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetNIT)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwnetworkid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetSDT(&self, tableid: u8, pwtransportstreamid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_SDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetSDT)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwtransportstreamid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEIT(&self, tableid: u8, pwserviceid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_EIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetEIT)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwserviceid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetBAT(&self, pwbouquetid: ::core::option::Option<*const u16>) -> ::windows::core::Result<IDVB_BAT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetBAT)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pwbouquetid.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetRST(&self, dwtimeout: u32) -> ::windows::core::Result<IDVB_RST> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetRST)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetST(&self, pid: u16, dwtimeout: u32) -> ::windows::core::Result<IDVB_ST> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetST)(::windows::core::Vtable::as_raw(self), pid, dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTDT(&self) -> ::windows::core::Result<IDVB_TDT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetTDT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTOT(&self) -> ::windows::core::Result<IDVB_TOT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetTOT)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetDIT(&self, dwtimeout: u32) -> ::windows::core::Result<IDVB_DIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetDIT)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetSIT(&self, dwtimeout: u32) -> ::windows::core::Result<IDVB_SIT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetSIT)(::windows::core::Vtable::as_raw(self), dwtimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEIT2(&self, tableid: u8, pwserviceid: ::core::option::Option<*const u16>, pbsegment: ::core::option::Option<*const u8>) -> ::windows::core::Result<IDVB_EIT2> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEIT2)(::windows::core::Vtable::as_raw(self), tableid, ::core::mem::transmute(pwserviceid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pbsegment.unwrap_or(::std::ptr::null())), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IIsdbTSInformationDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbTSInformationDescriptor {}
impl ::core::fmt::Debug for IIsdbTSInformationDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbTSInformationDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IIsdbTerrestrialDeliverySystemDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIsdbTerrestrialDeliverySystemDescriptor {}
impl ::core::fmt::Debug for IIsdbTerrestrialDeliverySystemDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIsdbTerrestrialDeliverySystemDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IKsNodeControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IKsNodeControl {}
impl ::core::fmt::Debug for IKsNodeControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IKsNodeControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IKsTopologyInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IKsTopologyInfo {}
impl ::core::fmt::Debug for IKsTopologyInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IKsTopologyInfo").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for ILanguageComponentType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for ILanguageComponentType {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for ILanguageComponentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILanguageComponentType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ILanguageComponentType {
    pub unsafe fn Category(&self) -> ::windows::core::Result<ComponentCategory> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCategory(&self, category: ComponentCategory) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCategory)(::windows::core::Vtable::as_raw(self), category).ok()
    }
    pub unsafe fn MediaMajorType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaMajorType(&self, mediamajortype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaMajorType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediamajortype)).ok()
    }
    pub unsafe fn _MediaMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaMajorType(&self, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MediaMajorType)(::windows::core::Vtable::as_raw(self), mediamajortypeguid).ok()
    }
    pub unsafe fn MediaSubType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaSubType(&self, mediasubtype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaSubType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediasubtype)).ok()
    }
    pub unsafe fn _MediaSubType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaSubType(&self, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MediaSubType)(::windows::core::Vtable::as_raw(self), mediasubtypeguid).ok()
    }
    pub unsafe fn MediaFormatType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaFormatType(&self, mediaformattype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaFormatType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediaformattype)).ok()
    }
    pub unsafe fn _MediaFormatType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaFormatType(&self, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MediaFormatType)(::windows::core::Vtable::as_raw(self), mediaformattypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn MediaType(&self) -> ::windows::core::Result<super::MediaFoundation::AM_MEDIA_TYPE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MediaType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn SetMediaType(&self, mediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaType)(::windows::core::Vtable::as_raw(self), mediatype).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IComponentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for ILocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for ILocator {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for ILocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILocator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMPEG2Component {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMPEG2Component {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMPEG2Component {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2Component").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2Component {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Type(&self) -> ::windows::core::Result<IComponentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Type)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetType<P0>(&self, ct: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentType>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetType)(::windows::core::Vtable::as_raw(self), ct.into().abi()).ok()
    }
    pub unsafe fn DescLangID(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DescLangID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDescLangID(&self, langid: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDescLangID)(::windows::core::Vtable::as_raw(self), langid).ok()
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<ComponentStatus> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetStatus(&self, status: ComponentStatus) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetStatus)(::windows::core::Vtable::as_raw(self), status).ok()
    }
    pub unsafe fn Description(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Description)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDescription(&self, description: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDescription)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(description)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IComponent> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMPEG2ComponentType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMPEG2ComponentType {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMPEG2ComponentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2ComponentType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2ComponentType {
    pub unsafe fn Category(&self) -> ::windows::core::Result<ComponentCategory> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCategory(&self, category: ComponentCategory) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCategory)(::windows::core::Vtable::as_raw(self), category).ok()
    }
    pub unsafe fn MediaMajorType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaMajorType(&self, mediamajortype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetMediaMajorType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediamajortype)).ok()
    }
    pub unsafe fn _MediaMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._MediaMajorType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaMajorType(&self, mediamajortypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_MediaMajorType)(::windows::core::Vtable::as_raw(self), mediamajortypeguid).ok()
    }
    pub unsafe fn MediaSubType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaSubType(&self, mediasubtype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetMediaSubType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediasubtype)).ok()
    }
    pub unsafe fn _MediaSubType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._MediaSubType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaSubType(&self, mediasubtypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_MediaSubType)(::windows::core::Vtable::as_raw(self), mediasubtypeguid).ok()
    }
    pub unsafe fn MediaFormatType(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMediaFormatType(&self, mediaformattype: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetMediaFormatType)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(mediaformattype)).ok()
    }
    pub unsafe fn _MediaFormatType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._MediaFormatType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_MediaFormatType(&self, mediaformattypeguid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Set_MediaFormatType)(::windows::core::Vtable::as_raw(self), mediaformattypeguid).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn MediaType(&self) -> ::windows::core::Result<super::MediaFoundation::AM_MEDIA_TYPE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.MediaType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn SetMediaType(&self, mediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetMediaType)(::windows::core::Vtable::as_raw(self), mediatype).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IComponentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn LangID(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.LangID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetLangID(&self, langid: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetLangID)(::windows::core::Vtable::as_raw(self), langid).ok()
    }
}
impl ::core::cmp::PartialEq for IMPEG2PIDMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMPEG2PIDMap {}
impl ::core::fmt::Debug for IMPEG2PIDMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2PIDMap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMPEG2StreamIdMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMPEG2StreamIdMap {}
impl ::core::fmt::Debug for IMPEG2StreamIdMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2StreamIdMap").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMPEG2TuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMPEG2TuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMPEG2TuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2TuneRequest").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMPEG2TuneRequest {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Components(&self) -> ::windows::core::Result<IComponents> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Components)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Clone(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Clone)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Locator(&self) -> ::windows::core::Result<ILocator> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Locator)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetLocator<P0>(&self, locator: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ILocator>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetLocator)(::windows::core::Vtable::as_raw(self), locator.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMPEG2TuneRequestFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMPEG2TuneRequestFactory {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMPEG2TuneRequestFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2TuneRequestFactory").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMPEG2TuneRequestSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMPEG2TuneRequestSupport {}
impl ::core::fmt::Debug for IMPEG2TuneRequestSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2TuneRequestSupport").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMPEG2_TIF_CONTROL {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMPEG2_TIF_CONTROL {}
impl ::core::fmt::Debug for IMPEG2_TIF_CONTROL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMPEG2_TIF_CONTROL").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSEventBinder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSEventBinder {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSEventBinder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSEventBinder").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAnalogTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAnalogTuner {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAnalogTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAnalogTuner").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAnalogTuner {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Tune(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Tune)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTune<P0>(&self, ptr: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetTune)(::windows::core::Vtable::as_raw(self), ptr.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTuningSpace<P0>(&self, plts: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuningSpace>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetTuningSpace)(::windows::core::Vtable::as_raw(self), plts.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAnalogTuner2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAnalogTuner2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAnalogTuner2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAnalogTuner2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAnalogTuner2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Tune(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Tune)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTune<P0>(&self, ptr: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetTune)(::windows::core::Vtable::as_raw(self), ptr.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTuningSpace<P0>(&self, plts: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuningSpace>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetTuningSpace)(::windows::core::Vtable::as_raw(self), plts.into().abi()).ok()
    }
    pub unsafe fn Channel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Channel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetChannel(&self, channel: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetChannel)(::windows::core::Vtable::as_raw(self), channel).ok()
    }
    pub unsafe fn VideoFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.VideoFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn AudioFrequency(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AudioFrequency)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CountryCode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CountryCode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCountryCode(&self, lcc: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCountryCode)(::windows::core::Vtable::as_raw(self), lcc).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SAP(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SAP)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetSAP<P0>(&self, fsapon: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSAP)(::windows::core::Vtable::as_raw(self), fsapon.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn ChannelAvailable(&self, nchannel: i32, signalstrength: *mut i32, fsignalpresent: *mut super::super::Foundation::VARIANT_BOOL) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ChannelAvailable)(::windows::core::Vtable::as_raw(self), nchannel, signalstrength, fsignalpresent).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAnalogTunerEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAnalogTunerEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAnalogTunerEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAnalogTunerEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAnalogTunerEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuneChanged<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidTuner>>,
    {
        (::windows::core::Vtable::vtable(self).base__.TuneChanged)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAudioRenderer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAudioRenderer {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAudioRenderer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAudioRenderer").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRenderer {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAudioRendererDevices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAudioRendererDevices {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAudioRendererDevices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAudioRendererDevices").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAudioRendererEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAudioRendererEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAudioRendererEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAudioRendererEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRendererEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidAudioRendererEvent2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidAudioRendererEvent2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidAudioRendererEvent2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidAudioRendererEvent2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidAudioRendererEvent2 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidClosedCaptioning {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidClosedCaptioning {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidClosedCaptioning {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidClosedCaptioning").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidClosedCaptioning {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidClosedCaptioning2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidClosedCaptioning2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidClosedCaptioning2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidClosedCaptioning2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidClosedCaptioning2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Enable(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Enable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnable<P0>(&self, on: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetEnable)(::windows::core::Vtable::as_raw(self), on.into()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidClosedCaptioning3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidClosedCaptioning3 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidClosedCaptioning3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidClosedCaptioning3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidClosedCaptioning3 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Enable(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Enable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnable<P0>(&self, on: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetEnable)(::windows::core::Vtable::as_raw(self), on.into()).ok()
    }
    pub unsafe fn Service(&self) -> ::windows::core::Result<MSVidCCService> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Service)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetService(&self, on: MSVidCCService) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetService)(::windows::core::Vtable::as_raw(self), on).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidCompositionSegment {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidCompositionSegment {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidCompositionSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidCompositionSegment").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidCompositionSegment {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Init(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Init)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInit<P0>(&self, pinit: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetInit)(::windows::core::Vtable::as_raw(self), pinit.into().abi()).ok()
    }
    pub unsafe fn EnumFilters(&self) -> ::windows::core::Result<IEnumFilters> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumFilters)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Container(&self) -> ::windows::core::Result<IMSVidGraphSegmentContainer> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Container)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetContainer<P0>(&self, pctl: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidGraphSegmentContainer>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetContainer)(::windows::core::Vtable::as_raw(self), pctl.into().abi()).ok()
    }
    pub unsafe fn Type(&self) -> ::windows::core::Result<MSVidSegmentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Type)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Build(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Build)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PostBuild(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PostBuild)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PreRun(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PreRun)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PostRun(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PostRun)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PreStop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PreStop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PostStop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PostStop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn OnEventNotify(&self, leventcode: i32, leventparm1: isize, leventparm2: isize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnEventNotify)(::windows::core::Vtable::as_raw(self), leventcode, leventparm1, leventparm2).ok()
    }
    pub unsafe fn Decompose(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Decompose)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidCtl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidCtl {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidCtl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidCtl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidDataServices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidDataServices {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidDataServices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidDataServices").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidDataServices {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidDataServicesEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidDataServicesEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidDataServicesEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidDataServicesEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidDataServicesEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidDevice {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidDevice").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMSVidDevice2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMSVidDevice2 {}
impl ::core::fmt::Debug for IMSVidDevice2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidDevice2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidDeviceEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidDeviceEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidDeviceEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidDeviceEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidEVR {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidEVR {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidEVR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidEVR").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidEVR {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CustomCompositorClass(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CustomCompositorClass)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCustomCompositorClass(&self, compositorclsid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCustomCompositorClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(compositorclsid)).ok()
    }
    pub unsafe fn _CustomCompositorClass(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._CustomCompositorClass)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_CustomCompositorClass(&self, compositorclsid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_CustomCompositorClass)(::windows::core::Vtable::as_raw(self), compositorclsid).ok()
    }
    pub unsafe fn _CustomCompositor(&self) -> ::windows::core::Result<IVMRImageCompositor> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._CustomCompositor)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_CustomCompositor<P0>(&self, compositor: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IVMRImageCompositor>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Set_CustomCompositor)(::windows::core::Vtable::as_raw(self), compositor.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn MixerBitmap(&self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmap)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _MixerBitmap(&self) -> ::windows::core::Result<IVMRMixerBitmap> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MixerBitmap)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetMixerBitmap<P0>(&self, mixerpicturedisp: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Ole::IPictureDisp>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicturedisp.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn Set_MixerBitmap(&self, mixerpicture: *const VMRALPHABITMAP) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicture).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MixerBitmapPositionRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmapPositionRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetMixerBitmapPositionRect<P0>(&self, rdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmapPositionRect)(::windows::core::Vtable::as_raw(self), rdest.into().abi()).ok()
    }
    pub unsafe fn MixerBitmapOpacity(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmapOpacity)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMixerBitmapOpacity(&self, opacity: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmapOpacity)(::windows::core::Vtable::as_raw(self), opacity).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetupMixerBitmap<P0, P1>(&self, mixerpicturedisp: P0, opacity: i32, rdest: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Ole::IPictureDisp>>,
        P1: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetupMixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicturedisp.into().abi(), opacity, rdest.into().abi()).ok()
    }
    pub unsafe fn SourceSize(&self) -> ::windows::core::Result<SourceSizeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceSize)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceSize(&self, newsize: SourceSizeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceSize)(::windows::core::Vtable::as_raw(self), newsize).ok()
    }
    pub unsafe fn OverScan(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OverScan)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOverScan(&self, lpercent: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOverScan)(::windows::core::Vtable::as_raw(self), lpercent).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AvailableSourceRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AvailableSourceRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MaxVidRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxVidRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MinVidRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinVidRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn ClippedSourceRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ClippedSourceRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetClippedSourceRect<P0>(&self, prect: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetClippedSourceRect)(::windows::core::Vtable::as_raw(self), prect.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UsingOverlay(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UsingOverlay)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetUsingOverlay<P0>(&self, useoverlayval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetUsingOverlay)(::windows::core::Vtable::as_raw(self), useoverlayval.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn Capture(&self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Capture)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FramesPerSecond(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FramesPerSecond)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn DecimateInput(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DecimateInput)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDecimateInput<P0>(&self, pdeci: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDecimateInput)(::windows::core::Vtable::as_raw(self), pdeci.into()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidEVREvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidEVREvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidEVREvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidEVREvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidEVREvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidEncoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidEncoder {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidEncoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidEncoder").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidEncoder {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidFeature {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidFeature {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidFeature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidFeature").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFeature {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidFeatureEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidFeatureEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidFeatureEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidFeatureEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFeatureEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidFeatures {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidFeatures {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidFeatures {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidFeatures").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidFilePlayback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidFilePlayback {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidFilePlayback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidFilePlayback").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFilePlayback {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableResetOnStop(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnableResetOnStop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnableResetOnStop<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetEnableResetOnStop)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn Run(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Run)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_CanStep<P0>(&self, fbackwards: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_CanStep)(::windows::core::Vtable::as_raw(self), fbackwards.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Step(&self, lstep: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Step)(::windows::core::Vtable::as_raw(self), lstep).ok()
    }
    pub unsafe fn SetRate(&self, plrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetRate)(::windows::core::Vtable::as_raw(self), plrate).ok()
    }
    pub unsafe fn Rate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Rate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, lposition: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCurrentPosition)(::windows::core::Vtable::as_raw(self), lposition).ok()
    }
    pub unsafe fn CurrentPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPositionMode(&self, lpositionmode: PositionModeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetPositionMode)(::windows::core::Vtable::as_raw(self), lpositionmode).ok()
    }
    pub unsafe fn PositionMode(&self) -> ::windows::core::Result<PositionModeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PositionMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Length(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Length)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidFilePlayback2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidFilePlayback2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidFilePlayback2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidFilePlayback2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFilePlayback2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableResetOnStop(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnableResetOnStop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnableResetOnStop<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetEnableResetOnStop)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn Run(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Run)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_CanStep<P0>(&self, fbackwards: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_CanStep)(::windows::core::Vtable::as_raw(self), fbackwards.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Step(&self, lstep: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Step)(::windows::core::Vtable::as_raw(self), lstep).ok()
    }
    pub unsafe fn SetRate(&self, plrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetRate)(::windows::core::Vtable::as_raw(self), plrate).ok()
    }
    pub unsafe fn Rate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Rate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, lposition: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCurrentPosition)(::windows::core::Vtable::as_raw(self), lposition).ok()
    }
    pub unsafe fn CurrentPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPositionMode(&self, lpositionmode: PositionModeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPositionMode)(::windows::core::Vtable::as_raw(self), lpositionmode).ok()
    }
    pub unsafe fn PositionMode(&self) -> ::windows::core::Result<PositionModeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PositionMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Length(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Length)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FileName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFileName(&self, filename: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(filename)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidFilePlaybackEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidFilePlaybackEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidFilePlaybackEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidFilePlaybackEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidFilePlaybackEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EndOfMedia<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidPlayback>>,
    {
        (::windows::core::Vtable::vtable(self).base__.EndOfMedia)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidGenericSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidGenericSink {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidGenericSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidGenericSink").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGenericSink {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidGenericSink2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidGenericSink2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidGenericSink2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidGenericSink2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGenericSink2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSinkFilter(&self, bstrname: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSinkFilter)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(bstrname)).ok()
    }
    pub unsafe fn SinkStreams(&self) -> ::windows::core::Result<MSVidSinkStreams> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SinkStreams)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSinkStreams(&self, streams: MSVidSinkStreams) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSinkStreams)(::windows::core::Vtable::as_raw(self), streams).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidGraphSegment {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidGraphSegment {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidGraphSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidGraphSegment").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidGraphSegment {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IMSVidGraphSegmentContainer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMSVidGraphSegmentContainer {}
impl ::core::fmt::Debug for IMSVidGraphSegmentContainer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidGraphSegmentContainer").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMSVidGraphSegmentUserInput {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMSVidGraphSegmentUserInput {}
impl ::core::fmt::Debug for IMSVidGraphSegmentUserInput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidGraphSegmentUserInput").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidInputDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidInputDevice {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidInputDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidInputDevice").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidInputDevice {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidInputDeviceEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidInputDeviceEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidInputDeviceEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidInputDeviceEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidInputDevices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidInputDevices {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidInputDevices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidInputDevices").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidOutputDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidOutputDevice {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidOutputDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidOutputDevice").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidOutputDevice {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidOutputDeviceEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidOutputDeviceEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidOutputDeviceEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidOutputDeviceEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidOutputDeviceEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidOutputDevices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidOutputDevices {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidOutputDevices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidOutputDevices").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidPlayback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidPlayback {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidPlayback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidPlayback").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidPlayback {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidPlaybackEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidPlaybackEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidPlaybackEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidPlaybackEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidRect {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidRect {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidRect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidRect").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferRecordingControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferRecordingControl {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferRecordingControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferRecordingControl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSink {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSink").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSink {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSink2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSink2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSink2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSink2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSink2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn get_ContentRecorder(&self, pszfilename: &::windows::core::BSTR) -> ::windows::core::Result<IMSVidStreamBufferRecordingControl> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_ContentRecorder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(pszfilename), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn get_ReferenceRecorder(&self, pszfilename: &::windows::core::BSTR) -> ::windows::core::Result<IMSVidStreamBufferRecordingControl> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_ReferenceRecorder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(pszfilename), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SinkName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SinkName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSinkName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSinkName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn NameSetLock(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.NameSetLock)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SBESink(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SBESink)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSink3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSink3 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSink3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSink3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSink3 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn get_ContentRecorder(&self, pszfilename: &::windows::core::BSTR) -> ::windows::core::Result<IMSVidStreamBufferRecordingControl> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_ContentRecorder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(pszfilename), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn get_ReferenceRecorder(&self, pszfilename: &::windows::core::BSTR) -> ::windows::core::Result<IMSVidStreamBufferRecordingControl> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_ReferenceRecorder)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(pszfilename), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SinkName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SinkName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSinkName(&self, name: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSinkName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(name)).ok()
    }
    pub unsafe fn NameSetLock(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.NameSetLock)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SBESink(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SBESink)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn UnlockProfile(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.UnlockProfile)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSinkEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSinkEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSinkEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSinkEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSinkEvent2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSinkEvent2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSinkEvent2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSinkEvent2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent2 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
    pub unsafe fn CertificateFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CertificateFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn CertificateSuccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CertificateSuccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn WriteFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.WriteFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSinkEvent3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSinkEvent3 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSinkEvent3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSinkEvent3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent3 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
    pub unsafe fn CertificateFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.CertificateFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn CertificateSuccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.CertificateSuccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn WriteFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.WriteFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn EncryptionOn(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.EncryptionOn)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn EncryptionOff(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.EncryptionOff)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSinkEvent4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSinkEvent4 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSinkEvent4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSinkEvent4").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSinkEvent4 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
    pub unsafe fn CertificateFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CertificateFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn CertificateSuccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CertificateSuccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn WriteFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.WriteFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn EncryptionOn(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.EncryptionOn)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn EncryptionOff(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.EncryptionOff)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn LicenseChange(&self, dwprot: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.LicenseChange)(::windows::core::Vtable::as_raw(self), dwprot).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSource {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSource").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSource {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableResetOnStop(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnableResetOnStop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnableResetOnStop<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetEnableResetOnStop)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn Run(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Run)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_CanStep<P0>(&self, fbackwards: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_CanStep)(::windows::core::Vtable::as_raw(self), fbackwards.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Step(&self, lstep: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Step)(::windows::core::Vtable::as_raw(self), lstep).ok()
    }
    pub unsafe fn SetRate(&self, plrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetRate)(::windows::core::Vtable::as_raw(self), plrate).ok()
    }
    pub unsafe fn Rate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Rate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, lposition: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCurrentPosition)(::windows::core::Vtable::as_raw(self), lposition).ok()
    }
    pub unsafe fn CurrentPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPositionMode(&self, lpositionmode: PositionModeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPositionMode)(::windows::core::Vtable::as_raw(self), lpositionmode).ok()
    }
    pub unsafe fn PositionMode(&self) -> ::windows::core::Result<PositionModeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PositionMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Length(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Length)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FileName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFileName(&self, filename: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(filename)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSource2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSource2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSource2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSource2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSource2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableResetOnStop(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EnableResetOnStop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnableResetOnStop<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetEnableResetOnStop)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn Run(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Run)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_CanStep<P0>(&self, fbackwards: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.get_CanStep)(::windows::core::Vtable::as_raw(self), fbackwards.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Step(&self, lstep: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Step)(::windows::core::Vtable::as_raw(self), lstep).ok()
    }
    pub unsafe fn SetRate(&self, plrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetRate)(::windows::core::Vtable::as_raw(self), plrate).ok()
    }
    pub unsafe fn Rate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Rate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, lposition: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetCurrentPosition)(::windows::core::Vtable::as_raw(self), lposition).ok()
    }
    pub unsafe fn CurrentPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.CurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPositionMode(&self, lpositionmode: PositionModeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPositionMode)(::windows::core::Vtable::as_raw(self), lpositionmode).ok()
    }
    pub unsafe fn PositionMode(&self) -> ::windows::core::Result<PositionModeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.PositionMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Length(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Length)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FileName(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.FileName)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFileName(&self, filename: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetFileName)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(filename)).ok()
    }
    pub unsafe fn Start(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Start)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn RecordingAttribute(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.RecordingAttribute)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentRatings(&self, pensystem: *mut EnTvRat_System, penrating: *mut EnTvRat_GenericLevel, pbfenattr: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CurrentRatings)(::windows::core::Vtable::as_raw(self), pensystem, penrating, pbfenattr).ok()
    }
    pub unsafe fn MaxRatingsLevel(&self, ensystem: EnTvRat_System, enrating: EnTvRat_GenericLevel, lbfenattr: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.MaxRatingsLevel)(::windows::core::Vtable::as_raw(self), ensystem, enrating, lbfenattr).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetBlockUnrated<P0>(&self, bblock: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetBlockUnrated)(::windows::core::Vtable::as_raw(self), bblock.into()).ok()
    }
    pub unsafe fn SetUnratedDelay(&self, dwdelay: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetUnratedDelay)(::windows::core::Vtable::as_raw(self), dwdelay).ok()
    }
    pub unsafe fn SBESource(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SBESource)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSourceEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSourceEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSourceEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSourceEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EndOfMedia<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidPlayback>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.EndOfMedia)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSourceEvent2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSourceEvent2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSourceEvent2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSourceEvent2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceEvent2 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EndOfMedia<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidPlayback>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.EndOfMedia)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
    pub unsafe fn CertificateFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CertificateFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn CertificateSuccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CertificateSuccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RatingsBlocked(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RatingsBlocked)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RatingsUnblocked(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RatingsUnblocked)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RatingsChanged(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RatingsChanged)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn TimeHole(&self, streamoffsetms: i32, sizems: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.TimeHole)(::windows::core::Vtable::as_raw(self), streamoffsetms, sizems).ok()
    }
    pub unsafe fn StaleDataRead(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.StaleDataRead)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ContentBecomingStale(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ContentBecomingStale)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn StaleFileDeleted(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.StaleFileDeleted)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferSourceEvent3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferSourceEvent3 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferSourceEvent3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferSourceEvent3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferSourceEvent3 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EndOfMedia<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidPlayback>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.EndOfMedia)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
    pub unsafe fn CertificateFailure(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.CertificateFailure)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn CertificateSuccess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.CertificateSuccess)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RatingsBlocked(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.RatingsBlocked)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RatingsUnblocked(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.RatingsUnblocked)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RatingsChanged(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.RatingsChanged)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn TimeHole(&self, streamoffsetms: i32, sizems: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.TimeHole)(::windows::core::Vtable::as_raw(self), streamoffsetms, sizems).ok()
    }
    pub unsafe fn StaleDataRead(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.StaleDataRead)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ContentBecomingStale(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.ContentBecomingStale)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn StaleFileDeleted(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.StaleFileDeleted)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RateChange(&self, qwnewrate: f64, qwoldrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RateChange)(::windows::core::Vtable::as_raw(self), qwnewrate, qwoldrate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidStreamBufferV2SourceEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidStreamBufferV2SourceEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidStreamBufferV2SourceEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidStreamBufferV2SourceEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidStreamBufferV2SourceEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EndOfMedia<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidPlayback>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.EndOfMedia)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidTuner {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidTuner").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidTuner {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidTunerEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidTunerEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidTunerEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidTunerEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVMR9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVMR9 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVMR9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVMR9").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVMR9 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CustomCompositorClass(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CustomCompositorClass)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCustomCompositorClass(&self, compositorclsid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCustomCompositorClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(compositorclsid)).ok()
    }
    pub unsafe fn _CustomCompositorClass(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._CustomCompositorClass)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_CustomCompositorClass(&self, compositorclsid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_CustomCompositorClass)(::windows::core::Vtable::as_raw(self), compositorclsid).ok()
    }
    pub unsafe fn _CustomCompositor(&self) -> ::windows::core::Result<IVMRImageCompositor> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._CustomCompositor)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_CustomCompositor<P0>(&self, compositor: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IVMRImageCompositor>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Set_CustomCompositor)(::windows::core::Vtable::as_raw(self), compositor.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn MixerBitmap(&self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmap)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _MixerBitmap(&self) -> ::windows::core::Result<IVMRMixerBitmap> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MixerBitmap)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetMixerBitmap<P0>(&self, mixerpicturedisp: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Ole::IPictureDisp>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicturedisp.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn Set_MixerBitmap(&self, mixerpicture: *const VMRALPHABITMAP) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicture).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MixerBitmapPositionRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmapPositionRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetMixerBitmapPositionRect<P0>(&self, rdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmapPositionRect)(::windows::core::Vtable::as_raw(self), rdest.into().abi()).ok()
    }
    pub unsafe fn MixerBitmapOpacity(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmapOpacity)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMixerBitmapOpacity(&self, opacity: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmapOpacity)(::windows::core::Vtable::as_raw(self), opacity).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetupMixerBitmap<P0, P1>(&self, mixerpicturedisp: P0, opacity: i32, rdest: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Ole::IPictureDisp>>,
        P1: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetupMixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicturedisp.into().abi(), opacity, rdest.into().abi()).ok()
    }
    pub unsafe fn SourceSize(&self) -> ::windows::core::Result<SourceSizeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceSize)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceSize(&self, newsize: SourceSizeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceSize)(::windows::core::Vtable::as_raw(self), newsize).ok()
    }
    pub unsafe fn OverScan(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OverScan)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOverScan(&self, lpercent: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOverScan)(::windows::core::Vtable::as_raw(self), lpercent).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AvailableSourceRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AvailableSourceRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MaxVidRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxVidRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MinVidRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinVidRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn ClippedSourceRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ClippedSourceRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetClippedSourceRect<P0>(&self, prect: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetClippedSourceRect)(::windows::core::Vtable::as_raw(self), prect.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UsingOverlay(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UsingOverlay)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetUsingOverlay<P0>(&self, useoverlayval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetUsingOverlay)(::windows::core::Vtable::as_raw(self), useoverlayval.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn Capture(&self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Capture)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FramesPerSecond(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FramesPerSecond)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn DecimateInput(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DecimateInput)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDecimateInput<P0>(&self, pdeci: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDecimateInput)(::windows::core::Vtable::as_raw(self), pdeci.into()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVRGraphSegment {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVRGraphSegment {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVRGraphSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVRGraphSegment").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVRGraphSegment {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Init(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Init)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetInit<P0>(&self, pinit: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::IUnknown>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetInit)(::windows::core::Vtable::as_raw(self), pinit.into().abi()).ok()
    }
    pub unsafe fn EnumFilters(&self) -> ::windows::core::Result<IEnumFilters> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumFilters)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Container(&self) -> ::windows::core::Result<IMSVidGraphSegmentContainer> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Container)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetContainer<P0>(&self, pctl: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidGraphSegmentContainer>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetContainer)(::windows::core::Vtable::as_raw(self), pctl.into().abi()).ok()
    }
    pub unsafe fn Type(&self) -> ::windows::core::Result<MSVidSegmentType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Type)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Build(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Build)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PostBuild(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PostBuild)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PreRun(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PreRun)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PostRun(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PostRun)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PreStop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PreStop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PostStop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PostStop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn OnEventNotify(&self, leventcode: i32, leventparm1: isize, leventparm2: isize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnEventNotify)(::windows::core::Vtable::as_raw(self), leventcode, leventparm1, leventparm2).ok()
    }
    pub unsafe fn Decompose(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Decompose)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVideoInputDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVideoInputDevice {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVideoInputDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVideoInputDevice").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoInputDevice {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVideoRenderer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVideoRenderer {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVideoRenderer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVideoRenderer").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRenderer {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVideoRenderer2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVideoRenderer2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVideoRenderer2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVideoRenderer2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRenderer2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CustomCompositorClass(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CustomCompositorClass)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCustomCompositorClass(&self, compositorclsid: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCustomCompositorClass)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(compositorclsid)).ok()
    }
    pub unsafe fn _CustomCompositorClass(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._CustomCompositorClass)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_CustomCompositorClass(&self, compositorclsid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_CustomCompositorClass)(::windows::core::Vtable::as_raw(self), compositorclsid).ok()
    }
    pub unsafe fn _CustomCompositor(&self) -> ::windows::core::Result<IVMRImageCompositor> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._CustomCompositor)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Set_CustomCompositor<P0>(&self, compositor: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IVMRImageCompositor>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Set_CustomCompositor)(::windows::core::Vtable::as_raw(self), compositor.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn MixerBitmap(&self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmap)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _MixerBitmap(&self) -> ::windows::core::Result<IVMRMixerBitmap> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__._MixerBitmap)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetMixerBitmap<P0>(&self, mixerpicturedisp: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Ole::IPictureDisp>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicturedisp.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn Set_MixerBitmap(&self, mixerpicture: *const VMRALPHABITMAP) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Set_MixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicture).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MixerBitmapPositionRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmapPositionRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetMixerBitmapPositionRect<P0>(&self, rdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmapPositionRect)(::windows::core::Vtable::as_raw(self), rdest.into().abi()).ok()
    }
    pub unsafe fn MixerBitmapOpacity(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MixerBitmapOpacity)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMixerBitmapOpacity(&self, opacity: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMixerBitmapOpacity)(::windows::core::Vtable::as_raw(self), opacity).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetupMixerBitmap<P0, P1>(&self, mixerpicturedisp: P0, opacity: i32, rdest: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::super::System::Ole::IPictureDisp>>,
        P1: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetupMixerBitmap)(::windows::core::Vtable::as_raw(self), mixerpicturedisp.into().abi(), opacity, rdest.into().abi()).ok()
    }
    pub unsafe fn SourceSize(&self) -> ::windows::core::Result<SourceSizeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SourceSize)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSourceSize(&self, newsize: SourceSizeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSourceSize)(::windows::core::Vtable::as_raw(self), newsize).ok()
    }
    pub unsafe fn OverScan(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.OverScan)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetOverScan(&self, lpercent: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetOverScan)(::windows::core::Vtable::as_raw(self), lpercent).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn AvailableSourceRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AvailableSourceRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MaxVidRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MaxVidRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn MinVidRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.MinVidRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn ClippedSourceRect(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ClippedSourceRect)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetClippedSourceRect<P0>(&self, prect: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetClippedSourceRect)(::windows::core::Vtable::as_raw(self), prect.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UsingOverlay(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UsingOverlay)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetUsingOverlay<P0>(&self, useoverlayval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetUsingOverlay)(::windows::core::Vtable::as_raw(self), useoverlayval.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn Capture(&self) -> ::windows::core::Result<super::super::System::Ole::IPictureDisp> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Capture)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FramesPerSecond(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FramesPerSecond)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn DecimateInput(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DecimateInput)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDecimateInput<P0>(&self, pdeci: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDecimateInput)(::windows::core::Vtable::as_raw(self), pdeci.into()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVideoRendererDevices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVideoRendererDevices {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVideoRendererDevices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVideoRendererDevices").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVideoRendererEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVideoRendererEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVideoRendererEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVideoRendererEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRendererEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidVideoRendererEvent2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidVideoRendererEvent2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidVideoRendererEvent2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidVideoRendererEvent2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidVideoRendererEvent2 {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidWebDVD {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidWebDVD {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidWebDVD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidWebDVD").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVD {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableResetOnStop(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnableResetOnStop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnableResetOnStop<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetEnableResetOnStop)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn Run(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Run)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_CanStep<P0>(&self, fbackwards: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_CanStep)(::windows::core::Vtable::as_raw(self), fbackwards.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Step(&self, lstep: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Step)(::windows::core::Vtable::as_raw(self), lstep).ok()
    }
    pub unsafe fn SetRate(&self, plrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetRate)(::windows::core::Vtable::as_raw(self), plrate).ok()
    }
    pub unsafe fn Rate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Rate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, lposition: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCurrentPosition)(::windows::core::Vtable::as_raw(self), lposition).ok()
    }
    pub unsafe fn CurrentPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPositionMode(&self, lpositionmode: PositionModeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetPositionMode)(::windows::core::Vtable::as_raw(self), lpositionmode).ok()
    }
    pub unsafe fn PositionMode(&self) -> ::windows::core::Result<PositionModeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PositionMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Length(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Length)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidWebDVD2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidWebDVD2 {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidWebDVD2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidWebDVD2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVD2 {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn IsViewable(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.IsViewable)(::windows::core::Vtable::as_raw(self), v, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn View(&self, v: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.base__.View)(::windows::core::Vtable::as_raw(self), v).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableResetOnStop(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnableResetOnStop)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetEnableResetOnStop<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetEnableResetOnStop)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn Run(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Run)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_CanStep<P0>(&self, fbackwards: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.get_CanStep)(::windows::core::Vtable::as_raw(self), fbackwards.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Step(&self, lstep: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Step)(::windows::core::Vtable::as_raw(self), lstep).ok()
    }
    pub unsafe fn SetRate(&self, plrate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetRate)(::windows::core::Vtable::as_raw(self), plrate).ok()
    }
    pub unsafe fn Rate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Rate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, lposition: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetCurrentPosition)(::windows::core::Vtable::as_raw(self), lposition).ok()
    }
    pub unsafe fn CurrentPosition(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetPositionMode(&self, lpositionmode: PositionModeList) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPositionMode)(::windows::core::Vtable::as_raw(self), lpositionmode).ok()
    }
    pub unsafe fn PositionMode(&self) -> ::windows::core::Result<PositionModeList> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PositionMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Length(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Length)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn OnDVDEvent(&self, levent: i32, lparam1: isize, lparam2: isize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnDVDEvent)(::windows::core::Vtable::as_raw(self), levent, lparam1, lparam2).ok()
    }
    pub unsafe fn PlayTitle(&self, ltitle: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayTitle)(::windows::core::Vtable::as_raw(self), ltitle).ok()
    }
    pub unsafe fn PlayChapterInTitle(&self, ltitle: i32, lchapter: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayChapterInTitle)(::windows::core::Vtable::as_raw(self), ltitle, lchapter).ok()
    }
    pub unsafe fn PlayChapter(&self, lchapter: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayChapter)(::windows::core::Vtable::as_raw(self), lchapter).ok()
    }
    pub unsafe fn PlayChaptersAutoStop(&self, ltitle: i32, lstrchapter: i32, lchaptercount: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayChaptersAutoStop)(::windows::core::Vtable::as_raw(self), ltitle, lstrchapter, lchaptercount).ok()
    }
    pub unsafe fn PlayAtTime(&self, strtime: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayAtTime)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(strtime)).ok()
    }
    pub unsafe fn PlayAtTimeInTitle(&self, ltitle: i32, strtime: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayAtTimeInTitle)(::windows::core::Vtable::as_raw(self), ltitle, ::core::mem::transmute_copy(strtime)).ok()
    }
    pub unsafe fn PlayPeriodInTitleAutoStop(&self, ltitle: i32, strstarttime: &::windows::core::BSTR, strendtime: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayPeriodInTitleAutoStop)(::windows::core::Vtable::as_raw(self), ltitle, ::core::mem::transmute_copy(strstarttime), ::core::mem::transmute_copy(strendtime)).ok()
    }
    pub unsafe fn ReplayChapter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ReplayChapter)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PlayPrevChapter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayPrevChapter)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn PlayNextChapter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.PlayNextChapter)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn StillOff(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.StillOff)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn get_AudioLanguage<P0>(&self, lstream: i32, fformat: P0) -> ::windows::core::Result<::windows::core::BSTR>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_AudioLanguage)(::windows::core::Vtable::as_raw(self), lstream, fformat.into(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ShowMenu(&self, menuid: DVDMenuIDConstants) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ShowMenu)(::windows::core::Vtable::as_raw(self), menuid).ok()
    }
    pub unsafe fn Resume(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Resume)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ReturnFromSubmenu(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ReturnFromSubmenu)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ButtonsAvailable(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.ButtonsAvailable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentButton(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentButton)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SelectAndActivateButton(&self, lbutton: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectAndActivateButton)(::windows::core::Vtable::as_raw(self), lbutton).ok()
    }
    pub unsafe fn ActivateButton(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ActivateButton)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SelectRightButton(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectRightButton)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SelectLeftButton(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectLeftButton)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SelectLowerButton(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectLowerButton)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SelectUpperButton(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectUpperButton)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ActivateAtPosition(&self, xpos: i32, ypos: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ActivateAtPosition)(::windows::core::Vtable::as_raw(self), xpos, ypos).ok()
    }
    pub unsafe fn SelectAtPosition(&self, xpos: i32, ypos: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectAtPosition)(::windows::core::Vtable::as_raw(self), xpos, ypos).ok()
    }
    pub unsafe fn get_ButtonAtPosition(&self, xpos: i32, ypos: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_ButtonAtPosition)(::windows::core::Vtable::as_raw(self), xpos, ypos, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_NumberOfChapters(&self, ltitle: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_NumberOfChapters)(::windows::core::Vtable::as_raw(self), ltitle, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn TotalTitleTime(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TotalTitleTime)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn TitlesAvailable(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TitlesAvailable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn VolumesAvailable(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.VolumesAvailable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentVolume(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentVolume)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentDiscSide(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentDiscSide)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentDomain(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentDomain)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentChapter(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentChapter)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentTitle(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentTitle)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentTime(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentTime)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DVDTimeCode2bstr(&self, timecode: i32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DVDTimeCode2bstr)(::windows::core::Vtable::as_raw(self), timecode, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DVDDirectory(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DVDDirectory)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDVDDirectory(&self, newval: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDVDDirectory)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute_copy(newval)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsSubpictureStreamEnabled(&self, lstream: i32) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsSubpictureStreamEnabled)(::windows::core::Vtable::as_raw(self), lstream, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsAudioStreamEnabled(&self, lstream: i32) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.IsAudioStreamEnabled)(::windows::core::Vtable::as_raw(self), lstream, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentSubpictureStream(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentSubpictureStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentSubpictureStream(&self, newval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCurrentSubpictureStream)(::windows::core::Vtable::as_raw(self), newval).ok()
    }
    pub unsafe fn get_SubpictureLanguage(&self, lstream: i32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_SubpictureLanguage)(::windows::core::Vtable::as_raw(self), lstream, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentAudioStream(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentAudioStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentAudioStream(&self, newval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCurrentAudioStream)(::windows::core::Vtable::as_raw(self), newval).ok()
    }
    pub unsafe fn AudioStreamsAvailable(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AudioStreamsAvailable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn AnglesAvailable(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.AnglesAvailable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CurrentAngle(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CurrentAngle)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetCurrentAngle(&self, newval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetCurrentAngle)(::windows::core::Vtable::as_raw(self), newval).ok()
    }
    pub unsafe fn SubpictureStreamsAvailable(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SubpictureStreamsAvailable)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SubpictureOn(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SubpictureOn)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetSubpictureOn<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSubpictureOn)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn DVDUniqueID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DVDUniqueID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn AcceptParentalLevelChange<P0>(&self, faccept: P0, strusername: &::windows::core::BSTR, strpassword: &::windows::core::BSTR) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.AcceptParentalLevelChange)(::windows::core::Vtable::as_raw(self), faccept.into(), ::core::mem::transmute_copy(strusername), ::core::mem::transmute_copy(strpassword)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn NotifyParentalLevelChange<P0>(&self, newval: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.NotifyParentalLevelChange)(::windows::core::Vtable::as_raw(self), newval.into()).ok()
    }
    pub unsafe fn SelectParentalCountry(&self, lcountry: i32, strusername: &::windows::core::BSTR, strpassword: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectParentalCountry)(::windows::core::Vtable::as_raw(self), lcountry, ::core::mem::transmute_copy(strusername), ::core::mem::transmute_copy(strpassword)).ok()
    }
    pub unsafe fn SelectParentalLevel(&self, lparentallevel: i32, strusername: &::windows::core::BSTR, strpassword: &::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectParentalLevel)(::windows::core::Vtable::as_raw(self), lparentallevel, ::core::mem::transmute_copy(strusername), ::core::mem::transmute_copy(strpassword)).ok()
    }
    pub unsafe fn get_TitleParentalLevels(&self, ltitle: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_TitleParentalLevels)(::windows::core::Vtable::as_raw(self), ltitle, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn PlayerParentalCountry(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PlayerParentalCountry)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn PlayerParentalLevel(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PlayerParentalLevel)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Eject(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Eject)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UOPValid(&self, luop: i32) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.UOPValid)(::windows::core::Vtable::as_raw(self), luop, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_SPRM(&self, lindex: i32) -> ::windows::core::Result<i16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_SPRM)(::windows::core::Vtable::as_raw(self), lindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_GPRM(&self, lindex: i32) -> ::windows::core::Result<i16> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_GPRM)(::windows::core::Vtable::as_raw(self), lindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn put_GPRM(&self, lindex: i32, svalue: i16) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.put_GPRM)(::windows::core::Vtable::as_raw(self), lindex, svalue).ok()
    }
    pub unsafe fn get_DVDTextStringType(&self, llangindex: i32, lstringindex: i32) -> ::windows::core::Result<DVDTextStringType> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_DVDTextStringType)(::windows::core::Vtable::as_raw(self), llangindex, lstringindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_DVDTextString(&self, llangindex: i32, lstringindex: i32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_DVDTextString)(::windows::core::Vtable::as_raw(self), llangindex, lstringindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_DVDTextNumberOfStrings(&self, llangindex: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_DVDTextNumberOfStrings)(::windows::core::Vtable::as_raw(self), llangindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DVDTextNumberOfLanguages(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DVDTextNumberOfLanguages)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_DVDTextLanguageLCID(&self, llangindex: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_DVDTextLanguageLCID)(::windows::core::Vtable::as_raw(self), llangindex, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn RegionChange(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RegionChange)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DVDAdm(&self) -> ::windows::core::Result<super::super::System::Com::IDispatch> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DVDAdm)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DeleteBookmark(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.DeleteBookmark)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn RestoreBookmark(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RestoreBookmark)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SaveBookmark(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SaveBookmark)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SelectDefaultAudioLanguage(&self, lang: i32, ext: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectDefaultAudioLanguage)(::windows::core::Vtable::as_raw(self), lang, ext).ok()
    }
    pub unsafe fn SelectDefaultSubpictureLanguage(&self, lang: i32, ext: DVDSPExt) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SelectDefaultSubpictureLanguage)(::windows::core::Vtable::as_raw(self), lang, ext).ok()
    }
    pub unsafe fn PreferredSubpictureStream(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PreferredSubpictureStream)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DefaultMenuLanguage(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultMenuLanguage)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDefaultMenuLanguage(&self, lang: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDefaultMenuLanguage)(::windows::core::Vtable::as_raw(self), lang).ok()
    }
    pub unsafe fn DefaultSubpictureLanguage(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultSubpictureLanguage)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DefaultAudioLanguage(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultAudioLanguage)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DefaultSubpictureLanguageExt(&self) -> ::windows::core::Result<DVDSPExt> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultSubpictureLanguageExt)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn DefaultAudioLanguageExt(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DefaultAudioLanguageExt)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_LanguageFromLCID(&self, lcid: i32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_LanguageFromLCID)(::windows::core::Vtable::as_raw(self), lcid, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn KaraokeAudioPresentationMode(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.KaraokeAudioPresentationMode)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetKaraokeAudioPresentationMode(&self, newval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetKaraokeAudioPresentationMode)(::windows::core::Vtable::as_raw(self), newval).ok()
    }
    pub unsafe fn get_KaraokeChannelContent(&self, lstream: i32, lchan: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_KaraokeChannelContent)(::windows::core::Vtable::as_raw(self), lstream, lchan, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn get_KaraokeChannelAssignment(&self, lstream: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_KaraokeChannelAssignment)(::windows::core::Vtable::as_raw(self), lstream, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn RestorePreferredSettings(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RestorePreferredSettings)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn get_ButtonRect(&self, lbutton: i32) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.get_ButtonRect)(::windows::core::Vtable::as_raw(self), lbutton, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn DVDScreenInMouseCoordinates(&self) -> ::windows::core::Result<IMSVidRect> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.DVDScreenInMouseCoordinates)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetDVDScreenInMouseCoordinates<P0>(&self, prect: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidRect>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDVDScreenInMouseCoordinates)(::windows::core::Vtable::as_raw(self), prect.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidWebDVDAdm {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidWebDVDAdm {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidWebDVDAdm {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidWebDVDAdm").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidWebDVDEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidWebDVDEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidWebDVDEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidWebDVDEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidWebDVDEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn EndOfMedia<P0>(&self, lpd: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidPlayback>>,
    {
        (::windows::core::Vtable::vtable(self).base__.EndOfMedia)(::windows::core::Vtable::as_raw(self), lpd.into().abi()).ok()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidXDS {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidXDS {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidXDS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidXDS").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidXDS {
    pub unsafe fn Name(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Name)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Status(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Status)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPower<P0>(&self, power: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::VARIANT_BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPower)(::windows::core::Vtable::as_raw(self), power.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Power(&self) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Power)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Category(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ClassID(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _Category(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._Category)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn _ClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__._ClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
    pub unsafe fn IsEqualDevice<P0>(&self, device: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.IsEqualDevice)(::windows::core::Vtable::as_raw(self), device.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMSVidXDSEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMSVidXDSEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMSVidXDSEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMSVidXDSEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMSVidXDSEvent {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn StateChange<P0>(&self, lpd: P0, oldstate: i32, newstate: i32) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMSVidDevice>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.StateChange)(::windows::core::Vtable::as_raw(self), lpd.into().abi(), oldstate, newstate).ok()
    }
}
impl ::core::cmp::PartialEq for IMceBurnerControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMceBurnerControl {}
impl ::core::fmt::Debug for IMceBurnerControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMceBurnerControl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaControl {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaControl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaEvent {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaEvent").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaEventEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaEventEx {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaEventEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaEventEx").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaEventEx {
    pub unsafe fn GetEventHandle(&self) -> ::windows::core::Result<isize> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetEventHandle)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetEvent(&self, leventcode: *mut i32, lparam1: *mut isize, lparam2: *mut isize, mstimeout: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetEvent)(::windows::core::Vtable::as_raw(self), leventcode, lparam1, lparam2, mstimeout).ok()
    }
    pub unsafe fn WaitForCompletion(&self, mstimeout: i32) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.WaitForCompletion)(::windows::core::Vtable::as_raw(self), mstimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CancelDefaultHandling(&self, levcode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CancelDefaultHandling)(::windows::core::Vtable::as_raw(self), levcode).ok()
    }
    pub unsafe fn RestoreDefaultHandling(&self, levcode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RestoreDefaultHandling)(::windows::core::Vtable::as_raw(self), levcode).ok()
    }
    pub unsafe fn FreeEventParams(&self, levcode: i32, lparam1: isize, lparam2: isize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.FreeEventParams)(::windows::core::Vtable::as_raw(self), levcode, lparam1, lparam2).ok()
    }
}
impl ::core::cmp::PartialEq for IMediaEventSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaEventSink {}
impl ::core::fmt::Debug for IMediaEventSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaEventSink").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaFilter {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaFilter").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaFilter {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IMediaParamInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaParamInfo {}
impl ::core::fmt::Debug for IMediaParamInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaParamInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMediaParams {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaParams {}
impl ::core::fmt::Debug for IMediaParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaParams").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaPosition {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaPosition {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaPosition {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaPosition").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::core::cmp::PartialEq for IMediaPropertyBag {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::core::cmp::Eq for IMediaPropertyBag {}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl ::core::fmt::Debug for IMediaPropertyBag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaPropertyBag").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com_StructuredStorage")]
impl IMediaPropertyBag {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
    pub unsafe fn Read<P0, P1>(&self, pszpropname: P0, pvar: *mut super::super::System::Com::VARIANT, perrorlog: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
        P1: ::std::convert::Into<::windows::core::InParam<super::super::System::Com::IErrorLog>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Read)(::windows::core::Vtable::as_raw(self), pszpropname.into().abi(), pvar, perrorlog.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Ole"))]
    pub unsafe fn Write<P0>(&self, pszpropname: P0, pvar: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Write)(::windows::core::Vtable::as_raw(self), pszpropname.into().abi(), pvar).ok()
    }
}
impl ::core::cmp::PartialEq for IMediaSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaSample {}
impl ::core::fmt::Debug for IMediaSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaSample").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMediaSample2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaSample2 {}
impl ::core::fmt::Debug for IMediaSample2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaSample2").field(&self.0).finish()
    }
}
impl IMediaSample2 {
    pub unsafe fn GetPointer(&self) -> ::windows::core::Result<*mut u8> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetPointer)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetSize(&self) -> i32 {
        (::windows::core::Vtable::vtable(self).base__.GetSize)(::windows::core::Vtable::as_raw(self))
    }
    pub unsafe fn GetTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetTime)(::windows::core::Vtable::as_raw(self), ptimestart, ptimeend).ok()
    }
    pub unsafe fn SetTime(&self, ptimestart: ::core::option::Option<*const i64>, ptimeend: ::core::option::Option<*const i64>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetTime)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(ptimestart.unwrap_or(::std::ptr::null())), ::core::mem::transmute(ptimeend.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn IsSyncPoint(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsSyncPoint)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetSyncPoint<P0>(&self, bissyncpoint: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetSyncPoint)(::windows::core::Vtable::as_raw(self), bissyncpoint.into()).ok()
    }
    pub unsafe fn IsPreroll(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsPreroll)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPreroll<P0>(&self, bispreroll: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetPreroll)(::windows::core::Vtable::as_raw(self), bispreroll.into()).ok()
    }
    pub unsafe fn GetActualDataLength(&self) -> i32 {
        (::windows::core::Vtable::vtable(self).base__.GetActualDataLength)(::windows::core::Vtable::as_raw(self))
    }
    pub unsafe fn SetActualDataLength(&self, __midl__imediasample0000: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetActualDataLength)(::windows::core::Vtable::as_raw(self), __midl__imediasample0000).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn GetMediaType(&self) -> ::windows::core::Result<*mut super::MediaFoundation::AM_MEDIA_TYPE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMediaType)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_MediaFoundation\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_MediaFoundation"))]
    pub unsafe fn SetMediaType(&self, pmediatype: *const super::MediaFoundation::AM_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaType)(::windows::core::Vtable::as_raw(self), pmediatype).ok()
    }
    pub unsafe fn IsDiscontinuity(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsDiscontinuity)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDiscontinuity<P0>(&self, bdiscontinuity: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDiscontinuity)(::windows::core::Vtable::as_raw(self), bdiscontinuity.into()).ok()
    }
    pub unsafe fn GetMediaTime(&self, ptimestart: *mut i64, ptimeend: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetMediaTime)(::windows::core::Vtable::as_raw(self), ptimestart, ptimeend).ok()
    }
    pub unsafe fn SetMediaTime(&self, ptimestart: ::core::option::Option<*const i64>, ptimeend: ::core::option::Option<*const i64>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMediaTime)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(ptimestart.unwrap_or(::std::ptr::null())), ::core::mem::transmute(ptimeend.unwrap_or(::std::ptr::null()))).ok()
    }
}
impl ::core::cmp::PartialEq for IMediaSample2Config {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaSample2Config {}
impl ::core::fmt::Debug for IMediaSample2Config {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaSample2Config").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMediaSeeking {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaSeeking {}
impl ::core::fmt::Debug for IMediaSeeking {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaSeeking").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMediaStream {}
impl ::core::fmt::Debug for IMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaStream").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaStreamFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaStreamFilter {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaStreamFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaStreamFilter").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IMediaStreamFilter {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Stop)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Pause)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Run(&self, tstart: i64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.Run)(::windows::core::Vtable::as_raw(self), tstart).ok()
    }
    pub unsafe fn GetState(&self, dwmillisecstimeout: u32) -> ::windows::core::Result<FILTER_STATE> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetState)(::windows::core::Vtable::as_raw(self), dwmillisecstimeout, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetSyncSource<P0>(&self, pclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<super::IReferenceClock>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetSyncSource)(::windows::core::Vtable::as_raw(self), pclock.into().abi()).ok()
    }
    pub unsafe fn GetSyncSource(&self) -> ::windows::core::Result<super::IReferenceClock> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetSyncSource)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn EnumPins(&self) -> ::windows::core::Result<IEnumPins> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumPins)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn FindPin<P0>(&self, id: P0) -> ::windows::core::Result<IPin>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.FindPin)(::windows::core::Vtable::as_raw(self), id.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn QueryFilterInfo(&self, pinfo: *mut FILTER_INFO) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.QueryFilterInfo)(::windows::core::Vtable::as_raw(self), pinfo).ok()
    }
    pub unsafe fn JoinFilterGraph<P0, P1>(&self, pgraph: P0, pname: P1) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IFilterGraph>>,
        P1: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.JoinFilterGraph)(::windows::core::Vtable::as_raw(self), pgraph.into().abi(), pname.into().abi()).ok()
    }
    pub unsafe fn QueryVendorInfo(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.QueryVendorInfo)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IMediaTypeInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IMediaTypeInfo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IMediaTypeInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMediaTypeInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMemAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMemAllocator {}
impl ::core::fmt::Debug for IMemAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMemAllocator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMemAllocatorCallbackTemp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMemAllocatorCallbackTemp {}
impl ::core::fmt::Debug for IMemAllocatorCallbackTemp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMemAllocatorCallbackTemp").field(&self.0).finish()
    }
}
impl IMemAllocatorCallbackTemp {
    pub unsafe fn SetProperties(&self, prequest: *const ALLOCATOR_PROPERTIES) -> ::windows::core::Result<ALLOCATOR_PROPERTIES> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SetProperties)(::windows::core::Vtable::as_raw(self), prequest, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetProperties(&self) -> ::windows::core::Result<ALLOCATOR_PROPERTIES> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetProperties)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn Commit(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Commit)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn Decommit(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.Decommit)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn GetBuffer(&self, ppbuffer: *mut ::core::option::Option<IMediaSample>, pstarttime: ::core::option::Option<*const i64>, pendtime: ::core::option::Option<*const i64>, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetBuffer)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(ppbuffer), ::core::mem::transmute(pstarttime.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pendtime.unwrap_or(::std::ptr::null())), dwflags).ok()
    }
    pub unsafe fn ReleaseBuffer<P0>(&self, pbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IMediaSample>>,
    {
        (::windows::core::Vtable::vtable(self).base__.ReleaseBuffer)(::windows::core::Vtable::as_raw(self), pbuffer.into().abi()).ok()
    }
}
impl ::core::cmp::PartialEq for IMemAllocatorNotifyCallbackTemp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMemAllocatorNotifyCallbackTemp {}
impl ::core::fmt::Debug for IMemAllocatorNotifyCallbackTemp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMemAllocatorNotifyCallbackTemp").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMemInputPin {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMemInputPin {}
impl ::core::fmt::Debug for IMemInputPin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMemInputPin").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMemoryData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMemoryData {}
impl ::core::fmt::Debug for IMemoryData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMemoryData").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMixerOCX {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMixerOCX {}
impl ::core::fmt::Debug for IMixerOCX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMixerOCX").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMixerOCXNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMixerOCXNotify {}
impl ::core::fmt::Debug for IMixerOCXNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMixerOCXNotify").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMixerPinConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMixerPinConfig {}
impl ::core::fmt::Debug for IMixerPinConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMixerPinConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMixerPinConfig2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMixerPinConfig2 {}
impl ::core::fmt::Debug for IMixerPinConfig2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMixerPinConfig2").field(&self.0).finish()
    }
}
impl IMixerPinConfig2 {
    pub unsafe fn SetRelativePosition(&self, dwleft: u32, dwtop: u32, dwright: u32, dwbottom: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetRelativePosition)(::windows::core::Vtable::as_raw(self), dwleft, dwtop, dwright, dwbottom).ok()
    }
    pub unsafe fn GetRelativePosition(&self, pdwleft: *mut u32, pdwtop: *mut u32, pdwright: *mut u32, pdwbottom: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetRelativePosition)(::windows::core::Vtable::as_raw(self), pdwleft, pdwtop, pdwright, pdwbottom).ok()
    }
    pub unsafe fn SetZOrder(&self, dwzorder: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetZOrder)(::windows::core::Vtable::as_raw(self), dwzorder).ok()
    }
    pub unsafe fn GetZOrder(&self, pdwzorder: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetZOrder)(::windows::core::Vtable::as_raw(self), pdwzorder).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetColorKey(&self, pcolorkey: *mut COLORKEY) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetColorKey)(::windows::core::Vtable::as_raw(self), pcolorkey).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetColorKey(&self, pcolorkey: *mut COLORKEY, pcolor: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetColorKey)(::windows::core::Vtable::as_raw(self), pcolorkey, pcolor).ok()
    }
    pub unsafe fn SetBlendingParameter(&self, dwblendingparameter: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetBlendingParameter)(::windows::core::Vtable::as_raw(self), dwblendingparameter).ok()
    }
    pub unsafe fn GetBlendingParameter(&self, pdwblendingparameter: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetBlendingParameter)(::windows::core::Vtable::as_raw(self), pdwblendingparameter).ok()
    }
    pub unsafe fn SetAspectRatioMode(&self, amaspectratiomode: AM_ASPECT_RATIO_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetAspectRatioMode)(::windows::core::Vtable::as_raw(self), amaspectratiomode).ok()
    }
    pub unsafe fn GetAspectRatioMode(&self, pamaspectratiomode: *mut AM_ASPECT_RATIO_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetAspectRatioMode)(::windows::core::Vtable::as_raw(self), pamaspectratiomode).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetStreamTransparent<P0>(&self, bstreamtransparent: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<super::super::Foundation::BOOL>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetStreamTransparent)(::windows::core::Vtable::as_raw(self), bstreamtransparent.into()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamTransparent(&self, pbstreamtransparent: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetStreamTransparent)(::windows::core::Vtable::as_raw(self), pbstreamtransparent).ok()
    }
}
impl ::core::cmp::PartialEq for IMpeg2Data {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMpeg2Data {}
impl ::core::fmt::Debug for IMpeg2Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMpeg2Data").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMpeg2Demultiplexer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMpeg2Demultiplexer {}
impl ::core::fmt::Debug for IMpeg2Demultiplexer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMpeg2Demultiplexer").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMpeg2Stream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMpeg2Stream {}
impl ::core::fmt::Debug for IMpeg2Stream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMpeg2Stream").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMpeg2TableFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMpeg2TableFilter {}
impl ::core::fmt::Debug for IMpeg2TableFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMpeg2TableFilter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMpegAudioDecoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMpegAudioDecoder {}
impl ::core::fmt::Debug for IMpegAudioDecoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMpegAudioDecoder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IMultiMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMultiMediaStream {}
impl ::core::fmt::Debug for IMultiMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMultiMediaStream").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IOverlay {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IOverlay {}
impl ::core::fmt::Debug for IOverlay {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOverlay").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IOverlayNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IOverlayNotify {}
impl ::core::fmt::Debug for IOverlayNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOverlayNotify").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IOverlayNotify2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IOverlayNotify2 {}
impl ::core::fmt::Debug for IOverlayNotify2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOverlayNotify2").field(&self.0).finish()
    }
}
impl IOverlayNotify2 {
    #[doc = "*Required features: `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn OnPaletteChange(&self, dwcolors: u32, ppalette: *const super::super::Graphics::Gdi::PALETTEENTRY) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnPaletteChange)(::windows::core::Vtable::as_raw(self), dwcolors, ppalette).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn OnClipChange(&self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT, prgndata: *const super::super::Graphics::Gdi::RGNDATA) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnClipChange)(::windows::core::Vtable::as_raw(self), psourcerect, pdestinationrect, prgndata).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OnColorKeyChange(&self, pcolorkey: *const COLORKEY) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnColorKeyChange)(::windows::core::Vtable::as_raw(self), pcolorkey).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OnPositionChange(&self, psourcerect: *const super::super::Foundation::RECT, pdestinationrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.OnPositionChange)(::windows::core::Vtable::as_raw(self), psourcerect, pdestinationrect).ok()
    }
}
impl ::core::cmp::PartialEq for IPAT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPAT {}
impl ::core::fmt::Debug for IPAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPAT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPBDAAttributesDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPBDAAttributesDescriptor {}
impl ::core::fmt::Debug for IPBDAAttributesDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPBDAAttributesDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPBDAEntitlementDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPBDAEntitlementDescriptor {}
impl ::core::fmt::Debug for IPBDAEntitlementDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPBDAEntitlementDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPBDASiParser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPBDASiParser {}
impl ::core::fmt::Debug for IPBDASiParser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPBDASiParser").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPBDA_EIT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPBDA_EIT {}
impl ::core::fmt::Debug for IPBDA_EIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPBDA_EIT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPBDA_Services {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPBDA_Services {}
impl ::core::fmt::Debug for IPBDA_Services {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPBDA_Services").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPMT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPMT {}
impl ::core::fmt::Debug for IPMT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPMT").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPSITables {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPSITables {}
impl ::core::fmt::Debug for IPSITables {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPSITables").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPTFilterLicenseRenewal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPTFilterLicenseRenewal {}
impl ::core::fmt::Debug for IPTFilterLicenseRenewal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPTFilterLicenseRenewal").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IPersistMediaPropertyBag {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IPersistMediaPropertyBag {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IPersistMediaPropertyBag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistMediaPropertyBag").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IPersistMediaPropertyBag {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IPersistTuneXml {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IPersistTuneXml {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IPersistTuneXml {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistTuneXml").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl IPersistTuneXml {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetClassID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetClassID)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IPersistTuneXmlUtility {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPersistTuneXmlUtility {}
impl ::core::fmt::Debug for IPersistTuneXmlUtility {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistTuneXmlUtility").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPersistTuneXmlUtility2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPersistTuneXmlUtility2 {}
impl ::core::fmt::Debug for IPersistTuneXmlUtility2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistTuneXmlUtility2").field(&self.0).finish()
    }
}
impl IPersistTuneXmlUtility2 {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn Deserialize(&self, varvalue: super::super::System::Com::VARIANT) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.Deserialize)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(varvalue), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IPin {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPin {}
impl ::core::fmt::Debug for IPin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPin").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPinConnection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPinConnection {}
impl ::core::fmt::Debug for IPinConnection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPinConnection").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IPinFlowControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPinFlowControl {}
impl ::core::fmt::Debug for IPinFlowControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPinFlowControl").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IPinInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IPinInfo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IPinInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPinInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IQualProp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQualProp {}
impl ::core::fmt::Debug for IQualProp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQualProp").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IQualityControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQualityControl {}
impl ::core::fmt::Debug for IQualityControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQualityControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IQueueCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueueCommand {}
impl ::core::fmt::Debug for IQueueCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueueCommand").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IRegFilterInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IRegFilterInfo {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IRegFilterInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRegFilterInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IRegisterServiceProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IRegisterServiceProvider {}
impl ::core::fmt::Debug for IRegisterServiceProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRegisterServiceProvider").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IRegisterTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IRegisterTuner {}
impl ::core::fmt::Debug for IRegisterTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRegisterTuner").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IResourceConsumer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IResourceConsumer {}
impl ::core::fmt::Debug for IResourceConsumer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IResourceConsumer").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IResourceManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IResourceManager {}
impl ::core::fmt::Debug for IResourceManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IResourceManager").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2Crossbar {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2Crossbar {}
impl ::core::fmt::Debug for ISBE2Crossbar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2Crossbar").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2EnumStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2EnumStream {}
impl ::core::fmt::Debug for ISBE2EnumStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2EnumStream").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2FileScan {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2FileScan {}
impl ::core::fmt::Debug for ISBE2FileScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2FileScan").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2GlobalEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2GlobalEvent {}
impl ::core::fmt::Debug for ISBE2GlobalEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2GlobalEvent").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2GlobalEvent2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2GlobalEvent2 {}
impl ::core::fmt::Debug for ISBE2GlobalEvent2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2GlobalEvent2").field(&self.0).finish()
    }
}
impl ISBE2GlobalEvent2 {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetEvent(&self, idevt: *const ::windows::core::GUID, param1: u32, param2: u32, param3: u32, param4: u32, pspanning: *mut super::super::Foundation::BOOL, pcb: *mut u32, pb: *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetEvent)(::windows::core::Vtable::as_raw(self), idevt, param1, param2, param3, param4, pspanning, pcb, pb).ok()
    }
}
impl ::core::cmp::PartialEq for ISBE2MediaTypeProfile {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2MediaTypeProfile {}
impl ::core::fmt::Debug for ISBE2MediaTypeProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2MediaTypeProfile").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2SpanningEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2SpanningEvent {}
impl ::core::fmt::Debug for ISBE2SpanningEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2SpanningEvent").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISBE2StreamMap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISBE2StreamMap {}
impl ::core::fmt::Debug for ISBE2StreamMap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISBE2StreamMap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISCTE_EAS {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISCTE_EAS {}
impl ::core::fmt::Debug for ISCTE_EAS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISCTE_EAS").field(&self.0).finish()
    }
}
impl ::core::default::Default for ISDBCAS_REQUEST_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ISDBCAS_REQUEST_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISDBCAS_REQUEST_ID").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISIInbandEPG {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISIInbandEPG {}
impl ::core::fmt::Debug for ISIInbandEPG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISIInbandEPG").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISIInbandEPGEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISIInbandEPGEvent {}
impl ::core::fmt::Debug for ISIInbandEPGEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISIInbandEPGEvent").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IScanningTuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IScanningTuner {}
impl ::core::fmt::Debug for IScanningTuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IScanningTuner").field(&self.0).finish()
    }
}
impl IScanningTuner {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTuningSpace<P0>(&self, tuningspace: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuningSpace>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetTuningSpace)(::windows::core::Vtable::as_raw(self), tuningspace.into().abi()).ok()
    }
    pub unsafe fn EnumTuningSpaces(&self) -> ::windows::core::Result<IEnumTuningSpaces> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.EnumTuningSpaces)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.TuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTuneRequest<P0>(&self, tunerequest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetTuneRequest)(::windows::core::Vtable::as_raw(self), tunerequest.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Validate<P0>(&self, tunerequest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.Validate)(::windows::core::Vtable::as_raw(self), tunerequest.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn PreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.PreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetPreferredComponentTypes<P0>(&self, componenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), componenttypes.into().abi()).ok()
    }
    pub unsafe fn SignalStrength(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.SignalStrength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn TriggerSignalEvents(&self, interval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.TriggerSignalEvents)(::windows::core::Vtable::as_raw(self), interval).ok()
    }
}
impl ::core::cmp::PartialEq for IScanningTunerEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IScanningTunerEx {}
impl ::core::fmt::Debug for IScanningTunerEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IScanningTunerEx").field(&self.0).finish()
    }
}
impl IScanningTunerEx {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuningSpace(&self) -> ::windows::core::Result<ITuningSpace> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.TuningSpace)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTuningSpace<P0>(&self, tuningspace: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuningSpace>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetTuningSpace)(::windows::core::Vtable::as_raw(self), tuningspace.into().abi()).ok()
    }
    pub unsafe fn EnumTuningSpaces(&self) -> ::windows::core::Result<IEnumTuningSpaces> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.EnumTuningSpaces)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn TuneRequest(&self) -> ::windows::core::Result<ITuneRequest> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.TuneRequest)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetTuneRequest<P0>(&self, tunerequest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetTuneRequest)(::windows::core::Vtable::as_raw(self), tunerequest.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn Validate<P0>(&self, tunerequest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.Validate)(::windows::core::Vtable::as_raw(self), tunerequest.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn PreferredComponentTypes(&self) -> ::windows::core::Result<IComponentTypes> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.PreferredComponentTypes)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetPreferredComponentTypes<P0>(&self, componenttypes: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IComponentTypes>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPreferredComponentTypes)(::windows::core::Vtable::as_raw(self), componenttypes.into().abi()).ok()
    }
    pub unsafe fn SignalStrength(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.SignalStrength)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn TriggerSignalEvents(&self, interval: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.TriggerSignalEvents)(::windows::core::Vtable::as_raw(self), interval).ok()
    }
    pub unsafe fn SeekUp(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SeekUp)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SeekDown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SeekDown)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn ScanUp(&self, millisecondspause: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ScanUp)(::windows::core::Vtable::as_raw(self), millisecondspause).ok()
    }
    pub unsafe fn ScanDown(&self, millisecondspause: i32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ScanDown)(::windows::core::Vtable::as_raw(self), millisecondspause).ok()
    }
    pub unsafe fn AutoProgram(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.AutoProgram)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for ISectionList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISectionList {}
impl ::core::fmt::Debug for ISectionList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISectionList").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISeekingPassThru {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISeekingPassThru {}
impl ::core::fmt::Debug for ISeekingPassThru {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISeekingPassThru").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISelector {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISelector {}
impl ::core::fmt::Debug for ISelector {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISelector").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IServiceLocationDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IServiceLocationDescriptor {}
impl ::core::fmt::Debug for IServiceLocationDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IServiceLocationDescriptor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ISpecifyParticularPages {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISpecifyParticularPages {}
impl ::core::fmt::Debug for ISpecifyParticularPages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISpecifyParticularPages").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferConfigure {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferConfigure {}
impl ::core::fmt::Debug for IStreamBufferConfigure {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferConfigure").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferConfigure2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferConfigure2 {}
impl ::core::fmt::Debug for IStreamBufferConfigure2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferConfigure2").field(&self.0).finish()
    }
}
impl IStreamBufferConfigure2 {
    pub unsafe fn SetDirectory<P0>(&self, pszdirectoryname: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.SetDirectory)(::windows::core::Vtable::as_raw(self), pszdirectoryname.into().abi()).ok()
    }
    pub unsafe fn GetDirectory(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetDirectory)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetBackingFileCount(&self, dwmin: u32, dwmax: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetBackingFileCount)(::windows::core::Vtable::as_raw(self), dwmin, dwmax).ok()
    }
    pub unsafe fn GetBackingFileCount(&self, pdwmin: *mut u32, pdwmax: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetBackingFileCount)(::windows::core::Vtable::as_raw(self), pdwmin, pdwmax).ok()
    }
    pub unsafe fn SetBackingFileDuration(&self, dwseconds: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetBackingFileDuration)(::windows::core::Vtable::as_raw(self), dwseconds).ok()
    }
    pub unsafe fn GetBackingFileDuration(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetBackingFileDuration)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IStreamBufferConfigure3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferConfigure3 {}
impl ::core::fmt::Debug for IStreamBufferConfigure3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferConfigure3").field(&self.0).finish()
    }
}
impl IStreamBufferConfigure3 {
    pub unsafe fn SetDirectory<P0>(&self, pszdirectoryname: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.SetDirectory)(::windows::core::Vtable::as_raw(self), pszdirectoryname.into().abi()).ok()
    }
    pub unsafe fn GetDirectory(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetDirectory)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetBackingFileCount(&self, dwmin: u32, dwmax: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetBackingFileCount)(::windows::core::Vtable::as_raw(self), dwmin, dwmax).ok()
    }
    pub unsafe fn GetBackingFileCount(&self, pdwmin: *mut u32, pdwmax: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.GetBackingFileCount)(::windows::core::Vtable::as_raw(self), pdwmin, pdwmax).ok()
    }
    pub unsafe fn SetBackingFileDuration(&self, dwseconds: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetBackingFileDuration)(::windows::core::Vtable::as_raw(self), dwseconds).ok()
    }
    pub unsafe fn GetBackingFileDuration(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetBackingFileDuration)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetMultiplexedPacketSize(&self, cbbytesperpacket: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetMultiplexedPacketSize)(::windows::core::Vtable::as_raw(self), cbbytesperpacket).ok()
    }
    pub unsafe fn GetMultiplexedPacketSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetMultiplexedPacketSize)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetFFTransitionRates(&self, dwmaxfullframerate: u32, dwmaxnonskippingrate: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetFFTransitionRates)(::windows::core::Vtable::as_raw(self), dwmaxfullframerate, dwmaxnonskippingrate).ok()
    }
    pub unsafe fn GetFFTransitionRates(&self, pdwmaxfullframerate: *mut u32, pdwmaxnonskippingrate: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetFFTransitionRates)(::windows::core::Vtable::as_raw(self), pdwmaxfullframerate, pdwmaxnonskippingrate).ok()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferDataCounters {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferDataCounters {}
impl ::core::fmt::Debug for IStreamBufferDataCounters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferDataCounters").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferInitialize {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferInitialize {}
impl ::core::fmt::Debug for IStreamBufferInitialize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferInitialize").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferMediaSeeking {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferMediaSeeking {}
impl ::core::fmt::Debug for IStreamBufferMediaSeeking {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferMediaSeeking").field(&self.0).finish()
    }
}
impl IStreamBufferMediaSeeking {
    pub unsafe fn GetCapabilities(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCapabilities)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CheckCapabilities(&self, pcapabilities: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.CheckCapabilities)(::windows::core::Vtable::as_raw(self), pcapabilities).ok()
    }
    pub unsafe fn IsFormatSupported(&self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsFormatSupported)(::windows::core::Vtable::as_raw(self), pformat).ok()
    }
    pub unsafe fn QueryPreferredFormat(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.QueryPreferredFormat)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTimeFormat(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetTimeFormat)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn IsUsingTimeFormat(&self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsUsingTimeFormat)(::windows::core::Vtable::as_raw(self), pformat).ok()
    }
    pub unsafe fn SetTimeFormat(&self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetTimeFormat)(::windows::core::Vtable::as_raw(self), pformat).ok()
    }
    pub unsafe fn GetDuration(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetDuration)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStopPosition(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetStopPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCurrentPosition(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetCurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ConvertTimeFormat(&self, ptarget: *mut i64, ptargetformat: ::core::option::Option<*const ::windows::core::GUID>, source: i64, psourceformat: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.ConvertTimeFormat)(::windows::core::Vtable::as_raw(self), ptarget, ::core::mem::transmute(ptargetformat.unwrap_or(::std::ptr::null())), source, ::core::mem::transmute(psourceformat.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetPositions(&self, pcurrent: ::core::option::Option<*mut i64>, dwcurrentflags: u32, pstop: ::core::option::Option<*mut i64>, dwstopflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetPositions)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pcurrent.unwrap_or(::std::ptr::null_mut())), dwcurrentflags, ::core::mem::transmute(pstop.unwrap_or(::std::ptr::null_mut())), dwstopflags).ok()
    }
    pub unsafe fn GetPositions(&self, pcurrent: ::core::option::Option<*mut i64>, pstop: ::core::option::Option<*mut i64>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetPositions)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pcurrent.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pstop.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAvailable(&self, pearliest: ::core::option::Option<*mut i64>, platest: ::core::option::Option<*mut i64>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetAvailable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pearliest.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(platest.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetRate(&self, drate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetRate)(::windows::core::Vtable::as_raw(self), drate).ok()
    }
    pub unsafe fn GetRate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetPreroll(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetPreroll)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IStreamBufferMediaSeeking2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferMediaSeeking2 {}
impl ::core::fmt::Debug for IStreamBufferMediaSeeking2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferMediaSeeking2").field(&self.0).finish()
    }
}
impl IStreamBufferMediaSeeking2 {
    pub unsafe fn GetCapabilities(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetCapabilities)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn CheckCapabilities(&self, pcapabilities: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.CheckCapabilities)(::windows::core::Vtable::as_raw(self), pcapabilities).ok()
    }
    pub unsafe fn IsFormatSupported(&self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.IsFormatSupported)(::windows::core::Vtable::as_raw(self), pformat).ok()
    }
    pub unsafe fn QueryPreferredFormat(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.QueryPreferredFormat)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetTimeFormat(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetTimeFormat)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn IsUsingTimeFormat(&self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.IsUsingTimeFormat)(::windows::core::Vtable::as_raw(self), pformat).ok()
    }
    pub unsafe fn SetTimeFormat(&self, pformat: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetTimeFormat)(::windows::core::Vtable::as_raw(self), pformat).ok()
    }
    pub unsafe fn GetDuration(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetDuration)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetStopPosition(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetStopPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetCurrentPosition(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetCurrentPosition)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn ConvertTimeFormat(&self, ptarget: *mut i64, ptargetformat: ::core::option::Option<*const ::windows::core::GUID>, source: i64, psourceformat: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.ConvertTimeFormat)(::windows::core::Vtable::as_raw(self), ptarget, ::core::mem::transmute(ptargetformat.unwrap_or(::std::ptr::null())), source, ::core::mem::transmute(psourceformat.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetPositions(&self, pcurrent: ::core::option::Option<*mut i64>, dwcurrentflags: u32, pstop: ::core::option::Option<*mut i64>, dwstopflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetPositions)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pcurrent.unwrap_or(::std::ptr::null_mut())), dwcurrentflags, ::core::mem::transmute(pstop.unwrap_or(::std::ptr::null_mut())), dwstopflags).ok()
    }
    pub unsafe fn GetPositions(&self, pcurrent: ::core::option::Option<*mut i64>, pstop: ::core::option::Option<*mut i64>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.GetPositions)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pcurrent.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pstop.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAvailable(&self, pearliest: ::core::option::Option<*mut i64>, platest: ::core::option::Option<*mut i64>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.GetAvailable)(::windows::core::Vtable::as_raw(self), ::core::mem::transmute(pearliest.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(platest.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetRate(&self, drate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.SetRate)(::windows::core::Vtable::as_raw(self), drate).ok()
    }
    pub unsafe fn GetRate(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetRate)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn GetPreroll(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.GetPreroll)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for IStreamBufferRecComp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferRecComp {}
impl ::core::fmt::Debug for IStreamBufferRecComp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferRecComp").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferRecordControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferRecordControl {}
impl ::core::fmt::Debug for IStreamBufferRecordControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferRecordControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferRecordingAttribute {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferRecordingAttribute {}
impl ::core::fmt::Debug for IStreamBufferRecordingAttribute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferRecordingAttribute").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferSink {}
impl ::core::fmt::Debug for IStreamBufferSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferSink").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferSink2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferSink2 {}
impl ::core::fmt::Debug for IStreamBufferSink2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferSink2").field(&self.0).finish()
    }
}
impl IStreamBufferSink2 {
    pub unsafe fn LockProfile<P0>(&self, pszstreambufferfilename: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.LockProfile)(::windows::core::Vtable::as_raw(self), pszstreambufferfilename.into().abi()).ok()
    }
    pub unsafe fn CreateRecorder<P0>(&self, pszfilename: P0, dwrecordtype: u32) -> ::windows::core::Result<::windows::core::IUnknown>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.CreateRecorder)(::windows::core::Vtable::as_raw(self), pszfilename.into().abi(), dwrecordtype, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn IsProfileLocked(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsProfileLocked)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferSink3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferSink3 {}
impl ::core::fmt::Debug for IStreamBufferSink3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferSink3").field(&self.0).finish()
    }
}
impl IStreamBufferSink3 {
    pub unsafe fn LockProfile<P0>(&self, pszstreambufferfilename: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        (::windows::core::Vtable::vtable(self).base__.base__.LockProfile)(::windows::core::Vtable::as_raw(self), pszstreambufferfilename.into().abi()).ok()
    }
    pub unsafe fn CreateRecorder<P0>(&self, pszfilename: P0, dwrecordtype: u32) -> ::windows::core::Result<::windows::core::IUnknown>
    where
        P0: ::std::convert::Into<::windows::core::InParam<::windows::core::PCWSTR>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.base__.CreateRecorder)(::windows::core::Vtable::as_raw(self), pszfilename.into().abi(), dwrecordtype, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn IsProfileLocked(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.IsProfileLocked)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn UnlockProfile(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.UnlockProfile)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IStreamBufferSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBufferSource {}
impl ::core::fmt::Debug for IStreamBufferSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBufferSource").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamBuilder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamBuilder {}
impl ::core::fmt::Debug for IStreamBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamBuilder").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IStreamSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamSample {}
impl ::core::fmt::Debug for IStreamSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamSample").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ITSDT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITSDT {}
impl ::core::fmt::Debug for ITSDT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITSDT").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for ITuneRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for ITuneRequest {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for ITuneRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuneRequest").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ITuneRequestInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITuneRequestInfo {}
impl ::core::fmt::Debug for ITuneRequestInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuneRequestInfo").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ITuneRequestInfoEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITuneRequestInfoEx {}
impl ::core::fmt::Debug for ITuneRequestInfoEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuneRequestInfoEx").field(&self.0).finish()
    }
}
impl ITuneRequestInfoEx {
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetLocatorData<P0>(&self, request: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.GetLocatorData)(::windows::core::Vtable::as_raw(self), request.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetComponentData<P0>(&self, currentrequest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.GetComponentData)(::windows::core::Vtable::as_raw(self), currentrequest.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateComponentList<P0>(&self, currentrequest: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        (::windows::core::Vtable::vtable(self).base__.CreateComponentList)(::windows::core::Vtable::as_raw(self), currentrequest.into().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetNextProgram<P0>(&self, currentrequest: P0) -> ::windows::core::Result<ITuneRequest>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetNextProgram)(::windows::core::Vtable::as_raw(self), currentrequest.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetPreviousProgram<P0>(&self, currentrequest: P0) -> ::windows::core::Result<ITuneRequest>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetPreviousProgram)(::windows::core::Vtable::as_raw(self), currentrequest.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetNextLocator<P0>(&self, currentrequest: P0) -> ::windows::core::Result<ITuneRequest>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetNextLocator)(::windows::core::Vtable::as_raw(self), currentrequest.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetPreviousLocator<P0>(&self, currentrequest: P0) -> ::windows::core::Result<ITuneRequest>
    where
        P0: ::std::convert::Into<::windows::core::InParam<ITuneRequest>>,
    {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetPreviousLocator)(::windows::core::Vtable::as_raw(self), currentrequest.into().abi(), result__.as_mut_ptr()).from_abi(result__)
    }
}
impl ::core::cmp::PartialEq for ITuner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITuner {}
impl ::core::fmt::Debug for ITuner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuner").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ITunerCap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITunerCap {}
impl ::core::fmt::Debug for ITunerCap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITunerCap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for ITunerCapEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITunerCapEx {}
impl ::core::fmt::Debug for ITunerCapEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITunerCapEx").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for ITuningSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for ITuningSpace {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for ITuningSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuningSpace").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for ITuningSpaceContainer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for ITuningSpaceContainer {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for ITuningSpaceContainer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuningSpaceContainer").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for ITuningSpaces {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for ITuningSpaces {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for ITuningSpaces {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITuningSpaces").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRAspectRatioControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRAspectRatioControl {}
impl ::core::fmt::Debug for IVMRAspectRatioControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRAspectRatioControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRAspectRatioControl9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRAspectRatioControl9 {}
impl ::core::fmt::Debug for IVMRAspectRatioControl9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRAspectRatioControl9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRDeinterlaceControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRDeinterlaceControl {}
impl ::core::fmt::Debug for IVMRDeinterlaceControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRDeinterlaceControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRDeinterlaceControl9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRDeinterlaceControl9 {}
impl ::core::fmt::Debug for IVMRDeinterlaceControl9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRDeinterlaceControl9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRFilterConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRFilterConfig {}
impl ::core::fmt::Debug for IVMRFilterConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRFilterConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRFilterConfig9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRFilterConfig9 {}
impl ::core::fmt::Debug for IVMRFilterConfig9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRFilterConfig9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImageCompositor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImageCompositor {}
impl ::core::fmt::Debug for IVMRImageCompositor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImageCompositor").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImageCompositor9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImageCompositor9 {}
impl ::core::fmt::Debug for IVMRImageCompositor9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImageCompositor9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImagePresenter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImagePresenter {}
impl ::core::fmt::Debug for IVMRImagePresenter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImagePresenter").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImagePresenter9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImagePresenter9 {}
impl ::core::fmt::Debug for IVMRImagePresenter9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImagePresenter9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImagePresenterConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImagePresenterConfig {}
impl ::core::fmt::Debug for IVMRImagePresenterConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImagePresenterConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImagePresenterConfig9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImagePresenterConfig9 {}
impl ::core::fmt::Debug for IVMRImagePresenterConfig9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImagePresenterConfig9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRImagePresenterExclModeConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRImagePresenterExclModeConfig {}
impl ::core::fmt::Debug for IVMRImagePresenterExclModeConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRImagePresenterExclModeConfig").field(&self.0).finish()
    }
}
impl IVMRImagePresenterExclModeConfig {
    pub unsafe fn SetRenderingPrefs(&self, dwrenderflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetRenderingPrefs)(::windows::core::Vtable::as_raw(self), dwrenderflags).ok()
    }
    pub unsafe fn GetRenderingPrefs(&self, dwrenderflags: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetRenderingPrefs)(::windows::core::Vtable::as_raw(self), dwrenderflags).ok()
    }
}
impl ::core::cmp::PartialEq for IVMRMixerBitmap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRMixerBitmap {}
impl ::core::fmt::Debug for IVMRMixerBitmap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRMixerBitmap").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRMixerBitmap9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRMixerBitmap9 {}
impl ::core::fmt::Debug for IVMRMixerBitmap9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRMixerBitmap9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRMixerControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRMixerControl {}
impl ::core::fmt::Debug for IVMRMixerControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRMixerControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRMixerControl9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRMixerControl9 {}
impl ::core::fmt::Debug for IVMRMixerControl9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRMixerControl9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRMonitorConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRMonitorConfig {}
impl ::core::fmt::Debug for IVMRMonitorConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRMonitorConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRMonitorConfig9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRMonitorConfig9 {}
impl ::core::fmt::Debug for IVMRMonitorConfig9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRMonitorConfig9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRSurface {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurface {}
impl ::core::fmt::Debug for IVMRSurface {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurface").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRSurface9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurface9 {}
impl ::core::fmt::Debug for IVMRSurface9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurface9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRSurfaceAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurfaceAllocator {}
impl ::core::fmt::Debug for IVMRSurfaceAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurfaceAllocator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRSurfaceAllocator9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurfaceAllocator9 {}
impl ::core::fmt::Debug for IVMRSurfaceAllocator9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurfaceAllocator9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRSurfaceAllocatorEx9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurfaceAllocatorEx9 {}
impl ::core::fmt::Debug for IVMRSurfaceAllocatorEx9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurfaceAllocatorEx9").field(&self.0).finish()
    }
}
impl IVMRSurfaceAllocatorEx9 {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn InitializeDevice(&self, dwuserid: usize, lpallocinfo: *const VMR9AllocationInfo, lpnumbuffers: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.InitializeDevice)(::windows::core::Vtable::as_raw(self), dwuserid, lpallocinfo, lpnumbuffers).ok()
    }
    pub unsafe fn TerminateDevice(&self, dwid: usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.TerminateDevice)(::windows::core::Vtable::as_raw(self), dwid).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetSurface(&self, dwuserid: usize, surfaceindex: u32, surfaceflags: u32) -> ::windows::core::Result<super::super::Graphics::Direct3D9::IDirect3DSurface9> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetSurface)(::windows::core::Vtable::as_raw(self), dwuserid, surfaceindex, surfaceflags, result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn AdviseNotify<P0>(&self, lpivmrsurfallocnotify: P0) -> ::windows::core::Result<()>
    where
        P0: ::std::convert::Into<::windows::core::InParam<IVMRSurfaceAllocatorNotify9>>,
    {
        (::windows::core::Vtable::vtable(self).base__.AdviseNotify)(::windows::core::Vtable::as_raw(self), lpivmrsurfallocnotify.into().abi()).ok()
    }
}
impl ::core::cmp::PartialEq for IVMRSurfaceAllocatorNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurfaceAllocatorNotify {}
impl ::core::fmt::Debug for IVMRSurfaceAllocatorNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurfaceAllocatorNotify").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRSurfaceAllocatorNotify9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRSurfaceAllocatorNotify9 {}
impl ::core::fmt::Debug for IVMRSurfaceAllocatorNotify9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRSurfaceAllocatorNotify9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRVideoStreamControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRVideoStreamControl {}
impl ::core::fmt::Debug for IVMRVideoStreamControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRVideoStreamControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRVideoStreamControl9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRVideoStreamControl9 {}
impl ::core::fmt::Debug for IVMRVideoStreamControl9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRVideoStreamControl9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRWindowlessControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRWindowlessControl {}
impl ::core::fmt::Debug for IVMRWindowlessControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRWindowlessControl").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVMRWindowlessControl9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVMRWindowlessControl9 {}
impl ::core::fmt::Debug for IVMRWindowlessControl9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVMRWindowlessControl9").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVPBaseConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPBaseConfig {}
impl ::core::fmt::Debug for IVPBaseConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPBaseConfig").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVPBaseNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPBaseNotify {}
impl ::core::fmt::Debug for IVPBaseNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPBaseNotify").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVPConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPConfig {}
impl ::core::fmt::Debug for IVPConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPConfig").field(&self.0).finish()
    }
}
impl IVPConfig {
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetConnectInfo(&self, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: ::core::option::Option<*mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetConnectInfo)(::windows::core::Vtable::as_raw(self), pdwnumconnectinfo, ::core::mem::transmute(pddvpconnectinfo.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetConnectInfo(&self, dwchosenentry: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetConnectInfo)(::windows::core::Vtable::as_raw(self), dwchosenentry).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVPDataInfo(&self, pamvpdatainfo: *mut AMVPDATAINFO) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetVPDataInfo)(::windows::core::Vtable::as_raw(self), pamvpdatainfo).ok()
    }
    pub unsafe fn GetMaxPixelRate(&self, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetMaxPixelRate)(::windows::core::Vtable::as_raw(self), pamvpsize, pdwmaxpixelspersecond).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn InformVPInputFormats(&self, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.InformVPInputFormats)(::windows::core::Vtable::as_raw(self), dwnumformats, pddpixelformats).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetVideoFormats(&self, pdwnumformats: *mut u32, pddpixelformats: ::core::option::Option<*mut super::super::Graphics::DirectDraw::DDPIXELFORMAT>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetVideoFormats)(::windows::core::Vtable::as_raw(self), pdwnumformats, ::core::mem::transmute(pddpixelformats.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetVideoFormat(&self, dwchosenentry: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetVideoFormat)(::windows::core::Vtable::as_raw(self), dwchosenentry).ok()
    }
    pub unsafe fn SetInvertPolarity(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInvertPolarity)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetOverlaySurface(&self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetOverlaySurface)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDirectDrawKernelHandle(&self, dwddkernelhandle: usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDirectDrawKernelHandle)(::windows::core::Vtable::as_raw(self), dwddkernelhandle).ok()
    }
    pub unsafe fn SetVideoPortID(&self, dwvideoportid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetVideoPortID)(::windows::core::Vtable::as_raw(self), dwvideoportid).ok()
    }
    pub unsafe fn SetDDSurfaceKernelHandles(&self, chandles: u32, rgddkernelhandles: *mut usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDDSurfaceKernelHandles)(::windows::core::Vtable::as_raw(self), chandles, rgddkernelhandles).ok()
    }
    pub unsafe fn SetSurfaceParameters(&self, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSurfaceParameters)(::windows::core::Vtable::as_raw(self), dwpitch, dwxorigin, dwyorigin).ok()
    }
}
impl ::core::cmp::PartialEq for IVPManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPManager {}
impl ::core::fmt::Debug for IVPManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPManager").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVPNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPNotify {}
impl ::core::fmt::Debug for IVPNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPNotify").field(&self.0).finish()
    }
}
impl IVPNotify {
    pub unsafe fn RenegotiateVPParameters(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RenegotiateVPParameters)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IVPNotify2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPNotify2 {}
impl ::core::fmt::Debug for IVPNotify2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPNotify2").field(&self.0).finish()
    }
}
impl IVPNotify2 {
    pub unsafe fn RenegotiateVPParameters(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.base__.RenegotiateVPParameters)(::windows::core::Vtable::as_raw(self)).ok()
    }
    pub unsafe fn SetDeinterlaceMode(&self, mode: AMVP_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDeinterlaceMode)(::windows::core::Vtable::as_raw(self), mode).ok()
    }
    pub unsafe fn GetDeinterlaceMode(&self, pmode: *mut AMVP_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetDeinterlaceMode)(::windows::core::Vtable::as_raw(self), pmode).ok()
    }
}
impl ::core::cmp::PartialEq for IVPVBIConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPVBIConfig {}
impl ::core::fmt::Debug for IVPVBIConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPVBIConfig").field(&self.0).finish()
    }
}
impl IVPVBIConfig {
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetConnectInfo(&self, pdwnumconnectinfo: *mut u32, pddvpconnectinfo: ::core::option::Option<*mut super::super::Graphics::DirectDraw::DDVIDEOPORTCONNECT>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetConnectInfo)(::windows::core::Vtable::as_raw(self), pdwnumconnectinfo, ::core::mem::transmute(pddvpconnectinfo.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetConnectInfo(&self, dwchosenentry: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetConnectInfo)(::windows::core::Vtable::as_raw(self), dwchosenentry).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVPDataInfo(&self, pamvpdatainfo: *mut AMVPDATAINFO) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetVPDataInfo)(::windows::core::Vtable::as_raw(self), pamvpdatainfo).ok()
    }
    pub unsafe fn GetMaxPixelRate(&self, pamvpsize: *mut AMVPSIZE, pdwmaxpixelspersecond: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetMaxPixelRate)(::windows::core::Vtable::as_raw(self), pamvpsize, pdwmaxpixelspersecond).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn InformVPInputFormats(&self, dwnumformats: u32, pddpixelformats: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.InformVPInputFormats)(::windows::core::Vtable::as_raw(self), dwnumformats, pddpixelformats).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetVideoFormats(&self, pdwnumformats: *mut u32, pddpixelformats: ::core::option::Option<*mut super::super::Graphics::DirectDraw::DDPIXELFORMAT>) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetVideoFormats)(::windows::core::Vtable::as_raw(self), pdwnumformats, ::core::mem::transmute(pddpixelformats.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetVideoFormat(&self, dwchosenentry: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetVideoFormat)(::windows::core::Vtable::as_raw(self), dwchosenentry).ok()
    }
    pub unsafe fn SetInvertPolarity(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetInvertPolarity)(::windows::core::Vtable::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_DirectDraw\"`*"]
    #[cfg(feature = "Win32_Graphics_DirectDraw")]
    pub unsafe fn GetOverlaySurface(&self) -> ::windows::core::Result<super::super::Graphics::DirectDraw::IDirectDrawSurface> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetOverlaySurface)(::windows::core::Vtable::as_raw(self), result__.as_mut_ptr()).from_abi(result__)
    }
    pub unsafe fn SetDirectDrawKernelHandle(&self, dwddkernelhandle: usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDirectDrawKernelHandle)(::windows::core::Vtable::as_raw(self), dwddkernelhandle).ok()
    }
    pub unsafe fn SetVideoPortID(&self, dwvideoportid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetVideoPortID)(::windows::core::Vtable::as_raw(self), dwvideoportid).ok()
    }
    pub unsafe fn SetDDSurfaceKernelHandles(&self, chandles: u32, rgddkernelhandles: *mut usize) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetDDSurfaceKernelHandles)(::windows::core::Vtable::as_raw(self), chandles, rgddkernelhandles).ok()
    }
    pub unsafe fn SetSurfaceParameters(&self, dwpitch: u32, dwxorigin: u32, dwyorigin: u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetSurfaceParameters)(::windows::core::Vtable::as_raw(self), dwpitch, dwxorigin, dwyorigin).ok()
    }
}
impl ::core::cmp::PartialEq for IVPVBINotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVPVBINotify {}
impl ::core::fmt::Debug for IVPVBINotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVPVBINotify").field(&self.0).finish()
    }
}
impl IVPVBINotify {
    pub unsafe fn RenegotiateVPParameters(&self) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.RenegotiateVPParameters)(::windows::core::Vtable::as_raw(self)).ok()
    }
}
impl ::core::cmp::PartialEq for IVideoEncoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVideoEncoder {}
impl ::core::fmt::Debug for IVideoEncoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVideoEncoder").field(&self.0).finish()
    }
}
impl IVideoEncoder {
    pub unsafe fn IsSupported(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsSupported)(::windows::core::Vtable::as_raw(self), api).ok()
    }
    pub unsafe fn IsAvailable(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.IsAvailable)(::windows::core::Vtable::as_raw(self), api).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetParameterRange(&self, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetParameterRange)(::windows::core::Vtable::as_raw(self), api, valuemin, valuemax, steppingdelta).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetParameterValues(&self, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.GetParameterValues)(::windows::core::Vtable::as_raw(self), api, values, valuescount).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetDefaultValue(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetDefaultValue)(::windows::core::Vtable::as_raw(self), api, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetValue(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT> {
        let mut result__ = ::core::mem::MaybeUninit::zeroed();
        (::windows::core::Vtable::vtable(self).base__.GetValue)(::windows::core::Vtable::as_raw(self), api, result__.as_mut_ptr()).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetValue(&self, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Vtable::vtable(self).base__.SetValue)(::windows::core::Vtable::as_raw(self), api, value).ok()
    }
}
impl ::core::cmp::PartialEq for IVideoFrameStep {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVideoFrameStep {}
impl ::core::fmt::Debug for IVideoFrameStep {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVideoFrameStep").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IVideoProcAmp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVideoProcAmp {}
impl ::core::fmt::Debug for IVideoProcAmp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVideoProcAmp").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IVideoWindow {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IVideoWindow {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IVideoWindow {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVideoWindow").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IWMCodecAMVideoAccelerator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecAMVideoAccelerator {}
impl ::core::fmt::Debug for IWMCodecAMVideoAccelerator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecAMVideoAccelerator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IWMCodecVideoAccelerator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecVideoAccelerator {}
impl ::core::fmt::Debug for IWMCodecVideoAccelerator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecVideoAccelerator").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IXDSCodec {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IXDSCodec {}
impl ::core::fmt::Debug for IXDSCodec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IXDSCodec").field(&self.0).finish()
    }
}
impl ::core::cmp::PartialEq for IXDSCodecConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IXDSCodecConfig {}
impl ::core::fmt::Debug for IXDSCodecConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IXDSCodecConfig").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IXDSCodecEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IXDSCodecEvents {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IXDSCodecEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IXDSCodecEvents").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for IXDSToRat {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for IXDSToRat {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for IXDSToRat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IXDSToRat").field(&self.0).finish()
    }
}
impl ::core::default::Default for InterleavingMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for InterleavingMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("InterleavingMode").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSEVENTDATA_BDA_RF_TUNER_SCAN_S {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for KSEVENT_BDA_EVENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSEVENT_BDA_EVENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSEVENT_BDA_EVENT_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSEVENT_BDA_TUNER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSEVENT_BDA_TUNER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSEVENT_BDA_TUNER").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_CAS_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_CAS_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_CAS_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_CHANGE_SYNC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_CHANGE_SYNC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_CHANGE_SYNC").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_DEBUG_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_DEBUG_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_DEBUG_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_DEVICE_CONFIGURATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_DEVICE_CONFIGURATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_DEVICE_CONFIGURATION").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_DRM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_DRM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_DRM").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_EVENTING_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_EVENTING_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_EVENTING_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_GDDS_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_GDDS_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_GDDS_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_GPNV_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_GPNV_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_GPNV_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_ISDB_CAS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_ISDB_CAS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_ISDB_CAS").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_MUX_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_MUX_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_MUX_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_SCAN_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_SCAN_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_SCAN_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_TS_SELECTOR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_TS_SELECTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_TS_SELECTOR").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_TUNER_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_TUNER_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_TUNER_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_USERACTIVITY_SERVICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_USERACTIVITY_SERVICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_USERACTIVITY_SERVICE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_WMDRM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_WMDRM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_WMDRM").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSMETHOD_BDA_WMDRM_TUNER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSMETHOD_BDA_WMDRM_TUNER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_BDA_WMDRM_TUNER").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_CAS_CAPTURETOKEN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSM_BDA_CAS_CLOSEMMIDIALOG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSM_BDA_CAS_ENTITLEMENTTOKEN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSM_BDA_CAS_OPENBROADCASTMMI {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_DEBUG_LEVEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_DRM_SETDRM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_EVENT_COMPLETE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_GDDS_SERVICEFROMTUNEXML {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_GDDS_TUNEXMLFROMIDX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSM_BDA_GPNV_GETVALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_GPNV_NAMEINDEX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSM_BDA_GPNV_SETVALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_ISDBCAS_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_PIN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_PIN_PAIR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_SCAN_CAPABILTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_SCAN_FILTER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_SCAN_START {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_TS_SELECTOR_SETTSID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_TUNER_TUNEREQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_USERACTIVITY_USEREASON {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_WMDRMTUNER_GETPIDPROTECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSM_BDA_WMDRMTUNER_PURCHASEENTITLEMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_WMDRMTUNER_SETPIDPROTECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_WMDRMTUNER_SYNCVALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_WMDRM_LICENSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSM_BDA_WMDRM_RENEWLICENSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_AUTODEMODULATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_AUTODEMODULATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_AUTODEMODULATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_CA {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_CA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_CA").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_CA_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_CA_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_CA_EVENT").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_DIGITAL_DEMODULATOR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_DIGITAL_DEMODULATOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_DIGITAL_DEMODULATOR").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_DISEQC_COMMAND {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_DISEQC_COMMAND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_DISEQC_COMMAND").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_DISEQC_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_DISEQC_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_DISEQC_EVENT").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_ETHERNET_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_ETHERNET_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_ETHERNET_FILTER").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_FREQUENCY_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_FREQUENCY_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_FREQUENCY_FILTER").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_IPv4_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_IPv4_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_IPv4_FILTER").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_IPv6_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_IPv6_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_IPv6_FILTER").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_LNB_INFO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_LNB_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_LNB_INFO").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_NULL_TRANSFORM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_NULL_TRANSFORM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_NULL_TRANSFORM").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_PIDFILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_PIDFILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_PIDFILTER").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_PIN_CONTROL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_PIN_CONTROL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_PIN_CONTROL").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_PIN_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_PIN_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_PIN_EVENT").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSPROPERTY_BDA_RF_TUNER_CAPS_S {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS_S {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_KernelStreaming"))]
impl ::core::default::Default for KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE_S {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSPROPERTY_BDA_RF_TUNER_STANDARD_S {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_SIGNAL_STATS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_SIGNAL_STATS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_SIGNAL_STATS").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_TOPOLOGY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_TOPOLOGY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_TOPOLOGY").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_BDA_VOID_TRANSFORM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_BDA_VOID_TRANSFORM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_BDA_VOID_TRANSFORM").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_IDS_BDA_TABLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_IDS_BDA_TABLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_IDS_BDA_TABLE").field(&self.0).finish()
    }
}
impl ::core::default::Default for KSPROPERTY_IPSINK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KSPROPERTY_IPSINK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSPROPERTY_IPSINK").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for KSPROPERTY_IPSINK {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for KSPROPERTY_IPSINK {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for KSPROPERTY_IPSINK {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for KSPROPERTY_IPSINK {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for KSPROPERTY_IPSINK {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSP_BDA_NODE_PIN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KSP_NODE_ESPID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for KS_BDA_FRAME_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for KS_BDA_FRAME_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ExtendedHeaderSize == other.ExtendedHeaderSize && self.dwFrameFlags == other.dwFrameFlags && self.ulEvent == other.ulEvent && self.ulChannelNumber == other.ulChannelNumber && self.ulSubchannelNumber == other.ulSubchannelNumber && self.ulReason == other.ulReason
    }
}
impl ::core::cmp::Eq for KS_BDA_FRAME_INFO {}
impl ::core::fmt::Debug for KS_BDA_FRAME_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("KS_BDA_FRAME_INFO").field("ExtendedHeaderSize", &self.ExtendedHeaderSize).field("dwFrameFlags", &self.dwFrameFlags).field("ulEvent", &self.ulEvent).field("ulChannelNumber", &self.ulChannelNumber).field("ulSubchannelNumber", &self.ulSubchannelNumber).field("ulReason", &self.ulReason).finish()
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KS_DATARANGE_BDA_ANTENNA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Media_KernelStreaming")]
impl ::core::default::Default for KS_DATARANGE_BDA_TRANSPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for LNB_Source {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LNB_Source {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LNB_Source").field(&self.0).finish()
    }
}
impl ::core::default::Default for LONG_SECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for LanguageInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for LanguageInfo {
    fn eq(&self, other: &Self) -> bool {
        self.LangID == other.LangID && self.lISOLangCode == other.lISOLangCode
    }
}
impl ::core::cmp::Eq for LanguageInfo {}
impl ::core::fmt::Debug for LanguageInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LanguageInfo").field("LangID", &self.LangID).field("lISOLangCode", &self.lISOLangCode).finish()
    }
}
impl ::core::default::Default for LicenseEventBlockReason {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LicenseEventBlockReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LicenseEventBlockReason").field(&self.0).finish()
    }
}
impl ::core::default::Default for LocationCodeSchemeType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LocationCodeSchemeType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LocationCodeSchemeType").field(&self.0).finish()
    }
}
impl ::core::default::Default for MEDIA_SAMPLE_CONTENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MEDIA_SAMPLE_CONTENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MEDIA_SAMPLE_CONTENT").field(&self.0).finish()
    }
}
impl ::core::default::Default for MMSSF_GET_INFORMATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MMSSF_GET_INFORMATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MMSSF_GET_INFORMATION_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for MMSSF_GET_INFORMATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MMSSF_GET_INFORMATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MMSSF_GET_INFORMATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MMSSF_GET_INFORMATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MMSSF_GET_INFORMATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl ::core::default::Default for MPEG1WAVEFORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG2StreamType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MPEG2StreamType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MPEG2StreamType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MPEG2_FILTER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MPEG2_FILTER2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG2_TRANSPORT_STRIDE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for MPEG2_TRANSPORT_STRIDE {
    fn eq(&self, other: &Self) -> bool {
        self.dwOffset == other.dwOffset && self.dwPacketLength == other.dwPacketLength && self.dwStride == other.dwStride
    }
}
impl ::core::cmp::Eq for MPEG2_TRANSPORT_STRIDE {}
impl ::core::fmt::Debug for MPEG2_TRANSPORT_STRIDE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MPEG2_TRANSPORT_STRIDE").field("dwOffset", &self.dwOffset).field("dwPacketLength", &self.dwPacketLength).field("dwStride", &self.dwStride).finish()
    }
}
#[cfg(feature = "Win32_Media_Audio")]
impl ::core::default::Default for MPEGLAYER3WAVEFORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEGLAYER3WAVEFORMAT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MPEGLAYER3WAVEFORMAT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MPEGLAYER3WAVEFORMAT_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for MPEG_BCS_DEMUX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_CONTEXT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MPEG_CONTEXT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MPEG_CONTEXT_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for MPEG_CURRENT_NEXT_BIT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MPEG_CURRENT_NEXT_BIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MPEG_CURRENT_NEXT_BIT").field(&self.0).finish()
    }
}
impl ::core::default::Default for MPEG_DATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_DATE_AND_TIME {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_HEADER_BITS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_HEADER_BITS_MIDL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_HEADER_VERSION_BITS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for MPEG_HEADER_VERSION_BITS {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for MPEG_HEADER_VERSION_BITS {}
impl ::core::fmt::Debug for MPEG_HEADER_VERSION_BITS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MPEG_HEADER_VERSION_BITS").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::core::default::Default for MPEG_HEADER_VERSION_BITS_MIDL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for MPEG_HEADER_VERSION_BITS_MIDL {
    fn eq(&self, other: &Self) -> bool {
        self.Bits == other.Bits
    }
}
impl ::core::cmp::Eq for MPEG_HEADER_VERSION_BITS_MIDL {}
impl ::core::fmt::Debug for MPEG_HEADER_VERSION_BITS_MIDL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MPEG_HEADER_VERSION_BITS_MIDL").field("Bits", &self.Bits).finish()
    }
}
impl ::core::default::Default for MPEG_PACKET_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_REQUEST_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MPEG_REQUEST_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MPEG_REQUEST_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for MPEG_RQST_PACKET {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MPEG_SERVICE_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_SERVICE_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_STREAM_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MPEG_STREAM_FILTER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_TIME {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPEG_WINSOCK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MPE_ELEMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for MP_CURVE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MP_CURVE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MP_CURVE_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for MP_ENVELOPE_SEGMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for MP_ENVELOPE_SEGMENT {
    fn eq(&self, other: &Self) -> bool {
        self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.valStart == other.valStart && self.valEnd == other.valEnd && self.iCurve == other.iCurve && self.flags == other.flags
    }
}
impl ::core::cmp::Eq for MP_ENVELOPE_SEGMENT {}
impl ::core::fmt::Debug for MP_ENVELOPE_SEGMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MP_ENVELOPE_SEGMENT").field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("valStart", &self.valStart).field("valEnd", &self.valEnd).field("iCurve", &self.iCurve).field("flags", &self.flags).finish()
    }
}
impl ::core::default::Default for MP_PARAMINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for MP_PARAMINFO {
    fn eq(&self, other: &Self) -> bool {
        self.mpType == other.mpType && self.mopCaps == other.mopCaps && self.mpdMinValue == other.mpdMinValue && self.mpdMaxValue == other.mpdMaxValue && self.mpdNeutralValue == other.mpdNeutralValue && self.szUnitText == other.szUnitText && self.szLabel == other.szLabel
    }
}
impl ::core::cmp::Eq for MP_PARAMINFO {}
impl ::core::fmt::Debug for MP_PARAMINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MP_PARAMINFO").field("mpType", &self.mpType).field("mopCaps", &self.mopCaps).field("mpdMinValue", &self.mpdMinValue).field("mpdMaxValue", &self.mpdMaxValue).field("mpdNeutralValue", &self.mpdNeutralValue).field("szUnitText", &self.szUnitText).field("szLabel", &self.szLabel).finish()
    }
}
impl ::core::default::Default for MP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MP_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for MSVidCCService {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MSVidCCService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSVidCCService").field(&self.0).finish()
    }
}
impl ::core::default::Default for MSVidCtlButtonstate {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MSVidCtlButtonstate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSVidCtlButtonstate").field(&self.0).finish()
    }
}
impl ::core::default::Default for MSVidCtlStateList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MSVidCtlStateList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSVidCtlStateList").field(&self.0).finish()
    }
}
impl ::core::default::Default for MSVidSegmentType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MSVidSegmentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSVidSegmentType").field(&self.0).finish()
    }
}
impl ::core::default::Default for MSVidSinkStreams {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MSVidSinkStreams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSVidSinkStreams").field(&self.0).finish()
    }
}
impl ::core::default::Default for MSViddispidList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MSViddispidList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSViddispidList").field(&self.0).finish()
    }
}
impl ::core::default::Default for MUX_PID_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MUX_PID_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MUX_PID_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for MainAVIHeader {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for MainAVIHeader {
    fn eq(&self, other: &Self) -> bool {
        self.dwMicroSecPerFrame == other.dwMicroSecPerFrame && self.dwMaxBytesPerSec == other.dwMaxBytesPerSec && self.dwPaddingGranularity == other.dwPaddingGranularity && self.dwFlags == other.dwFlags && self.dwTotalFrames == other.dwTotalFrames && self.dwInitialFrames == other.dwInitialFrames && self.dwStreams == other.dwStreams && self.dwSuggestedBufferSize == other.dwSuggestedBufferSize && self.dwWidth == other.dwWidth && self.dwHeight == other.dwHeight && self.dwReserved == other.dwReserved
    }
}
impl ::core::cmp::Eq for MainAVIHeader {}
impl ::core::fmt::Debug for MainAVIHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MainAVIHeader")
            .field("dwMicroSecPerFrame", &self.dwMicroSecPerFrame)
            .field("dwMaxBytesPerSec", &self.dwMaxBytesPerSec)
            .field("dwPaddingGranularity", &self.dwPaddingGranularity)
            .field("dwFlags", &self.dwFlags)
            .field("dwTotalFrames", &self.dwTotalFrames)
            .field("dwInitialFrames", &self.dwInitialFrames)
            .field("dwStreams", &self.dwStreams)
            .field("dwSuggestedBufferSize", &self.dwSuggestedBufferSize)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("dwReserved", &self.dwReserved)
            .finish()
    }
}
impl ::core::default::Default for ModulationType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ModulationType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ModulationType").field(&self.0).finish()
    }
}
impl ::core::default::Default for Mpeg2TableSampleHdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for NORMALIZEDRECT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for NORMALIZEDRECT {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left && self.top == other.top && self.right == other.right && self.bottom == other.bottom
    }
}
impl ::core::cmp::Eq for NORMALIZEDRECT {}
impl ::core::fmt::Debug for NORMALIZEDRECT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NORMALIZEDRECT").field("left", &self.left).field("top", &self.top).field("right", &self.right).field("bottom", &self.bottom).finish()
    }
}
impl ::core::default::Default for OA_BOOL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for OA_BOOL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OA_BOOL").field(&self.0).finish()
    }
}
impl ::core::default::Default for OUTPUT_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for OUTPUT_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OUTPUT_STATE").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for OUTPUT_STATE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for OUTPUT_STATE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for OUTPUT_STATE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for OUTPUT_STATE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for OUTPUT_STATE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for PBDAParentalControl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for PBDA_TAG_ATTRIBUTE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for PBDA_TAG_ATTRIBUTE {
    fn eq(&self, other: &Self) -> bool {
        self.TableUUId == other.TableUUId && self.TableId == other.TableId && self.VersionNo == other.VersionNo && self.TableDataSize == other.TableDataSize && self.TableData == other.TableData
    }
}
impl ::core::cmp::Eq for PBDA_TAG_ATTRIBUTE {}
impl ::core::fmt::Debug for PBDA_TAG_ATTRIBUTE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PBDA_TAG_ATTRIBUTE").field("TableUUId", &self.TableUUId).field("TableId", &self.TableId).field("VersionNo", &self.VersionNo).field("TableDataSize", &self.TableDataSize).field("TableData", &self.TableData).finish()
    }
}
impl ::core::default::Default for PIC_SEQ_SAMPLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for PIC_SEQ_SAMPLE {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for PIC_SEQ_SAMPLE {}
impl ::core::fmt::Debug for PIC_SEQ_SAMPLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PIC_SEQ_SAMPLE").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::core::default::Default for PIDListSpanningEvent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for PIDListSpanningEvent {
    fn eq(&self, other: &Self) -> bool {
        self.wPIDCount == other.wPIDCount && self.pulPIDs == other.pulPIDs
    }
}
impl ::core::cmp::Eq for PIDListSpanningEvent {}
impl ::core::fmt::Debug for PIDListSpanningEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PIDListSpanningEvent").field("wPIDCount", &self.wPIDCount).field("pulPIDs", &self.pulPIDs).finish()
    }
}
impl ::core::default::Default for PID_BITS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for PID_BITS_MIDL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for PID_MAP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for PID_MAP {
    fn eq(&self, other: &Self) -> bool {
        self.ulPID == other.ulPID && self.MediaSampleContent == other.MediaSampleContent
    }
}
impl ::core::cmp::Eq for PID_MAP {}
impl ::core::fmt::Debug for PID_MAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PID_MAP").field("ulPID", &self.ulPID).field("MediaSampleContent", &self.MediaSampleContent).finish()
    }
}
impl ::core::default::Default for PIN_DIRECTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PIN_DIRECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PIN_DIRECTION").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::default::Default for PIN_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for PIN_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.pFilter == other.pFilter && self.dir == other.dir && self.achName == other.achName
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for PIN_INFO {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for PIN_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PIN_INFO").field("pFilter", &self.pFilter).field("dir", &self.dir).field("achName", &self.achName).finish()
    }
}
impl ::core::default::Default for PhysicalConnectorType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PhysicalConnectorType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PhysicalConnectorType").field(&self.0).finish()
    }
}
impl ::core::default::Default for Pilot {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for Pilot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("Pilot").field(&self.0).finish()
    }
}
impl ::core::default::Default for Polarisation {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for Polarisation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("Polarisation").field(&self.0).finish()
    }
}
impl ::core::default::Default for PositionModeList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PositionModeList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PositionModeList").field(&self.0).finish()
    }
}
impl ::core::default::Default for ProgramElement {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for ProgramElement {
    fn eq(&self, other: &Self) -> bool {
        self.wProgramNumber == other.wProgramNumber && self.wProgramMapPID == other.wProgramMapPID
    }
}
impl ::core::cmp::Eq for ProgramElement {}
impl ::core::fmt::Debug for ProgramElement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ProgramElement").field("wProgramNumber", &self.wProgramNumber).field("wProgramMapPID", &self.wProgramMapPID).finish()
    }
}
impl ::core::default::Default for ProtType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ProtType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ProtType").field(&self.0).finish()
    }
}
impl ::core::default::Default for Quality {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for Quality {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Proportion == other.Proportion && self.Late == other.Late && self.TimeStamp == other.TimeStamp
    }
}
impl ::core::cmp::Eq for Quality {}
impl ::core::fmt::Debug for Quality {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Quality").field("Type", &self.Type).field("Proportion", &self.Proportion).field("Late", &self.Late).field("TimeStamp", &self.TimeStamp).finish()
    }
}
impl ::core::default::Default for QualityMessageType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for QualityMessageType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("QualityMessageType").field(&self.0).finish()
    }
}
impl ::core::default::Default for RATING_ATTRIBUTE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for RATING_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for RATING_SYSTEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for RECORDING_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for RECORDING_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RECORDING_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for REGFILTER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for REGFILTER {
    fn eq(&self, other: &Self) -> bool {
        self.Clsid == other.Clsid && self.Name == other.Name
    }
}
impl ::core::cmp::Eq for REGFILTER {}
impl ::core::fmt::Debug for REGFILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REGFILTER").field("Clsid", &self.Clsid).field("Name", &self.Name).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REGFILTER2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REGFILTERPINS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REGFILTERPINS {
    fn eq(&self, other: &Self) -> bool {
        self.strName == other.strName && self.bRendered == other.bRendered && self.bOutput == other.bOutput && self.bZero == other.bZero && self.bMany == other.bMany && self.clsConnectsToFilter == other.clsConnectsToFilter && self.strConnectsToPin == other.strConnectsToPin && self.nMediaTypes == other.nMediaTypes && self.lpMediaType == other.lpMediaType
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REGFILTERPINS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REGFILTERPINS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REGFILTERPINS").field("strName", &self.strName).field("bRendered", &self.bRendered).field("bOutput", &self.bOutput).field("bZero", &self.bZero).field("bMany", &self.bMany).field("clsConnectsToFilter", &self.clsConnectsToFilter).field("strConnectsToPin", &self.strConnectsToPin).field("nMediaTypes", &self.nMediaTypes).field("lpMediaType", &self.lpMediaType).finish()
    }
}
impl ::core::default::Default for REGFILTERPINS2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for REGFILTERPINS2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.cInstances == other.cInstances && self.nMediaTypes == other.nMediaTypes && self.lpMediaType == other.lpMediaType && self.nMediums == other.nMediums && self.lpMedium == other.lpMedium && self.clsPinCategory == other.clsPinCategory
    }
}
impl ::core::cmp::Eq for REGFILTERPINS2 {}
impl ::core::fmt::Debug for REGFILTERPINS2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REGFILTERPINS2").field("dwFlags", &self.dwFlags).field("cInstances", &self.cInstances).field("nMediaTypes", &self.nMediaTypes).field("lpMediaType", &self.lpMediaType).field("nMediums", &self.nMediums).field("lpMedium", &self.lpMedium).field("clsPinCategory", &self.clsPinCategory).finish()
    }
}
impl ::core::default::Default for REGPINMEDIUM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for REGPINMEDIUM {
    fn eq(&self, other: &Self) -> bool {
        self.clsMedium == other.clsMedium && self.dw1 == other.dw1 && self.dw2 == other.dw2
    }
}
impl ::core::cmp::Eq for REGPINMEDIUM {}
impl ::core::fmt::Debug for REGPINMEDIUM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REGPINMEDIUM").field("clsMedium", &self.clsMedium).field("dw1", &self.dw1).field("dw2", &self.dw2).finish()
    }
}
impl ::core::default::Default for REGPINTYPES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for REGPINTYPES {
    fn eq(&self, other: &Self) -> bool {
        self.clsMajorType == other.clsMajorType && self.clsMinorType == other.clsMinorType
    }
}
impl ::core::cmp::Eq for REGPINTYPES {}
impl ::core::fmt::Debug for REGPINTYPES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REGPINTYPES").field("clsMajorType", &self.clsMajorType).field("clsMinorType", &self.clsMinorType).finish()
    }
}
impl ::core::default::Default for REG_PINFLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for REG_PINFLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REG_PINFLAG").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for REG_PINFLAG {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for REG_PINFLAG {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for REG_PINFLAG {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for REG_PINFLAG {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for REG_PINFLAG {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl ::core::default::Default for RIFFCHUNK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for RIFFLIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for RecordingType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for RecordingType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RecordingType").field(&self.0).finish()
    }
}
impl ::core::default::Default for RevokedComponent {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for RevokedComponent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RevokedComponent").field(&self.0).finish()
    }
}
impl ::core::default::Default for RollOff {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for RollOff {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RollOff").field(&self.0).finish()
    }
}
impl ::core::default::Default for SAMPLE_LIVE_STREAM_TIME {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SAMPLE_LIVE_STREAM_TIME {
    fn eq(&self, other: &Self) -> bool {
        self.qwStreamTime == other.qwStreamTime && self.qwLiveTime == other.qwLiveTime
    }
}
impl ::core::cmp::Eq for SAMPLE_LIVE_STREAM_TIME {}
impl ::core::fmt::Debug for SAMPLE_LIVE_STREAM_TIME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SAMPLE_LIVE_STREAM_TIME").field("qwStreamTime", &self.qwStreamTime).field("qwLiveTime", &self.qwLiveTime).finish()
    }
}
impl ::core::default::Default for SAMPLE_SEQ_OFFSET {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SAMPLE_SEQ_OFFSET {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for SAMPLE_SEQ_OFFSET {}
impl ::core::fmt::Debug for SAMPLE_SEQ_OFFSET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SAMPLE_SEQ_OFFSET").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::core::default::Default for SBE2_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SBE2_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.StreamId == other.StreamId && self.Default == other.Default && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for SBE2_STREAM_DESC {}
impl ::core::fmt::Debug for SBE2_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SBE2_STREAM_DESC").field("Version", &self.Version).field("StreamId", &self.StreamId).field("Default", &self.Default).field("Reserved", &self.Reserved).finish()
    }
}
impl ::core::default::Default for SBE_PIN_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SBE_PIN_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.cDataBytes == other.cDataBytes && self.cSamplesProcessed == other.cSamplesProcessed && self.cDiscontinuities == other.cDiscontinuities && self.cSyncPoints == other.cSyncPoints && self.cTimestamps == other.cTimestamps
    }
}
impl ::core::cmp::Eq for SBE_PIN_DATA {}
impl ::core::fmt::Debug for SBE_PIN_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SBE_PIN_DATA").field("cDataBytes", &self.cDataBytes).field("cSamplesProcessed", &self.cSamplesProcessed).field("cDiscontinuities", &self.cDiscontinuities).field("cSyncPoints", &self.cSyncPoints).field("cTimestamps", &self.cTimestamps).finish()
    }
}
impl ::core::default::Default for SECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for SNDDEV_ERR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SNDDEV_ERR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SNDDEV_ERR").field(&self.0).finish()
    }
}
impl ::core::default::Default for SSUPDATE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SSUPDATE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SSUPDATE_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for STREAMBUFFER_ATTRIBUTE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for STREAMBUFFER_ATTRIBUTE {
    fn eq(&self, other: &Self) -> bool {
        self.pszName == other.pszName && self.StreamBufferAttributeType == other.StreamBufferAttributeType && self.pbAttribute == other.pbAttribute && self.cbLength == other.cbLength
    }
}
impl ::core::cmp::Eq for STREAMBUFFER_ATTRIBUTE {}
impl ::core::fmt::Debug for STREAMBUFFER_ATTRIBUTE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAMBUFFER_ATTRIBUTE").field("pszName", &self.pszName).field("StreamBufferAttributeType", &self.StreamBufferAttributeType).field("pbAttribute", &self.pbAttribute).field("cbLength", &self.cbLength).finish()
    }
}
impl ::core::default::Default for STREAMBUFFER_ATTR_DATATYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STREAMBUFFER_ATTR_DATATYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STREAMBUFFER_ATTR_DATATYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for STREAMIF_CONSTANTS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STREAMIF_CONSTANTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STREAMIF_CONSTANTS").field(&self.0).finish()
    }
}
impl ::core::default::Default for STREAM_ID_MAP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for STREAM_ID_MAP {
    fn eq(&self, other: &Self) -> bool {
        self.stream_id == other.stream_id && self.dwMediaSampleContent == other.dwMediaSampleContent && self.ulSubstreamFilterValue == other.ulSubstreamFilterValue && self.iDataOffset == other.iDataOffset
    }
}
impl ::core::cmp::Eq for STREAM_ID_MAP {}
impl ::core::fmt::Debug for STREAM_ID_MAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_ID_MAP").field("stream_id", &self.stream_id).field("dwMediaSampleContent", &self.dwMediaSampleContent).field("ulSubstreamFilterValue", &self.ulSubstreamFilterValue).field("iDataOffset", &self.iDataOffset).finish()
    }
}
impl ::core::default::Default for STREAM_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STREAM_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STREAM_STATE").field(&self.0).finish()
    }
}
impl ::core::default::Default for STREAM_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STREAM_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STREAM_TYPE").field(&self.0).finish()
    }
}
impl ::core::default::Default for ScanModulationTypes {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ScanModulationTypes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ScanModulationTypes").field(&self.0).finish()
    }
}
impl ::core::default::Default for SegDispidList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SegDispidList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SegDispidList").field(&self.0).finish()
    }
}
impl ::core::default::Default for SegEventidList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SegEventidList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SegEventidList").field(&self.0).finish()
    }
}
impl ::core::default::Default for SignalAndServiceStatusSpanningEvent_State {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SignalAndServiceStatusSpanningEvent_State {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SignalAndServiceStatusSpanningEvent_State").field(&self.0).finish()
    }
}
impl ::core::default::Default for SmartCardApplication {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SmartCardApplication {
    fn eq(&self, other: &Self) -> bool {
        self.ApplicationType == other.ApplicationType && self.ApplicationVersion == other.ApplicationVersion && self.pbstrApplicationName == other.pbstrApplicationName && self.pbstrApplicationURL == other.pbstrApplicationURL
    }
}
impl ::core::cmp::Eq for SmartCardApplication {}
impl ::core::fmt::Debug for SmartCardApplication {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SmartCardApplication").field("ApplicationType", &self.ApplicationType).field("ApplicationVersion", &self.ApplicationVersion).field("pbstrApplicationName", &self.pbstrApplicationName).field("pbstrApplicationURL", &self.pbstrApplicationURL).finish()
    }
}
impl ::core::default::Default for SmartCardAssociationType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SmartCardAssociationType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SmartCardAssociationType").field(&self.0).finish()
    }
}
impl ::core::default::Default for SmartCardStatusType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SmartCardStatusType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SmartCardStatusType").field(&self.0).finish()
    }
}
impl ::core::default::Default for SourceSizeList {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SourceSizeList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SourceSizeList").field(&self.0).finish()
    }
}
impl ::core::default::Default for SpanningEventDescriptor {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SpanningEventDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.wDataLen == other.wDataLen && self.wProgNumber == other.wProgNumber && self.wSID == other.wSID && self.bDescriptor == other.bDescriptor
    }
}
impl ::core::cmp::Eq for SpanningEventDescriptor {}
impl ::core::fmt::Debug for SpanningEventDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SpanningEventDescriptor").field("wDataLen", &self.wDataLen).field("wProgNumber", &self.wProgNumber).field("wSID", &self.wSID).field("bDescriptor", &self.bDescriptor).finish()
    }
}
impl ::core::default::Default for SpanningEventEmmMessage {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for SpanningEventEmmMessage {
    fn eq(&self, other: &Self) -> bool {
        self.bCAbroadcasterGroupId == other.bCAbroadcasterGroupId && self.bMessageControl == other.bMessageControl && self.wServiceId == other.wServiceId && self.wTableIdExtension == other.wTableIdExtension && self.bDeletionStatus == other.bDeletionStatus && self.bDisplayingDuration1 == other.bDisplayingDuration1 && self.bDisplayingDuration2 == other.bDisplayingDuration2 && self.bDisplayingDuration3 == other.bDisplayingDuration3 && self.bDisplayingCycle == other.bDisplayingCycle && self.bFormatVersion == other.bFormatVersion && self.bDisplayPosition == other.bDisplayPosition && self.wMessageLength == other.wMessageLength && self.szMessageArea == other.szMessageArea
    }
}
impl ::core::cmp::Eq for SpanningEventEmmMessage {}
impl ::core::fmt::Debug for SpanningEventEmmMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SpanningEventEmmMessage")
            .field("bCAbroadcasterGroupId", &self.bCAbroadcasterGroupId)
            .field("bMessageControl", &self.bMessageControl)
            .field("wServiceId", &self.wServiceId)
            .field("wTableIdExtension", &self.wTableIdExtension)
            .field("bDeletionStatus", &self.bDeletionStatus)
            .field("bDisplayingDuration1", &self.bDisplayingDuration1)
            .field("bDisplayingDuration2", &self.bDisplayingDuration2)
            .field("bDisplayingDuration3", &self.bDisplayingDuration3)
            .field("bDisplayingCycle", &self.bDisplayingCycle)
            .field("bFormatVersion", &self.bFormatVersion)
            .field("bDisplayPosition", &self.bDisplayPosition)
            .field("wMessageLength", &self.wMessageLength)
            .field("szMessageArea", &self.szMessageArea)
            .finish()
    }
}
impl ::core::default::Default for SpectralInversion {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SpectralInversion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SpectralInversion").field(&self.0).finish()
    }
}
impl ::core::default::Default for TID_EXTENSION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for TIMECODEDATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for TRANSPORT_PROPERTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::default::Default for TRUECOLORINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::cmp::PartialEq for TRUECOLORINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwBitMasks == other.dwBitMasks && self.bmiColors == other.bmiColors
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::cmp::Eq for TRUECOLORINFO {}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::core::fmt::Debug for TRUECOLORINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TRUECOLORINFO").field("dwBitMasks", &self.dwBitMasks).field("bmiColors", &self.bmiColors).finish()
    }
}
impl ::core::default::Default for TVAudioMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for TVAudioMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TVAudioMode").field(&self.0).finish()
    }
}
impl ::core::default::Default for TransmissionMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for TransmissionMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TransmissionMode").field(&self.0).finish()
    }
}
impl ::core::default::Default for TunerInputType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for TunerInputType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TunerInputType").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for UDCR_TAG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for UDCR_TAG {
    fn eq(&self, other: &Self) -> bool {
        self.bVersion == other.bVersion && self.KID == other.KID && self.ullBaseCounter == other.ullBaseCounter && self.ullBaseCounterRange == other.ullBaseCounterRange && self.fScrambled == other.fScrambled && self.bStreamMark == other.bStreamMark && self.dwReserved1 == other.dwReserved1 && self.dwReserved2 == other.dwReserved2
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for UDCR_TAG {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for UDCR_TAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("UDCR_TAG").field("bVersion", &self.bVersion).field("KID", &self.KID).field("ullBaseCounter", &self.ullBaseCounter).field("ullBaseCounterRange", &self.ullBaseCounterRange).field("fScrambled", &self.fScrambled).field("bStreamMark", &self.bStreamMark).field("dwReserved1", &self.dwReserved1).field("dwReserved2", &self.dwReserved2).finish()
    }
}
impl ::core::default::Default for UICloseReasonType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for UICloseReasonType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("UICloseReasonType").field(&self.0).finish()
    }
}
impl ::core::default::Default for VALID_UOP_FLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VALID_UOP_FLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VALID_UOP_FLAG").field(&self.0).finish()
    }
}
impl ::core::default::Default for VA_COLOR_PRIMARIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VA_COLOR_PRIMARIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VA_COLOR_PRIMARIES").field(&self.0).finish()
    }
}
impl ::core::default::Default for VA_MATRIX_COEFFICIENTS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VA_MATRIX_COEFFICIENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VA_MATRIX_COEFFICIENTS").field(&self.0).finish()
    }
}
impl ::core::default::Default for VA_OPTIONAL_VIDEO_PROPERTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VA_OPTIONAL_VIDEO_PROPERTIES {
    fn eq(&self, other: &Self) -> bool {
        self.dwPictureHeight == other.dwPictureHeight && self.dwPictureWidth == other.dwPictureWidth && self.dwAspectRatioX == other.dwAspectRatioX && self.dwAspectRatioY == other.dwAspectRatioY && self.VAVideoFormat == other.VAVideoFormat && self.VAColorPrimaries == other.VAColorPrimaries && self.VATransferCharacteristics == other.VATransferCharacteristics && self.VAMatrixCoefficients == other.VAMatrixCoefficients
    }
}
impl ::core::cmp::Eq for VA_OPTIONAL_VIDEO_PROPERTIES {}
impl ::core::fmt::Debug for VA_OPTIONAL_VIDEO_PROPERTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VA_OPTIONAL_VIDEO_PROPERTIES").field("dwPictureHeight", &self.dwPictureHeight).field("dwPictureWidth", &self.dwPictureWidth).field("dwAspectRatioX", &self.dwAspectRatioX).field("dwAspectRatioY", &self.dwAspectRatioY).field("VAVideoFormat", &self.VAVideoFormat).field("VAColorPrimaries", &self.VAColorPrimaries).field("VATransferCharacteristics", &self.VATransferCharacteristics).field("VAMatrixCoefficients", &self.VAMatrixCoefficients).finish()
    }
}
impl ::core::default::Default for VA_TRANSFER_CHARACTERISTICS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VA_TRANSFER_CHARACTERISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VA_TRANSFER_CHARACTERISTICS").field(&self.0).finish()
    }
}
impl ::core::default::Default for VA_VIDEO_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VA_VIDEO_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VA_VIDEO_FORMAT").field(&self.0).finish()
    }
}
impl ::core::default::Default for VFW_FILTERLIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VFW_FILTERLIST {
    fn eq(&self, other: &Self) -> bool {
        self.cFilters == other.cFilters && self.aClsId == other.aClsId
    }
}
impl ::core::cmp::Eq for VFW_FILTERLIST {}
impl ::core::fmt::Debug for VFW_FILTERLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VFW_FILTERLIST").field("cFilters", &self.cFilters).field("aClsId", &self.aClsId).finish()
    }
}
impl ::core::default::Default for VIDEOENCODER_BITRATE_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VIDEOENCODER_BITRATE_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VIDEOENCODER_BITRATE_MODE").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VIDEOINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for VIDEO_STREAM_CONFIG_CAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for VIDEO_STREAM_CONFIG_CAPS {
    fn eq(&self, other: &Self) -> bool {
        self.guid == other.guid
            && self.VideoStandard == other.VideoStandard
            && self.InputSize == other.InputSize
            && self.MinCroppingSize == other.MinCroppingSize
            && self.MaxCroppingSize == other.MaxCroppingSize
            && self.CropGranularityX == other.CropGranularityX
            && self.CropGranularityY == other.CropGranularityY
            && self.CropAlignX == other.CropAlignX
            && self.CropAlignY == other.CropAlignY
            && self.MinOutputSize == other.MinOutputSize
            && self.MaxOutputSize == other.MaxOutputSize
            && self.OutputGranularityX == other.OutputGranularityX
            && self.OutputGranularityY == other.OutputGranularityY
            && self.StretchTapsX == other.StretchTapsX
            && self.StretchTapsY == other.StretchTapsY
            && self.ShrinkTapsX == other.ShrinkTapsX
            && self.ShrinkTapsY == other.ShrinkTapsY
            && self.MinFrameInterval == other.MinFrameInterval
            && self.MaxFrameInterval == other.MaxFrameInterval
            && self.MinBitsPerSecond == other.MinBitsPerSecond
            && self.MaxBitsPerSecond == other.MaxBitsPerSecond
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for VIDEO_STREAM_CONFIG_CAPS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for VIDEO_STREAM_CONFIG_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIDEO_STREAM_CONFIG_CAPS")
            .field("guid", &self.guid)
            .field("VideoStandard", &self.VideoStandard)
            .field("InputSize", &self.InputSize)
            .field("MinCroppingSize", &self.MinCroppingSize)
            .field("MaxCroppingSize", &self.MaxCroppingSize)
            .field("CropGranularityX", &self.CropGranularityX)
            .field("CropGranularityY", &self.CropGranularityY)
            .field("CropAlignX", &self.CropAlignX)
            .field("CropAlignY", &self.CropAlignY)
            .field("MinOutputSize", &self.MinOutputSize)
            .field("MaxOutputSize", &self.MaxOutputSize)
            .field("OutputGranularityX", &self.OutputGranularityX)
            .field("OutputGranularityY", &self.OutputGranularityY)
            .field("StretchTapsX", &self.StretchTapsX)
            .field("StretchTapsY", &self.StretchTapsY)
            .field("ShrinkTapsX", &self.ShrinkTapsX)
            .field("ShrinkTapsY", &self.ShrinkTapsY)
            .field("MinFrameInterval", &self.MinFrameInterval)
            .field("MaxFrameInterval", &self.MaxFrameInterval)
            .field("MinBitsPerSecond", &self.MinBitsPerSecond)
            .field("MaxBitsPerSecond", &self.MaxBitsPerSecond)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for VMR9AllocationInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::PartialEq for VMR9AllocationInfo {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.dwWidth == other.dwWidth && self.dwHeight == other.dwHeight && self.Format == other.Format && self.Pool == other.Pool && self.MinBuffers == other.MinBuffers && self.szAspectRatio == other.szAspectRatio && self.szNativeSize == other.szNativeSize
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::Eq for VMR9AllocationInfo {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::fmt::Debug for VMR9AllocationInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9AllocationInfo").field("dwFlags", &self.dwFlags).field("dwWidth", &self.dwWidth).field("dwHeight", &self.dwHeight).field("Format", &self.Format).field("Pool", &self.Pool).field("MinBuffers", &self.MinBuffers).field("szAspectRatio", &self.szAspectRatio).field("szNativeSize", &self.szNativeSize).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VMR9AlphaBitmap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for VMR9AlphaBitmap {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.hdc == other.hdc && self.pDDS == other.pDDS && self.rSrc == other.rSrc && self.rDest == other.rDest && self.fAlpha == other.fAlpha && self.clrSrcKey == other.clrSrcKey && self.dwFilterMode == other.dwFilterMode
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for VMR9AlphaBitmap {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for VMR9AlphaBitmap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9AlphaBitmap").field("dwFlags", &self.dwFlags).field("hdc", &self.hdc).field("pDDS", &self.pDDS).field("rSrc", &self.rSrc).field("rDest", &self.rDest).field("fAlpha", &self.fAlpha).field("clrSrcKey", &self.clrSrcKey).field("dwFilterMode", &self.dwFilterMode).finish()
    }
}
impl ::core::default::Default for VMR9AlphaBitmapFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9AlphaBitmapFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9AlphaBitmapFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9AspectRatioMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9AspectRatioMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9AspectRatioMode").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9DeinterlaceCaps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMR9DeinterlaceCaps {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwNumPreviousOutputFrames == other.dwNumPreviousOutputFrames && self.dwNumForwardRefSamples == other.dwNumForwardRefSamples && self.dwNumBackwardRefSamples == other.dwNumBackwardRefSamples && self.DeinterlaceTechnology == other.DeinterlaceTechnology
    }
}
impl ::core::cmp::Eq for VMR9DeinterlaceCaps {}
impl ::core::fmt::Debug for VMR9DeinterlaceCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9DeinterlaceCaps").field("dwSize", &self.dwSize).field("dwNumPreviousOutputFrames", &self.dwNumPreviousOutputFrames).field("dwNumForwardRefSamples", &self.dwNumForwardRefSamples).field("dwNumBackwardRefSamples", &self.dwNumBackwardRefSamples).field("DeinterlaceTechnology", &self.DeinterlaceTechnology).finish()
    }
}
impl ::core::default::Default for VMR9DeinterlacePrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9DeinterlacePrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9DeinterlacePrefs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9DeinterlaceTech {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9DeinterlaceTech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9DeinterlaceTech").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9Frequency {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMR9Frequency {
    fn eq(&self, other: &Self) -> bool {
        self.dwNumerator == other.dwNumerator && self.dwDenominator == other.dwDenominator
    }
}
impl ::core::cmp::Eq for VMR9Frequency {}
impl ::core::fmt::Debug for VMR9Frequency {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9Frequency").field("dwNumerator", &self.dwNumerator).field("dwDenominator", &self.dwDenominator).finish()
    }
}
impl ::core::default::Default for VMR9MixerPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9MixerPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9MixerPrefs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9Mode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9Mode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9Mode").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VMR9MonitorInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for VMR9MonitorInfo {
    fn eq(&self, other: &Self) -> bool {
        self.uDevID == other.uDevID && self.rcMonitor == other.rcMonitor && self.hMon == other.hMon && self.dwFlags == other.dwFlags && self.szDevice == other.szDevice && self.szDescription == other.szDescription && self.liDriverVersion == other.liDriverVersion && self.dwVendorId == other.dwVendorId && self.dwDeviceId == other.dwDeviceId && self.dwSubSysId == other.dwSubSysId && self.dwRevision == other.dwRevision
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for VMR9MonitorInfo {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for VMR9MonitorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9MonitorInfo").field("uDevID", &self.uDevID).field("rcMonitor", &self.rcMonitor).field("hMon", &self.hMon).field("dwFlags", &self.dwFlags).field("szDevice", &self.szDevice).field("szDescription", &self.szDescription).field("liDriverVersion", &self.liDriverVersion).field("dwVendorId", &self.dwVendorId).field("dwDeviceId", &self.dwDeviceId).field("dwSubSysId", &self.dwSubSysId).field("dwRevision", &self.dwRevision).finish()
    }
}
impl ::core::default::Default for VMR9NormalizedRect {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMR9NormalizedRect {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left && self.top == other.top && self.right == other.right && self.bottom == other.bottom
    }
}
impl ::core::cmp::Eq for VMR9NormalizedRect {}
impl ::core::fmt::Debug for VMR9NormalizedRect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9NormalizedRect").field("left", &self.left).field("top", &self.top).field("right", &self.right).field("bottom", &self.bottom).finish()
    }
}
impl ::core::default::Default for VMR9PresentationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9PresentationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9PresentationFlags").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for VMR9PresentationInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::PartialEq for VMR9PresentationInfo {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.lpSurf == other.lpSurf && self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.szAspectRatio == other.szAspectRatio && self.rcSrc == other.rcSrc && self.rcDst == other.rcDst && self.dwReserved1 == other.dwReserved1 && self.dwReserved2 == other.dwReserved2
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::Eq for VMR9PresentationInfo {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::fmt::Debug for VMR9PresentationInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9PresentationInfo").field("dwFlags", &self.dwFlags).field("lpSurf", &self.lpSurf).field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("szAspectRatio", &self.szAspectRatio).field("rcSrc", &self.rcSrc).field("rcDst", &self.rcDst).field("dwReserved1", &self.dwReserved1).field("dwReserved2", &self.dwReserved2).finish()
    }
}
impl ::core::default::Default for VMR9ProcAmpControl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMR9ProcAmpControl {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwFlags == other.dwFlags && self.Brightness == other.Brightness && self.Contrast == other.Contrast && self.Hue == other.Hue && self.Saturation == other.Saturation
    }
}
impl ::core::cmp::Eq for VMR9ProcAmpControl {}
impl ::core::fmt::Debug for VMR9ProcAmpControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9ProcAmpControl").field("dwSize", &self.dwSize).field("dwFlags", &self.dwFlags).field("Brightness", &self.Brightness).field("Contrast", &self.Contrast).field("Hue", &self.Hue).field("Saturation", &self.Saturation).finish()
    }
}
impl ::core::default::Default for VMR9ProcAmpControlFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9ProcAmpControlFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9ProcAmpControlFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9ProcAmpControlRange {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMR9ProcAmpControlRange {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwProperty == other.dwProperty && self.MinValue == other.MinValue && self.MaxValue == other.MaxValue && self.DefaultValue == other.DefaultValue && self.StepSize == other.StepSize
    }
}
impl ::core::cmp::Eq for VMR9ProcAmpControlRange {}
impl ::core::fmt::Debug for VMR9ProcAmpControlRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9ProcAmpControlRange").field("dwSize", &self.dwSize).field("dwProperty", &self.dwProperty).field("MinValue", &self.MinValue).field("MaxValue", &self.MaxValue).field("DefaultValue", &self.DefaultValue).field("StepSize", &self.StepSize).finish()
    }
}
impl ::core::default::Default for VMR9RenderPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9RenderPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9RenderPrefs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9SurfaceAllocationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9SurfaceAllocationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9SurfaceAllocationFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMR9VideoDesc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMR9VideoDesc {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwSampleWidth == other.dwSampleWidth && self.dwSampleHeight == other.dwSampleHeight && self.SampleFormat == other.SampleFormat && self.dwFourCC == other.dwFourCC && self.InputSampleFreq == other.InputSampleFreq && self.OutputFrameFreq == other.OutputFrameFreq
    }
}
impl ::core::cmp::Eq for VMR9VideoDesc {}
impl ::core::fmt::Debug for VMR9VideoDesc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9VideoDesc").field("dwSize", &self.dwSize).field("dwSampleWidth", &self.dwSampleWidth).field("dwSampleHeight", &self.dwSampleHeight).field("SampleFormat", &self.SampleFormat).field("dwFourCC", &self.dwFourCC).field("InputSampleFreq", &self.InputSampleFreq).field("OutputFrameFreq", &self.OutputFrameFreq).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for VMR9VideoStreamInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for VMR9VideoStreamInfo {
    fn eq(&self, other: &Self) -> bool {
        self.pddsVideoSurface == other.pddsVideoSurface && self.dwWidth == other.dwWidth && self.dwHeight == other.dwHeight && self.dwStrmID == other.dwStrmID && self.fAlpha == other.fAlpha && self.rNormal == other.rNormal && self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.SampleFormat == other.SampleFormat
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for VMR9VideoStreamInfo {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for VMR9VideoStreamInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMR9VideoStreamInfo").field("pddsVideoSurface", &self.pddsVideoSurface).field("dwWidth", &self.dwWidth).field("dwHeight", &self.dwHeight).field("dwStrmID", &self.dwStrmID).field("fAlpha", &self.fAlpha).field("rNormal", &self.rNormal).field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("SampleFormat", &self.SampleFormat).finish()
    }
}
impl ::core::default::Default for VMR9_SampleFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR9_SampleFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR9_SampleFormat").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VMRALLOCATIONINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for VMRALLOCATIONINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.lpHdr == other.lpHdr && self.lpPixFmt == other.lpPixFmt && self.szAspectRatio == other.szAspectRatio && self.dwMinBuffers == other.dwMinBuffers && self.dwMaxBuffers == other.dwMaxBuffers && self.dwInterlaceFlags == other.dwInterlaceFlags && self.szNativeSize == other.szNativeSize
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for VMRALLOCATIONINFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for VMRALLOCATIONINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRALLOCATIONINFO").field("dwFlags", &self.dwFlags).field("lpHdr", &self.lpHdr).field("lpPixFmt", &self.lpPixFmt).field("szAspectRatio", &self.szAspectRatio).field("dwMinBuffers", &self.dwMinBuffers).field("dwMaxBuffers", &self.dwMaxBuffers).field("dwInterlaceFlags", &self.dwInterlaceFlags).field("szNativeSize", &self.szNativeSize).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VMRALPHABITMAP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for VMRALPHABITMAP {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.hdc == other.hdc && self.pDDS == other.pDDS && self.rSrc == other.rSrc && self.rDest == other.rDest && self.fAlpha == other.fAlpha && self.clrSrcKey == other.clrSrcKey
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for VMRALPHABITMAP {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for VMRALPHABITMAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRALPHABITMAP").field("dwFlags", &self.dwFlags).field("hdc", &self.hdc).field("pDDS", &self.pDDS).field("rSrc", &self.rSrc).field("rDest", &self.rDest).field("fAlpha", &self.fAlpha).field("clrSrcKey", &self.clrSrcKey).finish()
    }
}
impl ::core::default::Default for VMRDeinterlaceCaps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMRDeinterlaceCaps {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwNumPreviousOutputFrames == other.dwNumPreviousOutputFrames && self.dwNumForwardRefSamples == other.dwNumForwardRefSamples && self.dwNumBackwardRefSamples == other.dwNumBackwardRefSamples && self.DeinterlaceTechnology == other.DeinterlaceTechnology
    }
}
impl ::core::cmp::Eq for VMRDeinterlaceCaps {}
impl ::core::fmt::Debug for VMRDeinterlaceCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRDeinterlaceCaps").field("dwSize", &self.dwSize).field("dwNumPreviousOutputFrames", &self.dwNumPreviousOutputFrames).field("dwNumForwardRefSamples", &self.dwNumForwardRefSamples).field("dwNumBackwardRefSamples", &self.dwNumBackwardRefSamples).field("DeinterlaceTechnology", &self.DeinterlaceTechnology).finish()
    }
}
impl ::core::default::Default for VMRDeinterlacePrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRDeinterlacePrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRDeinterlacePrefs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMRDeinterlaceTech {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRDeinterlaceTech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRDeinterlaceTech").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMRFrequency {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMRFrequency {
    fn eq(&self, other: &Self) -> bool {
        self.dwNumerator == other.dwNumerator && self.dwDenominator == other.dwDenominator
    }
}
impl ::core::cmp::Eq for VMRFrequency {}
impl ::core::fmt::Debug for VMRFrequency {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRFrequency").field("dwNumerator", &self.dwNumerator).field("dwDenominator", &self.dwDenominator).finish()
    }
}
impl ::core::default::Default for VMRGUID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::cmp::PartialEq for VMRGUID {
    fn eq(&self, other: &Self) -> bool {
        self.pGUID == other.pGUID && self.GUID == other.GUID
    }
}
impl ::core::cmp::Eq for VMRGUID {}
impl ::core::fmt::Debug for VMRGUID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRGUID").field("pGUID", &self.pGUID).field("GUID", &self.GUID).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VMRMONITORINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for VMRMONITORINFO {
    fn eq(&self, other: &Self) -> bool {
        self.guid == other.guid && self.rcMonitor == other.rcMonitor && self.hMon == other.hMon && self.dwFlags == other.dwFlags && self.szDevice == other.szDevice && self.szDescription == other.szDescription && self.liDriverVersion == other.liDriverVersion && self.dwVendorId == other.dwVendorId && self.dwDeviceId == other.dwDeviceId && self.dwSubSysId == other.dwSubSysId && self.dwRevision == other.dwRevision
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for VMRMONITORINFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for VMRMONITORINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRMONITORINFO").field("guid", &self.guid).field("rcMonitor", &self.rcMonitor).field("hMon", &self.hMon).field("dwFlags", &self.dwFlags).field("szDevice", &self.szDevice).field("szDescription", &self.szDescription).field("liDriverVersion", &self.liDriverVersion).field("dwVendorId", &self.dwVendorId).field("dwDeviceId", &self.dwDeviceId).field("dwSubSysId", &self.dwSubSysId).field("dwRevision", &self.dwRevision).finish()
    }
}
impl ::core::default::Default for VMRMixerPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRMixerPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRMixerPrefs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMRMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRMode").field(&self.0).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::default::Default for VMRPRESENTATIONINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::cmp::PartialEq for VMRPRESENTATIONINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.lpSurf == other.lpSurf && self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.szAspectRatio == other.szAspectRatio && self.rcSrc == other.rcSrc && self.rcDst == other.rcDst && self.dwTypeSpecificFlags == other.dwTypeSpecificFlags && self.dwInterlaceFlags == other.dwInterlaceFlags
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::cmp::Eq for VMRPRESENTATIONINFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::fmt::Debug for VMRPRESENTATIONINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRPRESENTATIONINFO").field("dwFlags", &self.dwFlags).field("lpSurf", &self.lpSurf).field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("szAspectRatio", &self.szAspectRatio).field("rcSrc", &self.rcSrc).field("rcDst", &self.rcDst).field("dwTypeSpecificFlags", &self.dwTypeSpecificFlags).field("dwInterlaceFlags", &self.dwInterlaceFlags).finish()
    }
}
impl ::core::default::Default for VMRPresentationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRPresentationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRPresentationFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMRRenderPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRRenderPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRRenderPrefs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VMRSurfaceAllocationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMRSurfaceAllocationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMRSurfaceAllocationFlags").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::default::Default for VMRVIDEOSTREAMINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::cmp::PartialEq for VMRVIDEOSTREAMINFO {
    fn eq(&self, other: &Self) -> bool {
        self.pddsVideoSurface == other.pddsVideoSurface && self.dwWidth == other.dwWidth && self.dwHeight == other.dwHeight && self.dwStrmID == other.dwStrmID && self.fAlpha == other.fAlpha && self.ddClrKey == other.ddClrKey && self.rNormal == other.rNormal
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::cmp::Eq for VMRVIDEOSTREAMINFO {}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::fmt::Debug for VMRVIDEOSTREAMINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRVIDEOSTREAMINFO").field("pddsVideoSurface", &self.pddsVideoSurface).field("dwWidth", &self.dwWidth).field("dwHeight", &self.dwHeight).field("dwStrmID", &self.dwStrmID).field("fAlpha", &self.fAlpha).field("ddClrKey", &self.ddClrKey).field("rNormal", &self.rNormal).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for VMRVideoDesc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for VMRVideoDesc {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwSampleWidth == other.dwSampleWidth && self.dwSampleHeight == other.dwSampleHeight && self.SingleFieldPerSample == other.SingleFieldPerSample && self.dwFourCC == other.dwFourCC && self.InputSampleFreq == other.InputSampleFreq && self.OutputFrameFreq == other.OutputFrameFreq
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for VMRVideoDesc {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for VMRVideoDesc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMRVideoDesc").field("dwSize", &self.dwSize).field("dwSampleWidth", &self.dwSampleWidth).field("dwSampleHeight", &self.dwSampleHeight).field("SingleFieldPerSample", &self.SingleFieldPerSample).field("dwFourCC", &self.dwFourCC).field("InputSampleFreq", &self.InputSampleFreq).field("OutputFrameFreq", &self.OutputFrameFreq).finish()
    }
}
impl ::core::default::Default for VMR_ASPECT_RATIO_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VMR_ASPECT_RATIO_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VMR_ASPECT_RATIO_MODE").field(&self.0).finish()
    }
}
impl ::core::default::Default for VfwCaptureDialogs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VfwCaptureDialogs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VfwCaptureDialogs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VfwCompressDialogs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VfwCompressDialogs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VfwCompressDialogs").field(&self.0).finish()
    }
}
impl ::core::default::Default for VideoControlFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VideoControlFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VideoControlFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for VideoCopyProtectionType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VideoCopyProtectionType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VideoCopyProtectionType").field(&self.0).finish()
    }
}
impl ::core::default::Default for VideoProcAmpFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VideoProcAmpFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VideoProcAmpFlags").field(&self.0).finish()
    }
}
impl ::core::default::Default for VideoProcAmpProperty {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VideoProcAmpProperty {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VideoProcAmpProperty").field(&self.0).finish()
    }
}
impl ::core::default::Default for WMDRMProtectionInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for _AMRESCTL_RESERVEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AMRESCTL_RESERVEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AMRESCTL_RESERVEFLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AMSTREAMSELECTENABLEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AMSTREAMSELECTENABLEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AMSTREAMSELECTENABLEFLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AMSTREAMSELECTINFOFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AMSTREAMSELECTINFOFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AMSTREAMSELECTINFOFLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_AUDIO_RENDERER_STAT_PARAM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_AUDIO_RENDERER_STAT_PARAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_AUDIO_RENDERER_STAT_PARAM").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_FILTER_MISC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_FILTER_MISC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_FILTER_MISC_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_INTF_SEARCH_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_INTF_SEARCH_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_INTF_SEARCH_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_OVERLAY_NOTIFY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_OVERLAY_NOTIFY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_OVERLAY_NOTIFY_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_PIN_FLOW_CONTROL_BLOCK_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_PUSHSOURCE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_PUSHSOURCE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_PUSHSOURCE_FLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _AM_RENSDEREXFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _AM_RENSDEREXFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_AM_RENSDEREXFLAGS").field(&self.0).finish()
    }
}
impl ::core::default::Default for _DVDECODERRESOLUTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _DVDECODERRESOLUTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_DVDECODERRESOLUTION").field(&self.0).finish()
    }
}
impl ::core::default::Default for _DVENCODERFORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _DVENCODERFORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_DVENCODERFORMAT").field(&self.0).finish()
    }
}
impl ::core::default::Default for _DVENCODERRESOLUTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _DVENCODERRESOLUTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_DVENCODERRESOLUTION").field(&self.0).finish()
    }
}
impl ::core::default::Default for _DVENCODERVIDEOFORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _DVENCODERVIDEOFORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_DVENCODERVIDEOFORMAT").field(&self.0).finish()
    }
}
impl ::core::default::Default for _DVRESOLUTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _DVRESOLUTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_DVRESOLUTION").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::PartialEq for _IMSVidCtlEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::core::cmp::Eq for _IMSVidCtlEvents {}
#[cfg(feature = "Win32_System_Com")]
impl ::core::fmt::Debug for _IMSVidCtlEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_IMSVidCtlEvents").field(&self.0).finish()
    }
}
impl ::core::default::Default for _REM_FILTER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _REM_FILTER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_REM_FILTER_FLAGS").field(&self.0).finish()
    }
}
